{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, historyState } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n"],"names":["restoreReducer","state","action","url","historyState","href","createHrefFromUrl","treeToRestore","renderedSearch","tree","oldCache","cache","newCache","process","env","__NEXT_PPR","updateCacheNodeOnPopstateRestoration","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","nextUrl","extractPathFromFlightRouterState","pathname","previousNextUrl","debugInfo"],"mappings":";;;;+BAUgBA;;;eAAAA;;;mCAVkB;oCAMe;gCACI;AAG9C,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,YAAY,EAAE,GAAGF;IAC9B,MAAMG,OAAOC,IAAAA,oCAAiB,EAACH;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAII;IACJ,IAAIC;IACJ,IAAIJ,cAAc;QAChBG,gBAAgBH,aAAaK,IAAI;QACjCD,iBAAiBJ,aAAaI,cAAc;IAC9C,OAAO;QACLD,gBAAgBN,MAAMQ,IAAI;QAC1BD,iBAAiBP,MAAMO,cAAc;IACvC;IAEA,MAAME,WAAWT,MAAMU,KAAK;IAC5B,MAAMC,WAAWC,QAAQC,GAAG,CAACC,UAAU,GAEnC,qEAAqE;IACrE,2DAA2D;IAC3D,2BAA2B;IAC3BC,IAAAA,oDAAoC,EAACN,UAAUH,iBAC/CG;IAEJ,OAAO;QACL,oBAAoB;QACpBO,cAAcZ;QACdG;QACAU,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBrB,MAAMqB,iBAAiB;QAC1CX,OAAOC;QACP,wBAAwB;QACxBH,MAAMF;QACNgB,SAASC,IAAAA,oDAAgC,EAACjB,kBAAkBJ,IAAIsB,QAAQ;QACxEC,iBAAiB;QACjBC,WAAW;IACb;AACF","ignoreList":[0]}