{"version":3,"sources":["../../../../../src/client/dev/hot-reloader/app/hot-reloader-app.tsx"],"sourcesContent":["/// <reference types=\"webpack/module.d.ts\" />\n\nimport type { ReactNode } from 'react'\nimport { useEffect, startTransition } from 'react'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\nimport formatWebpackMessages from '../../../../shared/lib/format-webpack-messages'\nimport {\n  REACT_REFRESH_FULL_RELOAD,\n  REACT_REFRESH_FULL_RELOAD_FROM_ERROR,\n} from '../shared'\nimport {\n  dispatcher,\n  getSerializedOverlayState,\n  getSegmentTrieData,\n} from 'next/dist/compiled/next-devtools'\nimport { ReplaySsrOnlyErrors } from '../../../../next-devtools/userspace/app/errors/replay-ssr-only-errors'\nimport { AppDevOverlayErrorBoundary } from '../../../../next-devtools/userspace/app/app-dev-overlay-error-boundary'\nimport { useErrorHandler } from '../../../../next-devtools/userspace/app/errors/use-error-handler'\nimport { RuntimeErrorHandler } from '../../runtime-error-handler'\nimport { useWebSocketPing } from './web-socket'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  HMR_MESSAGE_SENT_TO_SERVER,\n} from '../../../../server/dev/hot-reloader-types'\nimport type {\n  HmrMessageSentToBrowser,\n  TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport type { McpErrorStateResponse } from '../../../../shared/lib/mcp-error-types'\nimport type { McpPageMetadataResponse } from '../../../../shared/lib/mcp-page-metadata-types'\nimport { useUntrackedPathname } from '../../../components/navigation-untracked'\nimport reportHmrLatency from '../../report-hmr-latency'\nimport { TurbopackHmr } from '../turbopack-hot-reloader-common'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../../components/app-router-headers'\nimport {\n  publicAppRouterInstance,\n  type GlobalErrorState,\n} from '../../../components/app-router-instance'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { getOrCreateDebugChannelReadableWriterPair } from '../../debug-channel'\n\nexport interface StaticIndicatorState {\n  pathname: string | null\n  appIsrManifest: Record<string, boolean> | null\n}\n\nlet mostRecentCompilationHash: any = null\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now())\nlet reloading = false\nlet webpackStartMsSinceEpoch: number | null = null\nconst turbopackHmr: TurbopackHmr | null = process.env.TURBOPACK\n  ? new TurbopackHmr()\n  : null\n\nlet pendingHotUpdateWebpack = Promise.resolve()\nlet resolvePendingHotUpdateWebpack: () => void = () => {}\nfunction setPendingHotUpdateWebpack() {\n  pendingHotUpdateWebpack = new Promise((resolve) => {\n    resolvePendingHotUpdateWebpack = () => {\n      resolve()\n    }\n  })\n}\n\nexport function waitForWebpackRuntimeHotUpdate() {\n  return pendingHotUpdateWebpack\n}\n\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash: string) {\n  // Update last known compilation hash.\n  mostRecentCompilationHash = hash\n}\n\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */\nfunction isUpdateAvailable() {\n  if (process.env.TURBOPACK) {\n    return true\n  }\n\n  /* globals __webpack_hash__ */\n  // __webpack_hash__ is the hash of the current compilation.\n  // It's a global variable injected by Webpack.\n  return mostRecentCompilationHash !== __webpack_hash__\n}\n\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n  return module.hot.status() === 'idle'\n}\nfunction afterApplyUpdates(fn: any) {\n  if (canApplyUpdates()) {\n    fn()\n  } else {\n    function handler(status: any) {\n      if (status === 'idle') {\n        module.hot.removeStatusHandler(handler)\n        fn()\n      }\n    }\n    module.hot.addStatusHandler(handler)\n  }\n}\n\nexport function performFullReload(\n  err: any,\n  sendMessage: (data: string) => void\n) {\n  const stackTrace =\n    err &&\n    ((err.stack && err.stack.split('\\n').slice(0, 5).join('\\n')) ||\n      err.message ||\n      err + '')\n\n  sendMessage(\n    JSON.stringify({\n      event: 'client-full-reload',\n      stackTrace,\n      hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,\n      dependencyChain: err ? err.dependencyChain : undefined,\n    })\n  )\n\n  if (reloading) return\n  reloading = true\n  window.location.reload()\n}\n\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage: (message: string) => void) {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    resolvePendingHotUpdateWebpack()\n    dispatcher.onBuildOk()\n    reportHmrLatency(sendMessage, [], webpackStartMsSinceEpoch!, Date.now())\n    return\n  }\n\n  function handleApplyUpdates(\n    err: any,\n    updatedModules: (string | number)[] | null\n  ) {\n    if (err || RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n      if (err) {\n        console.warn(REACT_REFRESH_FULL_RELOAD)\n      } else if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n      }\n      performFullReload(err, sendMessage)\n      return\n    }\n\n    dispatcher.onBuildOk()\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdatesWebpack(sendMessage)\n      return\n    }\n\n    dispatcher.onRefresh()\n    resolvePendingHotUpdateWebpack()\n    reportHmrLatency(\n      sendMessage,\n      updatedModules,\n      webpackStartMsSinceEpoch!,\n      Date.now()\n    )\n\n    if (process.env.__NEXT_TEST_MODE) {\n      afterApplyUpdates(() => {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      })\n    }\n  }\n\n  // https://webpack.js.org/api/hot-module-replacement/#check\n  module.hot\n    .check(/* autoApply */ false)\n    .then((updatedModules: (string | number)[] | null) => {\n      if (updatedModules == null) {\n        return null\n      }\n\n      // We should always handle an update, even if updatedModules is empty (but\n      // non-null) for any reason. That's what webpack would normally do:\n      // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n      dispatcher.onBeforeRefresh()\n      // https://webpack.js.org/api/hot-module-replacement/#apply\n      return module.hot.apply()\n    })\n    .then(\n      (updatedModules: (string | number)[] | null) => {\n        handleApplyUpdates(null, updatedModules)\n      },\n      (err: any) => {\n        handleApplyUpdates(err, null)\n      }\n    )\n}\n\n/** Handles messages from the server for the App Router. */\nexport function processMessage(\n  message: HmrMessageSentToBrowser,\n  sendMessage: (message: string) => void,\n  processTurbopackMessage: (msg: TurbopackMessageSentToBrowser) => void,\n  staticIndicatorState: StaticIndicatorState\n) {\n  function handleErrors(errors: ReadonlyArray<unknown>) {\n    // \"Massage\" webpack messages.\n    const formatted = formatWebpackMessages({\n      errors: errors,\n      warnings: [],\n    })\n\n    // Only show the first error.\n    dispatcher.onBuildError(formatted.errors[0])\n\n    // Also log them to the console.\n    for (let i = 0; i < formatted.errors.length; i++) {\n      console.error(stripAnsi(formatted.errors[i]))\n    }\n\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (process.env.__NEXT_TEST_MODE) {\n      if (self.__NEXT_HMR_CB) {\n        self.__NEXT_HMR_CB(formatted.errors[0])\n        self.__NEXT_HMR_CB = null\n      }\n    }\n  }\n\n  function handleHotUpdate() {\n    if (process.env.TURBOPACK) {\n      const hmrUpdate = turbopackHmr!.onBuilt()\n      if (hmrUpdate != null) {\n        reportHmrLatency(\n          sendMessage,\n          [...hmrUpdate.updatedModules],\n          hmrUpdate.startMsSinceEpoch,\n          hmrUpdate.endMsSinceEpoch,\n          // suppress the `client-hmr-latency` event if the update was a no-op:\n          hmrUpdate.hasUpdates\n        )\n      }\n      dispatcher.onBuildOk()\n    } else {\n      tryApplyUpdatesWebpack(sendMessage)\n    }\n  }\n\n  switch (message.type) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST: {\n      if (process.env.__NEXT_DEV_INDICATOR) {\n        staticIndicatorState.appIsrManifest = message.data\n\n        // Handle the initial static indicator status on receiving the ISR\n        // manifest. Navigation is handled in an effect inside HotReload for\n        // pathname changes as we'll receive the updated manifest before\n        // usePathname triggers for a new value.\n\n        const isStatic = staticIndicatorState.pathname\n          ? message.data[staticIndicatorState.pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILDING: {\n      dispatcher.buildingIndicatorShow()\n\n      if (process.env.TURBOPACK) {\n        turbopackHmr!.onBuilding()\n      } else {\n        webpackStartMsSinceEpoch = Date.now()\n        setPendingHotUpdateWebpack()\n        console.log('[Fast Refresh] rebuilding')\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILT:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SYNC: {\n      dispatcher.buildingIndicatorHide()\n\n      if (message.hash) {\n        handleAvailableHash(message.hash)\n      }\n\n      const { errors, warnings } = message\n\n      // Is undefined when it's a 'built' event\n      if ('versionInfo' in message)\n        dispatcher.onVersionInfo(message.versionInfo)\n      if ('debug' in message && message.debug)\n        dispatcher.onDebugInfo(message.debug)\n      if ('devIndicator' in message)\n        dispatcher.onDevIndicator(message.devIndicator)\n      if ('devToolsConfig' in message)\n        dispatcher.onDevToolsConfig(message.devToolsConfig)\n\n      const hasErrors = Boolean(errors && errors.length)\n      // Compilation with errors (e.g. syntax error or missing modules).\n      if (hasErrors) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-error',\n            errorCount: errors.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        handleErrors(errors)\n        return\n      }\n\n      const hasWarnings = Boolean(warnings && warnings.length)\n      if (hasWarnings) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-warning',\n            warningCount: warnings.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        // Print warnings to the console.\n        const formattedMessages = formatWebpackMessages({\n          warnings: warnings,\n          errors: [],\n        })\n\n        for (let i = 0; i < formattedMessages.warnings.length; i++) {\n          if (i === 5) {\n            console.warn(\n              'There were more warnings in other files.\\n' +\n                'You can find a complete log in the terminal.'\n            )\n            break\n          }\n          console.warn(stripAnsi(formattedMessages.warnings[i]))\n        }\n\n        // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n      }\n\n      sendMessage(\n        JSON.stringify({\n          event: 'client-success',\n          clientId: __nextDevClientId,\n        })\n      )\n\n      if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.BUILT) {\n        handleHotUpdate()\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED: {\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n        data: {\n          sessionId: message.data.sessionId,\n        },\n      })\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE: {\n      turbopackHmr!.onTurbopackMessage(message)\n      dispatcher.onBeforeRefresh()\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n        data: message.data,\n      })\n      if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n        performFullReload(null, sendMessage)\n      }\n      dispatcher.onRefresh()\n      break\n    }\n    // TODO-APP: make server component change more granular\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES: {\n      turbopackHmr?.onServerComponentChanges()\n      sendMessage(\n        JSON.stringify({\n          event: 'server-component-reload-page',\n          clientId: __nextDevClientId,\n          hash: message.hash,\n        })\n      )\n\n      // Store the latest hash in a session cookie so that it's sent back to the\n      // server with any subsequent requests.\n      document.cookie = `${NEXT_HMR_REFRESH_HASH_COOKIE}=${message.hash};path=/`\n\n      if (\n        RuntimeErrorHandler.hadRuntimeError ||\n        document.documentElement.id === '__next_error__'\n      ) {\n        if (reloading) return\n        reloading = true\n        return window.location.reload()\n      }\n\n      startTransition(() => {\n        publicAppRouterInstance.hmrRefresh()\n        dispatcher.onRefresh()\n      })\n\n      if (process.env.__NEXT_TEST_MODE) {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE: {\n      turbopackHmr?.onReloadPage()\n      sendMessage(\n        JSON.stringify({\n          event: 'client-reload-page',\n          clientId: __nextDevClientId,\n        })\n      )\n      if (reloading) return\n      reloading = true\n      return window.location.reload()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE:\n    case HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE: {\n      turbopackHmr?.onPageAddRemove()\n      // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n      return publicAppRouterInstance.hmrRefresh()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR: {\n      const { errorJSON } = message\n      if (errorJSON) {\n        const errorObject = JSON.parse(errorJSON)\n        const error = new Error(errorObject.message)\n        error.stack = errorObject.stack\n        handleErrors([error])\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE: {\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG: {\n      dispatcher.onDevToolsConfig(message.data)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      const { requestId, chunk } = message\n      const { writer } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n      if (chunk) {\n        writer.ready.then(() => writer.write(chunk)).catch(console.error)\n      } else {\n        // A null chunk signals that no more chunks will be sent, which allows\n        // us to close the writer.\n        // TODO: Revisit this cleanup logic when we integrate the return channel\n        // that keeps the connection open to be able to lazily retrieve debug\n        // objects.\n        writer.ready.then(() => writer.close()).catch(console.error)\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE: {\n      const errorState = getSerializedOverlayState()\n      const response: McpErrorStateResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_ERROR_STATE_RESPONSE,\n        requestId: message.requestId,\n        errorState,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA: {\n      const segmentTrieData = getSegmentTrieData()\n      const response: McpPageMetadataResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_PAGE_METADATA_RESPONSE,\n        requestId: message.requestId,\n        segmentTrieData,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR: {\n      dispatcher.onCacheIndicator(message.state)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES:\n      // These action types are handled in src/client/page-bootstrap.ts\n      break\n    default: {\n      message satisfies never\n    }\n  }\n}\n\nexport default function HotReload({\n  children,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  children: ReactNode\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  useErrorHandler(dispatcher.onUnhandledError, dispatcher.onUnhandledRejection)\n  useWebSocketPing(webSocket)\n\n  // We don't want access of the pathname for the dev tools to trigger a dynamic\n  // access (as the dev overlay will never be present in production).\n  const pathname = useUntrackedPathname()\n\n  if (process.env.__NEXT_DEV_INDICATOR) {\n    // this conditional is only for dead-code elimination which\n    // isn't a runtime conditional only build-time so ignore hooks rule\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!staticIndicatorState) {\n        throw new InvariantError(\n          'Expected staticIndicatorState to be defined in dev mode.'\n        )\n      }\n\n      staticIndicatorState.pathname = pathname\n\n      if (staticIndicatorState.appIsrManifest) {\n        const isStatic = pathname\n          ? staticIndicatorState.appIsrManifest[pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n    }, [pathname, staticIndicatorState])\n  }\n\n  return (\n    <AppDevOverlayErrorBoundary globalError={globalError}>\n      <ReplaySsrOnlyErrors onBlockingError={dispatcher.openErrorOverlay} />\n      {children}\n    </AppDevOverlayErrorBoundary>\n  )\n}\n"],"names":["HotReload","performFullReload","processMessage","waitForWebpackRuntimeHotUpdate","mostRecentCompilationHash","__nextDevClientId","Math","round","random","Date","now","reloading","webpackStartMsSinceEpoch","turbopackHmr","process","env","TURBOPACK","TurbopackHmr","pendingHotUpdateWebpack","Promise","resolve","resolvePendingHotUpdateWebpack","setPendingHotUpdateWebpack","handleAvailableHash","hash","isUpdateAvailable","__webpack_hash__","canApplyUpdates","module","hot","status","afterApplyUpdates","fn","handler","removeStatusHandler","addStatusHandler","err","sendMessage","stackTrace","stack","split","slice","join","message","JSON","stringify","event","hadRuntimeError","RuntimeErrorHandler","dependencyChain","undefined","window","location","reload","tryApplyUpdatesWebpack","dispatcher","onBuildOk","reportHmrLatency","handleApplyUpdates","updatedModules","console","warn","REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","onRefresh","__NEXT_TEST_MODE","self","__NEXT_HMR_CB","check","then","onBeforeRefresh","apply","processTurbopackMessage","staticIndicatorState","handleErrors","errors","formatted","formatWebpackMessages","warnings","onBuildError","i","length","error","stripAnsi","handleHotUpdate","hmrUpdate","onBuilt","startMsSinceEpoch","endMsSinceEpoch","hasUpdates","type","HMR_MESSAGE_SENT_TO_BROWSER","ISR_MANIFEST","__NEXT_DEV_INDICATOR","appIsrManifest","data","isStatic","pathname","onStaticIndicator","BUILDING","buildingIndicatorShow","onBuilding","log","BUILT","SYNC","buildingIndicatorHide","onVersionInfo","versionInfo","debug","onDebugInfo","onDevIndicator","devIndicator","onDevToolsConfig","devToolsConfig","hasErrors","Boolean","errorCount","clientId","hasWarnings","warningCount","formattedMessages","TURBOPACK_CONNECTED","sessionId","TURBOPACK_MESSAGE","onTurbopackMessage","SERVER_COMPONENT_CHANGES","onServerComponentChanges","document","cookie","NEXT_HMR_REFRESH_HASH_COOKIE","documentElement","id","startTransition","publicAppRouterInstance","hmrRefresh","RELOAD_PAGE","onReloadPage","ADDED_PAGE","REMOVED_PAGE","onPageAddRemove","SERVER_ERROR","errorJSON","errorObject","parse","Error","DEV_PAGES_MANIFEST_UPDATE","DEVTOOLS_CONFIG","REACT_DEBUG_CHUNK","requestId","chunk","writer","getOrCreateDebugChannelReadableWriterPair","ready","write","catch","close","REQUEST_CURRENT_ERROR_STATE","errorState","getSerializedOverlayState","response","HMR_MESSAGE_SENT_TO_SERVER","MCP_ERROR_STATE_RESPONSE","url","href","REQUEST_PAGE_METADATA","segmentTrieData","getSegmentTrieData","MCP_PAGE_METADATA_RESPONSE","CACHE_INDICATOR","onCacheIndicator","state","MIDDLEWARE_CHANGES","CLIENT_CHANGES","SERVER_ONLY_CHANGES","children","globalError","webSocket","useErrorHandler","onUnhandledError","onUnhandledRejection","useWebSocketPing","useUntrackedPathname","useEffect","InvariantError","AppDevOverlayErrorBoundary","ReplaySsrOnlyErrors","onBlockingError","openErrorOverlay"],"mappings":"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","ignoreList":[0]}