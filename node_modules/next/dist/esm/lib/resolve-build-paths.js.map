{"version":3,"sources":["../../src/lib/resolve-build-paths.ts"],"sourcesContent":["import { promisify } from 'util'\nimport globOriginal from 'next/dist/compiled/glob'\nimport * as Log from '../build/output/log'\nimport path from 'path'\nimport fs from 'fs'\nimport isError from './is-error'\n\nconst glob = promisify(globOriginal)\n\ninterface ResolvedBuildPaths {\n  appPaths: string[]\n  pagePaths: string[]\n}\n\n/**\n * Resolves glob patterns and explicit paths to actual file paths\n * Categorizes them into App Router and Pages Router paths\n *\n * @param patterns - Array of glob patterns or explicit paths\n * @param projectDir - Root project directory\n * @returns Object with categorized app and page paths\n */\nexport async function resolveBuildPaths(\n  patterns: string[],\n  projectDir: string\n): Promise<ResolvedBuildPaths> {\n  const appPaths: Set<string> = new Set()\n  const pagePaths: Set<string> = new Set()\n\n  for (const pattern of patterns) {\n    const trimmed = pattern.trim()\n\n    if (!trimmed) {\n      continue\n    }\n\n    // Detect if pattern is glob pattern (contains glob special chars)\n    const isGlobPattern = /[*?[\\]{}!]/.test(trimmed)\n\n    if (isGlobPattern) {\n      try {\n        // Resolve glob pattern\n        const matches = (await glob(trimmed, {\n          cwd: projectDir,\n        })) as string[]\n\n        if (matches.length === 0) {\n          Log.warn(`Glob pattern \"${trimmed}\" did not match any files`)\n        }\n\n        for (const file of matches) {\n          // Skip directories, only process files\n          if (!fs.statSync(path.join(projectDir, file)).isDirectory()) {\n            categorizeAndAddPath(file, appPaths, pagePaths)\n          }\n        }\n      } catch (error) {\n        throw new Error(\n          `Failed to resolve glob pattern \"${trimmed}\": ${\n            isError(error) ? error.message : String(error)\n          }`\n        )\n      }\n    } else {\n      // Explicit path - categorize based on prefix\n      categorizeAndAddPath(trimmed, appPaths, pagePaths, projectDir)\n    }\n  }\n\n  return {\n    appPaths: Array.from(appPaths).sort(),\n    pagePaths: Array.from(pagePaths).sort(),\n  }\n}\n\n/**\n * Categorizes a file path to either app or pages router based on its prefix,\n * and normalizes it to the format expected by Next.js internal build system.\n *\n * The internal build system expects:\n * - App router: paths with leading slash (e.g., \"/page.tsx\", \"/dashboard/page.tsx\")\n * - Pages router: paths with leading slash (e.g., \"/index.tsx\", \"/about.tsx\")\n *\n * Examples:\n * - \"app/page.tsx\" → appPaths.add(\"/page.tsx\")\n * - \"app/dashboard/page.tsx\" → appPaths.add(\"/dashboard/page.tsx\")\n * - \"pages/index.tsx\" → pagePaths.add(\"/index.tsx\")\n * - \"pages/about.tsx\" → pagePaths.add(\"/about.tsx\")\n * - \"/page.tsx\" → appPaths.add(\"/page.tsx\") (already in app router format)\n */\nfunction categorizeAndAddPath(\n  filePath: string,\n  appPaths: Set<string>,\n  pagePaths: Set<string>,\n  projectDir?: string\n): void {\n  // Normalize path separators to forward slashes (Windows compatibility)\n  const normalized = filePath.replace(/\\\\/g, '/')\n\n  // Skip non-file entries (like directories without extensions)\n  if (normalized.endsWith('/')) {\n    return\n  }\n\n  if (normalized.startsWith('app/')) {\n    // App router path: remove 'app/' prefix and ensure leading slash\n    // \"app/page.tsx\" → \"/page.tsx\"\n    // \"app/dashboard/page.tsx\" → \"/dashboard/page.tsx\"\n    const withoutPrefix = normalized.slice(4) // Remove \"app/\"\n    appPaths.add('/' + withoutPrefix)\n  } else if (normalized.startsWith('pages/')) {\n    // Pages router path: remove 'pages/' prefix and add leading slash\n    // \"pages/index.tsx\" → \"/index.tsx\"\n    // \"pages/about.tsx\" → \"/about.tsx\"\n    const withoutPrefix = normalized.slice(6) // Remove \"pages/\"\n    pagePaths.add('/' + withoutPrefix)\n  } else if (normalized.startsWith('/')) {\n    // Leading slash suggests app router format (already in correct format)\n    // \"/page.tsx\" → \"/page.tsx\" (no change needed)\n    appPaths.add(normalized)\n  } else {\n    // No obvious prefix - try to detect based on file existence\n    if (projectDir) {\n      const appPath = path.join(projectDir, 'app', normalized)\n      const pagesPath = path.join(projectDir, 'pages', normalized)\n\n      if (fs.existsSync(appPath)) {\n        appPaths.add('/' + normalized)\n      } else if (fs.existsSync(pagesPath)) {\n        pagePaths.add('/' + normalized)\n      } else {\n        // Default to pages router for paths without clear indicator\n        pagePaths.add('/' + normalized)\n      }\n    } else {\n      // Without projectDir context, default to pages router\n      pagePaths.add('/' + normalized)\n    }\n  }\n}\n\n/**\n * Parse build paths from comma-separated format\n * Supports:\n * - Comma-separated values: \"app/page.tsx,app/about/page.tsx\"\n *\n * @param input - String input to parse\n * @returns Array of path patterns\n */\nexport function parseBuildPathsInput(input: string): string[] {\n  // Comma-separated values\n  return input\n    .split(',')\n    .map((p) => p.trim())\n    .filter((p) => p.length > 0)\n}\n"],"names":["promisify","globOriginal","Log","path","fs","isError","glob","resolveBuildPaths","patterns","projectDir","appPaths","Set","pagePaths","pattern","trimmed","trim","isGlobPattern","test","matches","cwd","length","warn","file","statSync","join","isDirectory","categorizeAndAddPath","error","Error","message","String","Array","from","sort","filePath","normalized","replace","endsWith","startsWith","withoutPrefix","slice","add","appPath","pagesPath","existsSync","parseBuildPathsInput","input","split","map","p","filter"],"mappings":"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","ignoreList":[0]}