{"version":3,"sources":["../../../src/lib/metadata/resolve-metadata.ts"],"sourcesContent":["import type {\n  Metadata,\n  ResolvedMetadata,\n  ResolvedViewport,\n  ResolvingMetadata,\n  ResolvingViewport,\n  Viewport,\n  WithStringifiedURLs,\n} from './types/metadata-interface'\nimport type { MetadataImageModule } from '../../build/webpack/loaders/metadata/types'\nimport type { GetDynamicParamFromSegment } from '../../server/app-render/app-render'\nimport type { Twitter } from './types/twitter-types'\nimport type { OpenGraph } from './types/opengraph-types'\nimport type { AppDirModules } from '../../build/webpack/loaders/next-app-loader'\nimport type { MetadataContext } from './types/resolvers'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type {\n  AbsoluteTemplateString,\n  IconDescriptor,\n  ResolvedIcons,\n} from './types/metadata-types'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { StaticMetadata } from './types/icons'\nimport type { WorkStore } from '../../server/app-render/work-async-storage.external'\nimport type { Params } from '../../server/request/params'\nimport type { SearchParams } from '../../server/request/search-params'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport 'server-only'\n\nimport { cache } from 'react'\nimport {\n  createDefaultMetadata,\n  createDefaultViewport,\n} from './default-metadata'\nimport { resolveOpenGraph, resolveTwitter } from './resolvers/resolve-opengraph'\nimport { resolveTitle } from './resolvers/resolve-title'\nimport { resolveAsArrayOrUndefined } from './generate/utils'\nimport {\n  getComponentTypeModule,\n  getLayoutOrPageModule,\n} from '../../server/lib/app-dir-module'\nimport { interopDefault } from '../interop-default'\nimport {\n  resolveAlternates,\n  resolveAppleWebApp,\n  resolveAppLinks,\n  resolveRobots,\n  resolveThemeColor,\n  resolveVerification,\n  resolveItunes,\n  resolveFacebook,\n  resolvePagination,\n} from './resolvers/resolve-basics'\nimport { resolveIcons } from './resolvers/resolve-icons'\nimport { getTracer } from '../../server/lib/trace/tracer'\nimport { ResolveMetadataSpan } from '../../server/lib/trace/constants'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport * as Log from '../../build/output/log'\nimport { createServerParamsForMetadata } from '../../server/request/params'\nimport type { MetadataBaseURL } from './resolvers/resolve-url'\nimport {\n  getUseCacheFunctionInfo,\n  isUseCacheFunction,\n} from '../client-and-server-references'\nimport type {\n  UseCacheLayoutProps,\n  UseCachePageProps,\n} from '../../server/use-cache/use-cache-wrapper'\nimport { createLazyResult } from '../../server/lib/lazy-result'\n\ntype StaticIcons = Pick<ResolvedIcons, 'icon' | 'apple'>\n\ntype Resolved<T> = T extends Metadata ? ResolvedMetadata : ResolvedViewport\n\ntype InstrumentedResolver<TData> = ((\n  parent: Promise<Resolved<TData>>\n) => TData | Promise<TData>) & {\n  $$original: (\n    props: unknown,\n    parent: Promise<Resolved<TData>>\n  ) => TData | Promise<TData>\n}\n\ntype MetadataResolver = InstrumentedResolver<Metadata>\ntype ViewportResolver = InstrumentedResolver<Viewport>\n\nexport type MetadataErrorType = 'not-found' | 'forbidden' | 'unauthorized'\n\nexport type MetadataItems = Array<\n  [Metadata | MetadataResolver | null, StaticMetadata]\n>\n\nexport type ViewportItems = Array<Viewport | ViewportResolver | null>\n\ntype TitleTemplates = {\n  title: string | null\n  twitter: string | null\n  openGraph: string | null\n}\n\ntype BuildState = {\n  warnings: Set<string>\n}\n\ntype LayoutProps = {\n  params: Promise<Params>\n}\n\ntype PageProps = {\n  params: Promise<Params>\n  searchParams: Promise<SearchParams>\n}\n\ntype SegmentProps = LayoutProps | PageProps\ntype UseCacheSegmentProps = UseCacheLayoutProps | UseCachePageProps\n\nfunction isFavicon(icon: IconDescriptor | undefined): boolean {\n  if (!icon) {\n    return false\n  }\n\n  // turbopack appends a hash to all images\n  return (\n    (icon.url === '/favicon.ico' ||\n      icon.url.toString().startsWith('/favicon.ico?')) &&\n    icon.type === 'image/x-icon'\n  )\n}\n\nfunction convertUrlsToStrings<T>(input: T): WithStringifiedURLs<T> {\n  if (input instanceof URL) {\n    return input.toString() as unknown as WithStringifiedURLs<T>\n  } else if (Array.isArray(input)) {\n    return input.map((item) =>\n      convertUrlsToStrings(item)\n    ) as WithStringifiedURLs<T>\n  } else if (input && typeof input === 'object') {\n    const result: Record<string, unknown> = {}\n    for (const [key, value] of Object.entries(input)) {\n      result[key] = convertUrlsToStrings(value)\n    }\n    return result as WithStringifiedURLs<T>\n  }\n  return input as WithStringifiedURLs<T>\n}\n\nfunction normalizeMetadataBase(metadataBase: string | URL | null): URL | null {\n  if (typeof metadataBase === 'string') {\n    try {\n      metadataBase = new URL(metadataBase)\n    } catch {\n      throw new Error(`metadataBase is not a valid URL: ${metadataBase}`)\n    }\n  }\n  return metadataBase\n}\n\nasync function mergeStaticMetadata(\n  metadataBase: MetadataBaseURL,\n  source: Metadata | null,\n  target: ResolvedMetadata,\n  staticFilesMetadata: StaticMetadata,\n  metadataContext: MetadataContext,\n  titleTemplates: TitleTemplates,\n  leafSegmentStaticIcons: StaticIcons,\n  pathname: Promise<string>\n): Promise<ResolvedMetadata> {\n  if (!staticFilesMetadata) return target\n  const { icon, apple, openGraph, twitter, manifest } = staticFilesMetadata\n\n  // Keep updating the static icons in the most leaf node\n\n  if (icon) {\n    leafSegmentStaticIcons.icon = icon\n  }\n  if (apple) {\n    leafSegmentStaticIcons.apple = apple\n  }\n\n  // file based metadata is specified and current level metadata twitter.images is not specified\n  if (twitter && !source?.twitter?.hasOwnProperty('images')) {\n    const resolvedTwitter = resolveTwitter(\n      { ...target.twitter, images: twitter } as Twitter,\n      metadataBase,\n      { ...metadataContext, isStaticMetadataRouteFile: true },\n      titleTemplates.twitter\n    )\n    target.twitter = convertUrlsToStrings(resolvedTwitter)\n  }\n\n  // file based metadata is specified and current level metadata openGraph.images is not specified\n  if (openGraph && !source?.openGraph?.hasOwnProperty('images')) {\n    const resolvedOpenGraph = await resolveOpenGraph(\n      { ...target.openGraph, images: openGraph } as OpenGraph,\n      metadataBase,\n      pathname,\n      { ...metadataContext, isStaticMetadataRouteFile: true },\n      titleTemplates.openGraph\n    )\n    target.openGraph = convertUrlsToStrings(resolvedOpenGraph)\n  }\n  if (manifest) {\n    target.manifest = manifest\n  }\n\n  return target\n}\n\n/**\n * Merges the given metadata with the resolved metadata. Returns a new object.\n */\nasync function mergeMetadata(\n  route: string,\n  pathname: Promise<string>,\n  {\n    metadata,\n    resolvedMetadata,\n    staticFilesMetadata,\n    titleTemplates,\n    metadataContext,\n    buildState,\n    leafSegmentStaticIcons,\n  }: {\n    metadata: Metadata | null\n    resolvedMetadata: ResolvedMetadata\n    staticFilesMetadata: StaticMetadata\n    titleTemplates: TitleTemplates\n    metadataContext: MetadataContext\n    buildState: BuildState\n    leafSegmentStaticIcons: StaticIcons\n  }\n): Promise<ResolvedMetadata> {\n  const newResolvedMetadata = structuredClone(resolvedMetadata)\n\n  const metadataBase = normalizeMetadataBase(\n    metadata?.metadataBase !== undefined\n      ? metadata.metadataBase\n      : resolvedMetadata.metadataBase\n  )\n\n  for (const key_ in metadata) {\n    const key = key_ as keyof Metadata\n\n    switch (key) {\n      case 'title': {\n        newResolvedMetadata.title = resolveTitle(\n          metadata.title,\n          titleTemplates.title\n        )\n        break\n      }\n      case 'alternates': {\n        newResolvedMetadata.alternates = convertUrlsToStrings(\n          await resolveAlternates(\n            metadata.alternates,\n            metadataBase,\n            pathname,\n            metadataContext\n          )\n        )\n        break\n      }\n      case 'openGraph': {\n        newResolvedMetadata.openGraph = convertUrlsToStrings(\n          await resolveOpenGraph(\n            metadata.openGraph,\n            metadataBase,\n            pathname,\n            metadataContext,\n            titleTemplates.openGraph\n          )\n        )\n        break\n      }\n      case 'twitter': {\n        newResolvedMetadata.twitter = convertUrlsToStrings(\n          resolveTwitter(\n            metadata.twitter,\n            metadataBase,\n            metadataContext,\n            titleTemplates.twitter\n          )\n        )\n        break\n      }\n      case 'facebook':\n        newResolvedMetadata.facebook = resolveFacebook(metadata.facebook)\n        break\n      case 'verification':\n        newResolvedMetadata.verification = resolveVerification(\n          metadata.verification\n        )\n        break\n\n      case 'icons': {\n        newResolvedMetadata.icons = convertUrlsToStrings(\n          resolveIcons(metadata.icons)\n        )\n        break\n      }\n      case 'appleWebApp':\n        newResolvedMetadata.appleWebApp = resolveAppleWebApp(\n          metadata.appleWebApp\n        )\n        break\n      case 'appLinks':\n        newResolvedMetadata.appLinks = convertUrlsToStrings(\n          resolveAppLinks(metadata.appLinks)\n        )\n        break\n      case 'robots': {\n        newResolvedMetadata.robots = resolveRobots(metadata.robots)\n        break\n      }\n      case 'archives':\n      case 'assets':\n      case 'bookmarks':\n      case 'keywords': {\n        newResolvedMetadata[key] = resolveAsArrayOrUndefined(metadata[key])\n        break\n      }\n      case 'authors': {\n        newResolvedMetadata[key] = convertUrlsToStrings(\n          resolveAsArrayOrUndefined(metadata.authors)\n        )\n        break\n      }\n      case 'itunes': {\n        newResolvedMetadata[key] = await resolveItunes(\n          metadata.itunes,\n          metadataBase,\n          pathname,\n          metadataContext\n        )\n        break\n      }\n      case 'pagination': {\n        newResolvedMetadata.pagination = await resolvePagination(\n          metadata.pagination,\n          metadataBase,\n          pathname,\n          metadataContext\n        )\n        break\n      }\n      // directly assign fields that fallback to null\n      case 'abstract':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'applicationName':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'description':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'generator':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'creator':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'publisher':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'category':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'classification':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'referrer':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'formatDetection':\n        newResolvedMetadata[key] = metadata[key] ?? null\n        break\n      case 'manifest':\n        newResolvedMetadata[key] = convertUrlsToStrings(metadata[key]) ?? null\n        break\n      case 'pinterest':\n        newResolvedMetadata[key] = convertUrlsToStrings(metadata[key]) ?? null\n        break\n      case 'other':\n        newResolvedMetadata.other = Object.assign(\n          {},\n          newResolvedMetadata.other,\n          metadata.other\n        )\n        break\n      case 'metadataBase':\n        newResolvedMetadata.metadataBase = metadataBase\n          ? metadataBase.toString()\n          : null\n        break\n\n      case 'apple-touch-fullscreen': {\n        buildState.warnings.add(\n          `Use appleWebApp instead\\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-metadata`\n        )\n        break\n      }\n      case 'apple-touch-icon-precomposed': {\n        buildState.warnings.add(\n          `Use icons.apple instead\\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-metadata`\n        )\n        break\n      }\n      case 'themeColor':\n      case 'colorScheme':\n      case 'viewport':\n        if (metadata[key] != null) {\n          buildState.warnings.add(\n            `Unsupported metadata ${key} is configured in metadata export in ${route}. Please move it to viewport export instead.\\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`\n          )\n        }\n        break\n      default: {\n        key satisfies never\n      }\n    }\n  }\n\n  return mergeStaticMetadata(\n    metadataBase,\n    metadata,\n    newResolvedMetadata,\n    staticFilesMetadata,\n    metadataContext,\n    titleTemplates,\n    leafSegmentStaticIcons,\n    pathname\n  )\n}\n\n/**\n * Merges the given viewport with the resolved viewport. Returns a new object.\n */\nfunction mergeViewport({\n  resolvedViewport,\n  viewport,\n}: {\n  resolvedViewport: ResolvedViewport\n  viewport: Viewport | null\n}): ResolvedViewport {\n  const newResolvedViewport = structuredClone(resolvedViewport)\n\n  if (viewport) {\n    for (const key_ in viewport) {\n      const key = key_ as keyof Viewport\n\n      switch (key) {\n        case 'themeColor': {\n          newResolvedViewport.themeColor = resolveThemeColor(\n            viewport.themeColor\n          )\n          break\n        }\n        case 'colorScheme':\n          newResolvedViewport.colorScheme = viewport.colorScheme || null\n          break\n        case 'width':\n        case 'height':\n        case 'initialScale':\n        case 'minimumScale':\n        case 'maximumScale':\n        case 'userScalable':\n        case 'viewportFit':\n        case 'interactiveWidget':\n          // always override the target with the source\n          // @ts-ignore viewport properties\n          newResolvedViewport[key] = viewport[key]\n          break\n        default:\n          key satisfies never\n      }\n    }\n  }\n\n  return newResolvedViewport\n}\n\nfunction getDefinedViewport(\n  mod: any,\n  props: SegmentProps,\n  tracingProps: { route: string }\n): Viewport | ViewportResolver | null {\n  if (typeof mod.generateViewport === 'function') {\n    const { route } = tracingProps\n    const segmentProps = createSegmentProps(mod.generateViewport, props)\n\n    return Object.assign(\n      (parent: ResolvingViewport) =>\n        getTracer().trace(\n          ResolveMetadataSpan.generateViewport,\n          {\n            spanName: `generateViewport ${route}`,\n            attributes: {\n              'next.page': route,\n            },\n          },\n          () => mod.generateViewport(segmentProps, parent)\n        ),\n      { $$original: mod.generateViewport }\n    )\n  }\n  return mod.viewport || null\n}\n\nfunction getDefinedMetadata(\n  mod: any,\n  props: SegmentProps,\n  tracingProps: { route: string }\n): Metadata | MetadataResolver | null {\n  if (typeof mod.generateMetadata === 'function') {\n    const { route } = tracingProps\n    const segmentProps = createSegmentProps(mod.generateMetadata, props)\n\n    return Object.assign(\n      (parent: ResolvingMetadata) =>\n        getTracer().trace(\n          ResolveMetadataSpan.generateMetadata,\n          {\n            spanName: `generateMetadata ${route}`,\n            attributes: {\n              'next.page': route,\n            },\n          },\n          () => mod.generateMetadata(segmentProps, parent)\n        ),\n      { $$original: mod.generateMetadata }\n    )\n  }\n  return mod.metadata || null\n}\n\n/**\n * If `fn` is a `'use cache'` function, we add special markers to the props,\n * that the cache wrapper reads and removes, before passing the props to the\n * user function.\n */\nfunction createSegmentProps(\n  fn: Function,\n  props: SegmentProps\n): SegmentProps | UseCacheSegmentProps {\n  return isUseCacheFunction(fn)\n    ? 'searchParams' in props\n      ? { ...props, $$isPage: true }\n      : { ...props, $$isLayout: true }\n    : props\n}\n\nasync function collectStaticImagesFiles(\n  metadata: AppDirModules['metadata'],\n  props: SegmentProps,\n  type: keyof NonNullable<AppDirModules['metadata']>\n) {\n  if (!metadata?.[type]) return undefined\n\n  const iconPromises = metadata[type as 'icon' | 'apple'].map(\n    async (imageModule: (p: any) => Promise<MetadataImageModule[]>) =>\n      interopDefault(await imageModule(props))\n  )\n\n  return iconPromises?.length > 0\n    ? (await Promise.all(iconPromises))?.flat()\n    : undefined\n}\n\nasync function resolveStaticMetadata(\n  modules: AppDirModules,\n  props: SegmentProps\n): Promise<StaticMetadata> {\n  const { metadata } = modules\n  if (!metadata) return null\n\n  const [icon, apple, openGraph, twitter] = await Promise.all([\n    collectStaticImagesFiles(metadata, props, 'icon'),\n    collectStaticImagesFiles(metadata, props, 'apple'),\n    collectStaticImagesFiles(metadata, props, 'openGraph'),\n    collectStaticImagesFiles(metadata, props, 'twitter'),\n  ])\n\n  const staticMetadata = {\n    icon,\n    apple,\n    openGraph,\n    twitter,\n    manifest: metadata.manifest,\n  }\n\n  return staticMetadata\n}\n\n// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]\nasync function collectMetadata({\n  tree,\n  metadataItems,\n  errorMetadataItem,\n  props,\n  route,\n  errorConvention,\n}: {\n  tree: LoaderTree\n  metadataItems: MetadataItems\n  errorMetadataItem: MetadataItems[number]\n  props: SegmentProps\n  route: string\n  errorConvention?: MetadataErrorType\n}) {\n  let mod\n  let modType\n  const hasErrorConventionComponent = Boolean(\n    errorConvention && tree[2][errorConvention]\n  )\n  if (errorConvention) {\n    mod = await getComponentTypeModule(tree, 'layout')\n    modType = errorConvention\n  } else {\n    const { mod: layoutOrPageMod, modType: layoutOrPageModType } =\n      await getLayoutOrPageModule(tree)\n    mod = layoutOrPageMod\n    modType = layoutOrPageModType\n  }\n\n  if (modType) {\n    route += `/${modType}`\n  }\n\n  const staticFilesMetadata = await resolveStaticMetadata(tree[2], props)\n  const metadataExport = mod ? getDefinedMetadata(mod, props, { route }) : null\n\n  metadataItems.push([metadataExport, staticFilesMetadata])\n\n  if (hasErrorConventionComponent && errorConvention) {\n    const errorMod = await getComponentTypeModule(tree, errorConvention)\n    const errorMetadataExport = errorMod\n      ? getDefinedMetadata(errorMod, props, { route })\n      : null\n\n    errorMetadataItem[0] = errorMetadataExport\n    errorMetadataItem[1] = staticFilesMetadata\n  }\n}\n\n// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]\nasync function collectViewport({\n  tree,\n  viewportItems,\n  errorViewportItemRef,\n  props,\n  route,\n  errorConvention,\n}: {\n  tree: LoaderTree\n  viewportItems: ViewportItems\n  errorViewportItemRef: ErrorViewportItemRef\n  props: SegmentProps\n  route: string\n  errorConvention?: MetadataErrorType\n}) {\n  let mod\n  let modType\n  const hasErrorConventionComponent = Boolean(\n    errorConvention && tree[2][errorConvention]\n  )\n  if (errorConvention) {\n    mod = await getComponentTypeModule(tree, 'layout')\n    modType = errorConvention\n  } else {\n    const { mod: layoutOrPageMod, modType: layoutOrPageModType } =\n      await getLayoutOrPageModule(tree)\n    mod = layoutOrPageMod\n    modType = layoutOrPageModType\n  }\n\n  if (modType) {\n    route += `/${modType}`\n  }\n\n  const viewportExport = mod ? getDefinedViewport(mod, props, { route }) : null\n\n  viewportItems.push(viewportExport)\n\n  if (hasErrorConventionComponent && errorConvention) {\n    const errorMod = await getComponentTypeModule(tree, errorConvention)\n    const errorViewportExport = errorMod\n      ? getDefinedViewport(errorMod, props, { route })\n      : null\n\n    errorViewportItemRef.current = errorViewportExport\n  }\n}\n\nconst resolveMetadataItems = cache(async function (\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  errorConvention: MetadataErrorType | undefined,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore\n) {\n  const parentParams = {}\n  const metadataItems: MetadataItems = []\n  const errorMetadataItem: MetadataItems[number] = [null, null]\n  const treePrefix = undefined\n  return resolveMetadataItemsImpl(\n    metadataItems,\n    tree,\n    treePrefix,\n    parentParams,\n    searchParams,\n    errorConvention,\n    errorMetadataItem,\n    getDynamicParamFromSegment,\n    workStore\n  )\n})\n\nasync function resolveMetadataItemsImpl(\n  metadataItems: MetadataItems,\n  tree: LoaderTree,\n  /** Provided tree can be nested subtree, this argument says what is the path of such subtree */\n  treePrefix: undefined | string[],\n  parentParams: Params,\n  searchParams: Promise<ParsedUrlQuery>,\n  errorConvention: MetadataErrorType | undefined,\n  errorMetadataItem: MetadataItems[number],\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore\n): Promise<MetadataItems> {\n  const [segment, parallelRoutes, { page }] = tree\n  const currentTreePrefix =\n    treePrefix && treePrefix.length ? [...treePrefix, segment] : [segment]\n  const isPage = typeof page !== 'undefined'\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n  /**\n   * Create object holding the parent params and current params\n   */\n  let currentParams = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  const params = createServerParamsForMetadata(currentParams, workStore)\n  const props: SegmentProps = isPage ? { params, searchParams } : { params }\n\n  await collectMetadata({\n    tree,\n    metadataItems,\n    errorMetadataItem,\n    errorConvention,\n    props,\n    route: currentTreePrefix\n      // __PAGE__ shouldn't be shown in a route\n      .filter((s) => s !== PAGE_SEGMENT_KEY)\n      .join('/'),\n  })\n\n  for (const key in parallelRoutes) {\n    const childTree = parallelRoutes[key]\n    await resolveMetadataItemsImpl(\n      metadataItems,\n      childTree,\n      currentTreePrefix,\n      currentParams,\n      searchParams,\n      errorConvention,\n      errorMetadataItem,\n      getDynamicParamFromSegment,\n      workStore\n    )\n  }\n\n  if (Object.keys(parallelRoutes).length === 0 && errorConvention) {\n    // If there are no parallel routes, place error metadata as the last item.\n    // e.g. layout -> layout -> not-found\n    metadataItems.push(errorMetadataItem)\n  }\n\n  return metadataItems\n}\n\ntype ErrorViewportItemRef = { current: ViewportItems[number] }\nconst resolveViewportItems = cache(async function (\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  errorConvention: MetadataErrorType | undefined,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore\n) {\n  const parentParams = {}\n  const viewportItems: ViewportItems = []\n  const errorViewportItemRef: ErrorViewportItemRef = {\n    current: null,\n  }\n  const treePrefix = undefined\n  return resolveViewportItemsImpl(\n    viewportItems,\n    tree,\n    treePrefix,\n    parentParams,\n    searchParams,\n    errorConvention,\n    errorViewportItemRef,\n    getDynamicParamFromSegment,\n    workStore\n  )\n})\n\nasync function resolveViewportItemsImpl(\n  viewportItems: ViewportItems,\n  tree: LoaderTree,\n  /** Provided tree can be nested subtree, this argument says what is the path of such subtree */\n  treePrefix: undefined | string[],\n  parentParams: Params,\n  searchParams: Promise<ParsedUrlQuery>,\n  errorConvention: MetadataErrorType | undefined,\n  errorViewportItemRef: ErrorViewportItemRef,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore\n): Promise<ViewportItems> {\n  const [segment, parallelRoutes, { page }] = tree\n  const currentTreePrefix =\n    treePrefix && treePrefix.length ? [...treePrefix, segment] : [segment]\n  const isPage = typeof page !== 'undefined'\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n  /**\n   * Create object holding the parent params and current params\n   */\n  let currentParams = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  const params = createServerParamsForMetadata(currentParams, workStore)\n\n  let layerProps: LayoutProps | PageProps\n  if (isPage) {\n    layerProps = {\n      params,\n      searchParams,\n    }\n  } else {\n    layerProps = {\n      params,\n    }\n  }\n\n  await collectViewport({\n    tree,\n    viewportItems,\n    errorViewportItemRef,\n    errorConvention,\n    props: layerProps,\n    route: currentTreePrefix\n      // __PAGE__ shouldn't be shown in a route\n      .filter((s) => s !== PAGE_SEGMENT_KEY)\n      .join('/'),\n  })\n\n  for (const key in parallelRoutes) {\n    const childTree = parallelRoutes[key]\n    await resolveViewportItemsImpl(\n      viewportItems,\n      childTree,\n      currentTreePrefix,\n      currentParams,\n      searchParams,\n      errorConvention,\n      errorViewportItemRef,\n      getDynamicParamFromSegment,\n      workStore\n    )\n  }\n\n  if (Object.keys(parallelRoutes).length === 0 && errorConvention) {\n    // If there are no parallel routes, place error metadata as the last item.\n    // e.g. layout -> layout -> not-found\n    viewportItems.push(errorViewportItemRef.current)\n  }\n\n  return viewportItems\n}\n\ntype WithTitle = { title?: AbsoluteTemplateString | null }\ntype WithDescription = { description?: string | null }\n\nconst isTitleTruthy = (title: AbsoluteTemplateString | null | undefined) =>\n  !!title?.absolute\nconst hasTitle = (metadata: WithTitle | null) => isTitleTruthy(metadata?.title)\n\nfunction inheritFromMetadata(\n  target: (WithTitle & WithDescription) | null,\n  metadata: ResolvedMetadata\n) {\n  if (target) {\n    if (!hasTitle(target) && hasTitle(metadata)) {\n      target.title = metadata.title\n    }\n    if (!target.description && metadata.description) {\n      target.description = metadata.description\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst commonOgKeys = ['title', 'description', 'images'] as const\nfunction postProcessMetadata(\n  metadata: ResolvedMetadata,\n  favicon: any,\n  titleTemplates: TitleTemplates,\n  metadataContext: MetadataContext\n): ResolvedMetadata {\n  const { openGraph, twitter } = metadata\n\n  if (openGraph) {\n    // If there's openGraph information but not configured in twitter,\n    // inherit them from openGraph metadata.\n    let autoFillProps: Partial<{\n      [Key in (typeof commonOgKeys)[number]]: NonNullable<\n        ResolvedMetadata['openGraph']\n      >[Key]\n    }> = {}\n    const hasTwTitle = hasTitle(twitter)\n    const hasTwDescription = twitter?.description\n    const hasTwImages = Boolean(\n      twitter?.hasOwnProperty('images') && twitter.images\n    )\n    if (!hasTwTitle) {\n      if (isTitleTruthy(openGraph.title)) {\n        autoFillProps.title = openGraph.title\n      } else if (metadata.title && isTitleTruthy(metadata.title)) {\n        autoFillProps.title = metadata.title\n      }\n    }\n    if (!hasTwDescription)\n      autoFillProps.description =\n        openGraph.description || metadata.description || undefined\n    if (!hasTwImages) autoFillProps.images = openGraph.images\n\n    if (Object.keys(autoFillProps).length > 0) {\n      const partialTwitter = resolveTwitter(\n        autoFillProps,\n        normalizeMetadataBase(metadata.metadataBase),\n        metadataContext,\n        titleTemplates.twitter\n      )\n      if (metadata.twitter) {\n        metadata.twitter = Object.assign({}, metadata.twitter, {\n          ...(!hasTwTitle && { title: partialTwitter?.title }),\n          ...(!hasTwDescription && {\n            description: partialTwitter?.description,\n          }),\n          ...(!hasTwImages && { images: partialTwitter?.images }),\n        })\n      } else {\n        metadata.twitter = convertUrlsToStrings(partialTwitter)\n      }\n    }\n  }\n\n  // If there's no title and description configured in openGraph or twitter,\n  // use the title and description from metadata.\n  inheritFromMetadata(openGraph, metadata)\n  inheritFromMetadata(twitter, metadata)\n\n  if (favicon) {\n    if (!metadata.icons) {\n      metadata.icons = {\n        icon: [],\n        apple: [],\n      }\n    }\n\n    metadata.icons.icon.unshift(favicon)\n  }\n\n  return metadata\n}\n\ntype Result<T> = null | T | Promise<null | T> | PromiseLike<null | T>\n\nfunction prerenderMetadata(metadataItems: MetadataItems) {\n  // If the index is a function then it is a resolver and the next slot\n  // is the corresponding result. If the index is not a function it is the result\n  // itself.\n  const resolversAndResults: Array<\n    ((value: ResolvedMetadata) => void) | Result<Metadata>\n  > = []\n  for (let i = 0; i < metadataItems.length; i++) {\n    const metadataExport = metadataItems[i][0]\n    getResult<Metadata>(resolversAndResults, metadataExport)\n  }\n  return resolversAndResults\n}\n\nfunction prerenderViewport(viewportItems: ViewportItems) {\n  // If the index is a function then it is a resolver and the next slot\n  // is the corresponding result. If the index is not a function it is the result\n  // itself.\n  const resolversAndResults: Array<\n    ((value: ResolvedViewport) => void) | Result<Viewport>\n  > = []\n  for (let i = 0; i < viewportItems.length; i++) {\n    const viewportExport = viewportItems[i]\n    getResult<Viewport>(resolversAndResults, viewportExport)\n  }\n  return resolversAndResults\n}\n\nconst noop = () => {}\n\nfunction getResult<TData extends object>(\n  resolversAndResults: Array<\n    ((value: Resolved<TData>) => void) | Result<TData>\n  >,\n  exportForResult: null | TData | InstrumentedResolver<TData>\n) {\n  if (typeof exportForResult === 'function') {\n    // If the function is a 'use cache' function that uses the parent data as\n    // the second argument, we don't want to eagerly execute it during\n    // metadata/viewport pre-rendering, as the parent data might also be\n    // computed from another 'use cache' function. To ensure that the hanging\n    // input abort signal handling works in this case (i.e. the depending\n    // function waits for the cached input to resolve while encoding its args),\n    // they must be called sequentially. This can be accomplished by wrapping\n    // the call in a lazy promise, so that the original function is only called\n    // when the result is actually awaited.\n    const useCacheFunctionInfo = getUseCacheFunctionInfo(\n      exportForResult.$$original\n    )\n    if (useCacheFunctionInfo && useCacheFunctionInfo.usedArgs[1]) {\n      const promise = new Promise<Resolved<TData>>((resolve) =>\n        resolversAndResults.push(resolve)\n      )\n      resolversAndResults.push(\n        createLazyResult(async () => exportForResult(promise))\n      )\n    } else {\n      let result: TData | Promise<TData>\n      if (useCacheFunctionInfo) {\n        resolversAndResults.push(noop)\n        // @ts-expect-error We intentionally omit the parent argument, because\n        // we know from the check above that the 'use cache' function does not\n        // use it.\n        result = exportForResult()\n      } else {\n        result = exportForResult(\n          new Promise<Resolved<TData>>((resolve) =>\n            resolversAndResults.push(resolve)\n          )\n        )\n      }\n      resolversAndResults.push(result)\n      if (result instanceof Promise) {\n        // since we eager execute generateMetadata and\n        // they can reject at anytime we need to ensure\n        // we attach the catch handler right away to\n        // prevent unhandled rejections crashing the process\n        result.catch((err) => {\n          return {\n            __nextError: err,\n          }\n        })\n      }\n    }\n  } else if (typeof exportForResult === 'object') {\n    resolversAndResults.push(exportForResult)\n  } else {\n    resolversAndResults.push(null)\n  }\n}\n\nfunction freezeInDev<T extends object>(obj: T): T {\n  if (process.env.NODE_ENV === 'development') {\n    return (\n      require('../../shared/lib/deep-freeze') as typeof import('../../shared/lib/deep-freeze')\n    ).deepFreeze(obj) as T\n  }\n\n  return obj\n}\n\nexport async function accumulateMetadata(\n  route: string,\n  metadataItems: MetadataItems,\n  pathname: Promise<string>,\n  metadataContext: MetadataContext\n): Promise<ResolvedMetadata> {\n  let resolvedMetadata = createDefaultMetadata()\n\n  let titleTemplates: TitleTemplates = {\n    title: null,\n    twitter: null,\n    openGraph: null,\n  }\n\n  const buildState = {\n    warnings: new Set<string>(),\n  }\n\n  let favicon\n\n  // Collect the static icons in the most leaf node,\n  // since we don't collect all the static metadata icons in the parent segments.\n  const leafSegmentStaticIcons = {\n    icon: [],\n    apple: [],\n  }\n\n  const resolversAndResults = prerenderMetadata(metadataItems)\n  let resultIndex = 0\n\n  for (let i = 0; i < metadataItems.length; i++) {\n    const staticFilesMetadata = metadataItems[i][1]\n    // Treat favicon as special case, it should be the first icon in the list\n    // i <= 1 represents root layout, and if current page is also at root\n    if (i <= 1 && isFavicon(staticFilesMetadata?.icon?.[0])) {\n      const iconMod = staticFilesMetadata?.icon?.shift()\n      if (i === 0) favicon = iconMod\n    }\n\n    let pendingMetadata = resolversAndResults[resultIndex++]\n    if (typeof pendingMetadata === 'function') {\n      // This metadata item had a `generateMetadata` and\n      // we need to provide the currently resolved metadata\n      // to it before we continue;\n      const resolveParentMetadata = pendingMetadata\n      // we know that the next item is a result if this item\n      // was a resolver\n      pendingMetadata = resolversAndResults[resultIndex++] as Result<Metadata>\n\n      resolveParentMetadata(freezeInDev(resolvedMetadata))\n    }\n    // Otherwise the item was either null or a static export\n\n    let metadata: Metadata | null\n    if (isPromiseLike(pendingMetadata)) {\n      metadata = await pendingMetadata\n    } else {\n      metadata = pendingMetadata\n    }\n\n    resolvedMetadata = await mergeMetadata(route, pathname, {\n      resolvedMetadata,\n      metadata,\n      metadataContext,\n      staticFilesMetadata,\n      titleTemplates,\n      buildState,\n      leafSegmentStaticIcons,\n    })\n\n    // If the layout is the same layer with page, skip the leaf layout and leaf page\n    // The leaf layout and page are the last two items\n    if (i < metadataItems.length - 2) {\n      titleTemplates = {\n        title: resolvedMetadata.title?.template || null,\n        openGraph: resolvedMetadata.openGraph?.title.template || null,\n        twitter: resolvedMetadata.twitter?.title.template || null,\n      }\n    }\n  }\n\n  if (\n    leafSegmentStaticIcons.icon.length > 0 ||\n    leafSegmentStaticIcons.apple.length > 0\n  ) {\n    if (!resolvedMetadata.icons) {\n      resolvedMetadata.icons = {\n        icon: [],\n        apple: [],\n      }\n      if (leafSegmentStaticIcons.icon.length > 0) {\n        resolvedMetadata.icons.icon.unshift(...leafSegmentStaticIcons.icon)\n      }\n      if (leafSegmentStaticIcons.apple.length > 0) {\n        resolvedMetadata.icons.apple.unshift(...leafSegmentStaticIcons.apple)\n      }\n    }\n  }\n\n  // Only log warnings if there are any, and only once after the metadata resolving process is finished\n  if (buildState.warnings.size > 0) {\n    for (const warning of buildState.warnings) {\n      Log.warn(warning)\n    }\n  }\n\n  return postProcessMetadata(\n    resolvedMetadata,\n    favicon,\n    titleTemplates,\n    metadataContext\n  )\n}\n\nexport async function accumulateViewport(\n  viewportItems: ViewportItems\n): Promise<ResolvedViewport> {\n  let resolvedViewport: ResolvedViewport = createDefaultViewport()\n\n  const resolversAndResults = prerenderViewport(viewportItems)\n  let i = 0\n\n  while (i < resolversAndResults.length) {\n    let pendingViewport = resolversAndResults[i++]\n    if (typeof pendingViewport === 'function') {\n      // this viewport item had a `generateViewport` and\n      // we need to provide the currently resolved viewport\n      // to it before we continue;\n      const resolveParentViewport = pendingViewport\n      // we know that the next item is a result if this item\n      // was a resolver\n      pendingViewport = resolversAndResults[i++] as Result<Viewport>\n\n      resolveParentViewport(freezeInDev(resolvedViewport))\n    }\n    // Otherwise the item was either null or a static export\n\n    let viewport: Viewport | null\n    if (isPromiseLike(pendingViewport)) {\n      viewport = await pendingViewport\n    } else {\n      viewport = pendingViewport\n    }\n\n    resolvedViewport = mergeViewport({ resolvedViewport, viewport })\n  }\n\n  return resolvedViewport\n}\n\n// Exposed API for metadata component, that directly resolve the loader tree and related context as resolved metadata.\nexport async function resolveMetadata(\n  tree: LoaderTree,\n  pathname: Promise<string>,\n  searchParams: Promise<ParsedUrlQuery>,\n  errorConvention: MetadataErrorType | undefined,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore,\n  metadataContext: MetadataContext\n): Promise<ResolvedMetadata> {\n  const metadataItems = await resolveMetadataItems(\n    tree,\n    searchParams,\n    errorConvention,\n    getDynamicParamFromSegment,\n    workStore\n  )\n  return accumulateMetadata(\n    workStore.route,\n    metadataItems,\n    pathname,\n    metadataContext\n  )\n}\n\n// Exposed API for viewport component, that directly resolve the loader tree and related context as resolved viewport.\nexport async function resolveViewport(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  errorConvention: MetadataErrorType | undefined,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore\n): Promise<ResolvedViewport> {\n  const viewportItems = await resolveViewportItems(\n    tree,\n    searchParams,\n    errorConvention,\n    getDynamicParamFromSegment,\n    workStore\n  )\n  return accumulateViewport(viewportItems)\n}\n\nfunction isPromiseLike<T>(\n  value: unknown | PromiseLike<T>\n): value is PromiseLike<T> {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof (value as PromiseLike<unknown>).then === 'function'\n  )\n}\n"],"names":["cache","createDefaultMetadata","createDefaultViewport","resolveOpenGraph","resolveTwitter","resolveTitle","resolveAsArrayOrUndefined","getComponentTypeModule","getLayoutOrPageModule","interopDefault","resolveAlternates","resolveAppleWebApp","resolveAppLinks","resolveRobots","resolveThemeColor","resolveVerification","resolveItunes","resolveFacebook","resolvePagination","resolveIcons","getTracer","ResolveMetadataSpan","PAGE_SEGMENT_KEY","Log","createServerParamsForMetadata","getUseCacheFunctionInfo","isUseCacheFunction","createLazyResult","isFavicon","icon","url","toString","startsWith","type","convertUrlsToStrings","input","URL","Array","isArray","map","item","result","key","value","Object","entries","normalizeMetadataBase","metadataBase","Error","mergeStaticMetadata","source","target","staticFilesMetadata","metadataContext","titleTemplates","leafSegmentStaticIcons","pathname","apple","openGraph","twitter","manifest","hasOwnProperty","resolvedTwitter","images","isStaticMetadataRouteFile","resolvedOpenGraph","mergeMetadata","route","metadata","resolvedMetadata","buildState","newResolvedMetadata","structuredClone","undefined","key_","title","alternates","facebook","verification","icons","appleWebApp","appLinks","robots","authors","itunes","pagination","other","assign","warnings","add","mergeViewport","resolvedViewport","viewport","newResolvedViewport","themeColor","colorScheme","getDefinedViewport","mod","props","tracingProps","generateViewport","segmentProps","createSegmentProps","parent","trace","spanName","attributes","$$original","getDefinedMetadata","generateMetadata","fn","$$isPage","$$isLayout","collectStaticImagesFiles","iconPromises","imageModule","length","Promise","all","flat","resolveStaticMetadata","modules","staticMetadata","collectMetadata","tree","metadataItems","errorMetadataItem","errorConvention","modType","hasErrorConventionComponent","Boolean","layoutOrPageMod","layoutOrPageModType","metadataExport","push","errorMod","errorMetadataExport","collectViewport","viewportItems","errorViewportItemRef","viewportExport","errorViewportExport","current","resolveMetadataItems","searchParams","getDynamicParamFromSegment","workStore","parentParams","treePrefix","resolveMetadataItemsImpl","segment","parallelRoutes","page","currentTreePrefix","isPage","segmentParam","currentParams","param","params","filter","s","join","childTree","keys","resolveViewportItems","resolveViewportItemsImpl","layerProps","isTitleTruthy","absolute","hasTitle","inheritFromMetadata","description","commonOgKeys","postProcessMetadata","favicon","autoFillProps","hasTwTitle","hasTwDescription","hasTwImages","partialTwitter","unshift","prerenderMetadata","resolversAndResults","i","getResult","prerenderViewport","noop","exportForResult","useCacheFunctionInfo","usedArgs","promise","resolve","catch","err","__nextError","freezeInDev","obj","process","env","NODE_ENV","require","deepFreeze","accumulateMetadata","Set","resultIndex","iconMod","shift","pendingMetadata","resolveParentMetadata","isPromiseLike","template","size","warning","warn","accumulateViewport","pendingViewport","resolveParentViewport","resolveMetadata","resolveViewport","then"],"mappings":"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","ignoreList":[0]}