{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import React, { Suspense, cache, cloneElement } from 'react'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { GetDynamicParamFromSegment } from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { SearchParams } from '../../server/request/search-params'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n  FacebookMeta,\n  PinterestMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport {\n  type MetadataErrorType,\n  resolveMetadata,\n  resolveViewport,\n} from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\nimport type { MetadataContext } from './types/resolvers'\nimport type { WorkStore } from '../../server/app-render/work-async-storage.external'\nimport { createServerSearchParamsForMetadata } from '../../server/request/search-params'\nimport { createServerPathnameForMetadata } from '../../server/request/pathname'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\n\nimport {\n  MetadataBoundary,\n  ViewportBoundary,\n  OutletBoundary,\n} from '../framework/boundary-components'\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  pathname,\n  parsedQuery,\n  metadataContext,\n  getDynamicParamFromSegment,\n  errorType,\n  workStore,\n  serveStreamingMetadata,\n}: {\n  tree: LoaderTree\n  pathname: string\n  parsedQuery: SearchParams\n  metadataContext: MetadataContext\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  errorType?: MetadataErrorType | 'redirect'\n  workStore: WorkStore\n  serveStreamingMetadata: boolean\n}): {\n  Viewport: React.ComponentType\n  Metadata: React.ComponentType\n  MetadataOutlet: React.ComponentType\n} {\n  const searchParams = createServerSearchParamsForMetadata(\n    parsedQuery,\n    workStore\n  )\n  const pathnameForMetadata = createServerPathnameForMetadata(\n    pathname,\n    workStore\n  )\n\n  function Viewport() {\n    const pendingViewportTags = getResolvedViewport(\n      tree,\n      searchParams,\n      getDynamicParamFromSegment,\n      workStore,\n      errorType\n    ).catch((viewportErr) => {\n      // When Legacy PPR is enabled viewport can reject with a Postpone type\n      // This will go away once Legacy PPR is removed and dynamic metadata will\n      // stay pending until after the prerender is complete when it is dynamic\n      if (isPostpone(viewportErr)) {\n        throw viewportErr\n      }\n      if (!errorType && isHTTPAccessFallbackError(viewportErr)) {\n        return getNotFoundViewport(\n          tree,\n          searchParams,\n          getDynamicParamFromSegment,\n          workStore\n        ).catch(() => null)\n      }\n      // We're going to throw the error from the metadata outlet so we just render null here instead\n      return null\n    })\n\n    return (\n      <ViewportBoundary>\n        {/* @ts-expect-error -- Promise<ReactNode> not considered a valid child even though it is */}\n        {pendingViewportTags}\n      </ViewportBoundary>\n    )\n  }\n  Viewport.displayName = 'Next.Viewport'\n\n  function Metadata() {\n    const pendingMetadataTags = getResolvedMetadata(\n      tree,\n      pathnameForMetadata,\n      searchParams,\n      getDynamicParamFromSegment,\n      metadataContext,\n      workStore,\n      errorType\n    ).catch((metadataErr) => {\n      // When Legacy PPR is enabled metadata can reject with a Postpone type\n      // This will go away once Legacy PPR is removed and dynamic metadata will\n      // stay pending until after the prerender is complete when it is dynamic\n      if (isPostpone(metadataErr)) {\n        throw metadataErr\n      }\n      if (!errorType && isHTTPAccessFallbackError(metadataErr)) {\n        return getNotFoundMetadata(\n          tree,\n          pathnameForMetadata,\n          searchParams,\n          getDynamicParamFromSegment,\n          metadataContext,\n          workStore\n        ).catch(() => null)\n      }\n      // We're going to throw the error from the metadata outlet so we just render null here instead\n      return null\n    })\n\n    // TODO: We shouldn't change what we render based on whether we are streaming or not.\n    // If we aren't streaming we should just block the response until we have resolved the\n    // metadata.\n    if (!serveStreamingMetadata) {\n      return (\n        <MetadataBoundary>\n          {/* @ts-expect-error -- Promise<ReactNode> not considered a valid child even though it is */}\n          {pendingMetadataTags}\n        </MetadataBoundary>\n      )\n    }\n    return (\n      <div hidden>\n        <MetadataBoundary>\n          <Suspense name=\"Next.Metadata\">\n            {/* @ts-expect-error -- Promise<ReactNode> not considered a valid child even though it is */}\n            {pendingMetadataTags}\n          </Suspense>\n        </MetadataBoundary>\n      </div>\n    )\n  }\n  Metadata.displayName = 'Next.Metadata'\n\n  function MetadataOutlet() {\n    const pendingOutlet = Promise.all([\n      getResolvedMetadata(\n        tree,\n        pathnameForMetadata,\n        searchParams,\n        getDynamicParamFromSegment,\n        metadataContext,\n        workStore,\n        errorType\n      ),\n      getResolvedViewport(\n        tree,\n        searchParams,\n        getDynamicParamFromSegment,\n        workStore,\n        errorType\n      ),\n    ]).then(() => null)\n\n    // TODO: We shouldn't change what we render based on whether we are streaming or not.\n    // If we aren't streaming we should just block the response until we have resolved the\n    // metadata.\n    if (!serveStreamingMetadata) {\n      return <OutletBoundary>{pendingOutlet}</OutletBoundary>\n    }\n    return (\n      <OutletBoundary>\n        <Suspense name=\"Next.MetadataOutlet\">{pendingOutlet}</Suspense>\n      </OutletBoundary>\n    )\n  }\n  MetadataOutlet.displayName = 'Next.MetadataOutlet'\n\n  return {\n    Viewport,\n    Metadata,\n    MetadataOutlet,\n  }\n}\n\nconst getResolvedMetadata = cache(getResolvedMetadataImpl)\nasync function getResolvedMetadataImpl(\n  tree: LoaderTree,\n  pathname: Promise<string>,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  metadataContext: MetadataContext,\n  workStore: WorkStore,\n  errorType?: MetadataErrorType | 'redirect'\n): Promise<React.ReactNode> {\n  const errorConvention = errorType === 'redirect' ? undefined : errorType\n  return renderMetadata(\n    tree,\n    pathname,\n    searchParams,\n    getDynamicParamFromSegment,\n    metadataContext,\n    workStore,\n    errorConvention\n  )\n}\n\nconst getNotFoundMetadata = cache(getNotFoundMetadataImpl)\nasync function getNotFoundMetadataImpl(\n  tree: LoaderTree,\n  pathname: Promise<string>,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  metadataContext: MetadataContext,\n  workStore: WorkStore\n): Promise<React.ReactNode> {\n  const notFoundErrorConvention = 'not-found'\n  return renderMetadata(\n    tree,\n    pathname,\n    searchParams,\n    getDynamicParamFromSegment,\n    metadataContext,\n    workStore,\n    notFoundErrorConvention\n  )\n}\n\nconst getResolvedViewport = cache(getResolvedViewportImpl)\nasync function getResolvedViewportImpl(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore,\n  errorType?: MetadataErrorType | 'redirect'\n): Promise<React.ReactNode> {\n  const errorConvention = errorType === 'redirect' ? undefined : errorType\n  return renderViewport(\n    tree,\n    searchParams,\n    getDynamicParamFromSegment,\n    workStore,\n    errorConvention\n  )\n}\n\nconst getNotFoundViewport = cache(getNotFoundViewportImpl)\nasync function getNotFoundViewportImpl(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore\n): Promise<React.ReactNode> {\n  const notFoundErrorConvention = 'not-found'\n  return renderViewport(\n    tree,\n    searchParams,\n    getDynamicParamFromSegment,\n    workStore,\n    notFoundErrorConvention\n  )\n}\n\nasync function renderMetadata(\n  tree: LoaderTree,\n  pathname: Promise<string>,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  metadataContext: MetadataContext,\n  workStore: WorkStore,\n  errorConvention?: MetadataErrorType\n) {\n  const resolvedMetadata = await resolveMetadata(\n    tree,\n    pathname,\n    searchParams,\n    errorConvention,\n    getDynamicParamFromSegment,\n    workStore,\n    metadataContext\n  )\n  const elements: Array<React.ReactNode> =\n    createMetadataElements(resolvedMetadata)\n  return (\n    <>\n      {elements.map((el, index) => {\n        return cloneElement(el as React.ReactElement, { key: index })\n      })}\n    </>\n  )\n}\n\nasync function renderViewport(\n  tree: LoaderTree,\n  searchParams: Promise<ParsedUrlQuery>,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  workStore: WorkStore,\n  errorConvention?: MetadataErrorType\n) {\n  const resolvedViewport = await resolveViewport(\n    tree,\n    searchParams,\n    errorConvention,\n    getDynamicParamFromSegment,\n    workStore\n  )\n\n  const elements: Array<React.ReactNode> =\n    createViewportElements(resolvedViewport)\n  return (\n    <>\n      {elements.map((el, index) => {\n        return cloneElement(el as React.ReactElement, { key: index })\n      })}\n    </>\n  )\n}\n\nfunction createMetadataElements(metadata: ResolvedMetadata) {\n  return MetaFilter([\n    BasicMeta({ metadata }),\n    AlternatesMetadata({ alternates: metadata.alternates }),\n    ItunesMeta({ itunes: metadata.itunes }),\n    FacebookMeta({ facebook: metadata.facebook }),\n    PinterestMeta({ pinterest: metadata.pinterest }),\n    FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n    VerificationMeta({ verification: metadata.verification }),\n    AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n    OpenGraphMetadata({ openGraph: metadata.openGraph }),\n    TwitterMetadata({ twitter: metadata.twitter }),\n    AppLinksMeta({ appLinks: metadata.appLinks }),\n    IconsMetadata({ icons: metadata.icons }),\n  ])\n}\n\nfunction createViewportElements(viewport: ResolvedViewport) {\n  return MetaFilter([ViewportMeta({ viewport: viewport })])\n}\n"],"names":["React","Suspense","cache","cloneElement","AppleWebAppMeta","FormatDetectionMeta","ItunesMeta","BasicMeta","ViewportMeta","VerificationMeta","FacebookMeta","PinterestMeta","AlternatesMetadata","OpenGraphMetadata","TwitterMetadata","AppLinksMeta","IconsMetadata","resolveMetadata","resolveViewport","MetaFilter","isHTTPAccessFallbackError","createServerSearchParamsForMetadata","createServerPathnameForMetadata","isPostpone","MetadataBoundary","ViewportBoundary","OutletBoundary","createMetadataComponents","tree","pathname","parsedQuery","metadataContext","getDynamicParamFromSegment","errorType","workStore","serveStreamingMetadata","searchParams","pathnameForMetadata","Viewport","pendingViewportTags","getResolvedViewport","catch","viewportErr","getNotFoundViewport","displayName","Metadata","pendingMetadataTags","getResolvedMetadata","metadataErr","getNotFoundMetadata","div","hidden","name","MetadataOutlet","pendingOutlet","Promise","all","then","getResolvedMetadataImpl","errorConvention","undefined","renderMetadata","getNotFoundMetadataImpl","notFoundErrorConvention","getResolvedViewportImpl","renderViewport","getNotFoundViewportImpl","resolvedMetadata","elements","createMetadataElements","map","el","index","key","resolvedViewport","createViewportElements","metadata","alternates","itunes","facebook","pinterest","formatDetection","verification","appleWebApp","openGraph","twitter","appLinks","icons","viewport"],"mappings":";AAAA,OAAOA,SAASC,QAAQ,EAAEC,KAAK,EAAEC,YAAY,QAAQ,QAAO;AAK5D,SACEC,eAAe,EACfC,mBAAmB,EACnBC,UAAU,EACVC,SAAS,EACTC,YAAY,EACZC,gBAAgB,EAChBC,YAAY,EACZC,aAAa,QACR,mBAAkB;AACzB,SAASC,kBAAkB,QAAQ,uBAAsB;AACzD,SACEC,iBAAiB,EACjBC,eAAe,EACfC,YAAY,QACP,uBAAsB;AAC7B,SAASC,aAAa,QAAQ,mBAAkB;AAChD,SAEEC,eAAe,EACfC,eAAe,QACV,qBAAoB;AAC3B,SAASC,UAAU,QAAQ,kBAAiB;AAK5C,SAASC,yBAAyB,QAAQ,oEAAmE;AAG7G,SAASC,mCAAmC,QAAQ,qCAAoC;AACxF,SAASC,+BAA+B,QAAQ,gCAA+B;AAC/E,SAASC,UAAU,QAAQ,4CAA2C;AAEtE,SACEC,gBAAgB,EAChBC,gBAAgB,EAChBC,cAAc,QACT,mCAAkC;AAEzC,+DAA+D;AAC/D,+DAA+D;AAC/D,sGAAsG;AACtG,0GAA0G;AAC1G,uEAAuE;AACvE,4EAA4E;AAC5E,OAAO,SAASC,yBAAyB,EACvCC,IAAI,EACJC,QAAQ,EACRC,WAAW,EACXC,eAAe,EACfC,0BAA0B,EAC1BC,SAAS,EACTC,SAAS,EACTC,sBAAsB,EAUvB;IAKC,MAAMC,eAAef,oCACnBS,aACAI;IAEF,MAAMG,sBAAsBf,gCAC1BO,UACAK;IAGF,SAASI;QACP,MAAMC,sBAAsBC,oBAC1BZ,MACAQ,cACAJ,4BACAE,WACAD,WACAQ,KAAK,CAAC,CAACC;YACP,sEAAsE;YACtE,yEAAyE;YACzE,wEAAwE;YACxE,IAAInB,WAAWmB,cAAc;gBAC3B,MAAMA;YACR;YACA,IAAI,CAACT,aAAab,0BAA0BsB,cAAc;gBACxD,OAAOC,oBACLf,MACAQ,cACAJ,4BACAE,WACAO,KAAK,CAAC,IAAM;YAChB;YACA,8FAA8F;YAC9F,OAAO;QACT;QAEA,qBACE,KAAChB;sBAEEc;;IAGP;IACAD,SAASM,WAAW,GAAG;IAEvB,SAASC;QACP,MAAMC,sBAAsBC,oBAC1BnB,MACAS,qBACAD,cACAJ,4BACAD,iBACAG,WACAD,WACAQ,KAAK,CAAC,CAACO;YACP,sEAAsE;YACtE,yEAAyE;YACzE,wEAAwE;YACxE,IAAIzB,WAAWyB,cAAc;gBAC3B,MAAMA;YACR;YACA,IAAI,CAACf,aAAab,0BAA0B4B,cAAc;gBACxD,OAAOC,oBACLrB,MACAS,qBACAD,cACAJ,4BACAD,iBACAG,WACAO,KAAK,CAAC,IAAM;YAChB;YACA,8FAA8F;YAC9F,OAAO;QACT;QAEA,qFAAqF;QACrF,sFAAsF;QACtF,YAAY;QACZ,IAAI,CAACN,wBAAwB;YAC3B,qBACE,KAACX;0BAEEsB;;QAGP;QACA,qBACE,KAACI;YAAIC,MAAM;sBACT,cAAA,KAAC3B;0BACC,cAAA,KAACvB;oBAASmD,MAAK;8BAEZN;;;;IAKX;IACAD,SAASD,WAAW,GAAG;IAEvB,SAASS;QACP,MAAMC,gBAAgBC,QAAQC,GAAG,CAAC;YAChCT,oBACEnB,MACAS,qBACAD,cACAJ,4BACAD,iBACAG,WACAD;YAEFO,oBACEZ,MACAQ,cACAJ,4BACAE,WACAD;SAEH,EAAEwB,IAAI,CAAC,IAAM;QAEd,qFAAqF;QACrF,sFAAsF;QACtF,YAAY;QACZ,IAAI,CAACtB,wBAAwB;YAC3B,qBAAO,KAACT;0BAAgB4B;;QAC1B;QACA,qBACE,KAAC5B;sBACC,cAAA,KAACzB;gBAASmD,MAAK;0BAAuBE;;;IAG5C;IACAD,eAAeT,WAAW,GAAG;IAE7B,OAAO;QACLN;QACAO;QACAQ;IACF;AACF;AAEA,MAAMN,sBAAsB7C,MAAMwD;AAClC,eAAeA,wBACb9B,IAAgB,EAChBC,QAAyB,EACzBO,YAAqC,EACrCJ,0BAAsD,EACtDD,eAAgC,EAChCG,SAAoB,EACpBD,SAA0C;IAE1C,MAAM0B,kBAAkB1B,cAAc,aAAa2B,YAAY3B;IAC/D,OAAO4B,eACLjC,MACAC,UACAO,cACAJ,4BACAD,iBACAG,WACAyB;AAEJ;AAEA,MAAMV,sBAAsB/C,MAAM4D;AAClC,eAAeA,wBACblC,IAAgB,EAChBC,QAAyB,EACzBO,YAAqC,EACrCJ,0BAAsD,EACtDD,eAAgC,EAChCG,SAAoB;IAEpB,MAAM6B,0BAA0B;IAChC,OAAOF,eACLjC,MACAC,UACAO,cACAJ,4BACAD,iBACAG,WACA6B;AAEJ;AAEA,MAAMvB,sBAAsBtC,MAAM8D;AAClC,eAAeA,wBACbpC,IAAgB,EAChBQ,YAAqC,EACrCJ,0BAAsD,EACtDE,SAAoB,EACpBD,SAA0C;IAE1C,MAAM0B,kBAAkB1B,cAAc,aAAa2B,YAAY3B;IAC/D,OAAOgC,eACLrC,MACAQ,cACAJ,4BACAE,WACAyB;AAEJ;AAEA,MAAMhB,sBAAsBzC,MAAMgE;AAClC,eAAeA,wBACbtC,IAAgB,EAChBQ,YAAqC,EACrCJ,0BAAsD,EACtDE,SAAoB;IAEpB,MAAM6B,0BAA0B;IAChC,OAAOE,eACLrC,MACAQ,cACAJ,4BACAE,WACA6B;AAEJ;AAEA,eAAeF,eACbjC,IAAgB,EAChBC,QAAyB,EACzBO,YAAqC,EACrCJ,0BAAsD,EACtDD,eAAgC,EAChCG,SAAoB,EACpByB,eAAmC;IAEnC,MAAMQ,mBAAmB,MAAMlD,gBAC7BW,MACAC,UACAO,cACAuB,iBACA3B,4BACAE,WACAH;IAEF,MAAMqC,WACJC,uBAAuBF;IACzB,qBACE;kBACGC,SAASE,GAAG,CAAC,CAACC,IAAIC;YACjB,qBAAOrE,aAAaoE,IAA0B;gBAAEE,KAAKD;YAAM;QAC7D;;AAGN;AAEA,eAAeP,eACbrC,IAAgB,EAChBQ,YAAqC,EACrCJ,0BAAsD,EACtDE,SAAoB,EACpByB,eAAmC;IAEnC,MAAMe,mBAAmB,MAAMxD,gBAC7BU,MACAQ,cACAuB,iBACA3B,4BACAE;IAGF,MAAMkC,WACJO,uBAAuBD;IACzB,qBACE;kBACGN,SAASE,GAAG,CAAC,CAACC,IAAIC;YACjB,qBAAOrE,aAAaoE,IAA0B;gBAAEE,KAAKD;YAAM;QAC7D;;AAGN;AAEA,SAASH,uBAAuBO,QAA0B;IACxD,OAAOzD,WAAW;QAChBZ,UAAU;YAAEqE;QAAS;QACrBhE,mBAAmB;YAAEiE,YAAYD,SAASC,UAAU;QAAC;QACrDvE,WAAW;YAAEwE,QAAQF,SAASE,MAAM;QAAC;QACrCpE,aAAa;YAAEqE,UAAUH,SAASG,QAAQ;QAAC;QAC3CpE,cAAc;YAAEqE,WAAWJ,SAASI,SAAS;QAAC;QAC9C3E,oBAAoB;YAAE4E,iBAAiBL,SAASK,eAAe;QAAC;QAChExE,iBAAiB;YAAEyE,cAAcN,SAASM,YAAY;QAAC;QACvD9E,gBAAgB;YAAE+E,aAAaP,SAASO,WAAW;QAAC;QACpDtE,kBAAkB;YAAEuE,WAAWR,SAASQ,SAAS;QAAC;QAClDtE,gBAAgB;YAAEuE,SAAST,SAASS,OAAO;QAAC;QAC5CtE,aAAa;YAAEuE,UAAUV,SAASU,QAAQ;QAAC;QAC3CtE,cAAc;YAAEuE,OAAOX,SAASW,KAAK;QAAC;KACvC;AACH;AAEA,SAASZ,uBAAuBa,QAA0B;IACxD,OAAOrE,WAAW;QAACX,aAAa;YAAEgF,UAAUA;QAAS;KAAG;AAC1D","ignoreList":[0]}