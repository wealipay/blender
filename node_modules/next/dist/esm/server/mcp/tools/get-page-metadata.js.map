{"version":3,"sources":["../../../../src/server/mcp/tools/get-page-metadata.ts"],"sourcesContent":["import type { McpServer } from 'next/dist/compiled/@modelcontextprotocol/sdk/server/mcp'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n} from '../../dev/hot-reloader-types'\nimport {\n  createBrowserRequest,\n  handleBrowserPageResponse,\n  DEFAULT_BROWSER_REQUEST_TIMEOUT_MS,\n} from './utils/browser-communication'\nimport type {\n  PageMetadata,\n  PageSegment,\n  SegmentTrieData,\n} from '../../../shared/lib/mcp-page-metadata-types'\nimport type { SegmentTrieNode } from '../../../next-devtools/dev-overlay/segment-explorer-trie'\nimport { mcpTelemetryTracker } from '../mcp-telemetry-tracker'\n\nexport function registerGetPageMetadataTool(\n  server: McpServer,\n  sendHmrMessage: (message: HmrMessageSentToBrowser) => void,\n  getActiveConnectionCount: () => number\n) {\n  server.registerTool(\n    'get_page_metadata',\n    {\n      description:\n        'Get runtime metadata about what contributes to the current page render from active browser sessions.',\n      inputSchema: {},\n    },\n    async (_request) => {\n      // Track telemetry\n      mcpTelemetryTracker.recordToolCall('mcp/get_page_metadata')\n\n      try {\n        const connectionCount = getActiveConnectionCount()\n        if (connectionCount === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: 'No browser sessions connected. Please open your application in a browser to retrieve page metadata.',\n              },\n            ],\n          }\n        }\n\n        const responses = await createBrowserRequest<SegmentTrieData>(\n          HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA,\n          sendHmrMessage,\n          getActiveConnectionCount,\n          DEFAULT_BROWSER_REQUEST_TIMEOUT_MS\n        )\n\n        if (responses.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: 'No browser sessions responded.',\n              },\n            ],\n          }\n        }\n\n        const sessionMetadata: Array<{ url: string; metadata: PageMetadata }> =\n          []\n        for (const response of responses) {\n          if (response.data) {\n            // TODO: Add other metadata for the current page render here. Currently, we only have segment trie data.\n            const pageMetadata = convertSegmentTrieToPageMetadata(response.data)\n            sessionMetadata.push({ url: response.url, metadata: pageMetadata })\n          }\n        }\n\n        if (sessionMetadata.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `No page metadata available from ${responses.length} browser session(s).`,\n              },\n            ],\n          }\n        }\n\n        const output = formatPageMetadata(sessionMetadata)\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: output,\n            },\n          ],\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : String(error)}`,\n            },\n          ],\n        }\n      }\n    }\n  )\n}\n\nexport function handlePageMetadataResponse(\n  requestId: string,\n  segmentTrieData: SegmentTrieData | null,\n  url: string | undefined\n) {\n  handleBrowserPageResponse<SegmentTrieData | null>(\n    requestId,\n    segmentTrieData,\n    url || ''\n  )\n}\n\nfunction convertSegmentTrieToPageMetadata(data: SegmentTrieData): PageMetadata {\n  const segments: PageSegment[] = []\n\n  if (data.segmentTrie) {\n    // Traverse the trie and collect all segments\n    function traverseTrie(node: SegmentTrieNode): void {\n      if (node.value) {\n        segments.push({\n          type: node.value.type,\n          pagePath: node.value.pagePath,\n          boundaryType: node.value.boundaryType,\n        })\n      }\n\n      for (const childNode of Object.values(node.children)) {\n        if (childNode) {\n          traverseTrie(childNode)\n        }\n      }\n    }\n\n    traverseTrie(data.segmentTrie)\n  }\n\n  return {\n    segments,\n    routerType: data.routerType,\n  }\n}\n\nfunction formatPageMetadata(\n  sessionMetadata: Array<{ url: string; metadata: PageMetadata }>\n): string {\n  let output = `# Page metadata from ${sessionMetadata.length} browser session(s)\\n\\n`\n\n  for (const { url, metadata } of sessionMetadata) {\n    let displayUrl = url\n    try {\n      const urlObj = new URL(url)\n      displayUrl = urlObj.pathname + urlObj.search + urlObj.hash\n    } catch {\n      // If URL parsing fails, use the original URL\n    }\n\n    output += `## Session: ${displayUrl}\\n\\n`\n    output += `**Router type:** ${metadata.routerType}\\n\\n`\n\n    if (metadata.segments.length === 0) {\n      output += '*No segments found*\\n\\n'\n    } else {\n      output += '### Files powering this page:\\n\\n'\n\n      // Ensure consistent output to avoid flaky tests\n      const sortedSegments = [...metadata.segments].sort((a, b) => {\n        const typeOrder = (segment: PageSegment): number => {\n          const type = segment.boundaryType || segment.type\n          if (type === 'layout') return 0\n          if (type.startsWith('boundary:')) return 1\n          if (type === 'page') return 2\n          return 3\n        }\n        const aOrder = typeOrder(a)\n        const bOrder = typeOrder(b)\n        if (aOrder !== bOrder) return aOrder - bOrder\n        return a.pagePath.localeCompare(b.pagePath)\n      })\n\n      for (const segment of sortedSegments) {\n        const path = segment.pagePath\n        const isBuiltin = path.startsWith('__next_builtin__')\n        const type = segment.boundaryType || segment.type\n        const isBoundary = type.startsWith('boundary:')\n\n        let displayPath = path\n          .replace(/@boundary$/, '')\n          .replace(/^__next_builtin__/, '')\n\n        if (!isBuiltin && !displayPath.startsWith('app/')) {\n          displayPath = `app/${displayPath}`\n        }\n\n        const descriptors: string[] = []\n        if (isBoundary) descriptors.push('boundary')\n        if (isBuiltin) descriptors.push('builtin')\n\n        const descriptor =\n          descriptors.length > 0 ? ` (${descriptors.join(', ')})` : ''\n        output += `- ${displayPath}${descriptor}\\n`\n      }\n      output += '\\n'\n    }\n\n    output += '---\\n\\n'\n  }\n\n  return output.trim()\n}\n"],"names":["HMR_MESSAGE_SENT_TO_BROWSER","createBrowserRequest","handleBrowserPageResponse","DEFAULT_BROWSER_REQUEST_TIMEOUT_MS","mcpTelemetryTracker","registerGetPageMetadataTool","server","sendHmrMessage","getActiveConnectionCount","registerTool","description","inputSchema","_request","recordToolCall","connectionCount","content","type","text","responses","REQUEST_PAGE_METADATA","length","sessionMetadata","response","data","pageMetadata","convertSegmentTrieToPageMetadata","push","url","metadata","output","formatPageMetadata","error","Error","message","String","handlePageMetadataResponse","requestId","segmentTrieData","segments","segmentTrie","traverseTrie","node","value","pagePath","boundaryType","childNode","Object","values","children","routerType","displayUrl","urlObj","URL","pathname","search","hash","sortedSegments","sort","a","b","typeOrder","segment","startsWith","aOrder","bOrder","localeCompare","path","isBuiltin","isBoundary","displayPath","replace","descriptors","descriptor","join","trim"],"mappings":"AACA,SACEA,2BAA2B,QAEtB,+BAA8B;AACrC,SACEC,oBAAoB,EACpBC,yBAAyB,EACzBC,kCAAkC,QAC7B,gCAA+B;AAOtC,SAASC,mBAAmB,QAAQ,2BAA0B;AAE9D,OAAO,SAASC,4BACdC,MAAiB,EACjBC,cAA0D,EAC1DC,wBAAsC;IAEtCF,OAAOG,YAAY,CACjB,qBACA;QACEC,aACE;QACFC,aAAa,CAAC;IAChB,GACA,OAAOC;QACL,kBAAkB;QAClBR,oBAAoBS,cAAc,CAAC;QAEnC,IAAI;YACF,MAAMC,kBAAkBN;YACxB,IAAIM,oBAAoB,GAAG;gBACzB,OAAO;oBACLC,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAM;wBACR;qBACD;gBACH;YACF;YAEA,MAAMC,YAAY,MAAMjB,qBACtBD,4BAA4BmB,qBAAqB,EACjDZ,gBACAC,0BACAL;YAGF,IAAIe,UAAUE,MAAM,KAAK,GAAG;gBAC1B,OAAO;oBACLL,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAM;wBACR;qBACD;gBACH;YACF;YAEA,MAAMI,kBACJ,EAAE;YACJ,KAAK,MAAMC,YAAYJ,UAAW;gBAChC,IAAII,SAASC,IAAI,EAAE;oBACjB,wGAAwG;oBACxG,MAAMC,eAAeC,iCAAiCH,SAASC,IAAI;oBACnEF,gBAAgBK,IAAI,CAAC;wBAAEC,KAAKL,SAASK,GAAG;wBAAEC,UAAUJ;oBAAa;gBACnE;YACF;YAEA,IAAIH,gBAAgBD,MAAM,KAAK,GAAG;gBAChC,OAAO;oBACLL,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAM,CAAC,gCAAgC,EAAEC,UAAUE,MAAM,CAAC,oBAAoB,CAAC;wBACjF;qBACD;gBACH;YACF;YAEA,MAAMS,SAASC,mBAAmBT;YAElC,OAAO;gBACLN,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAMY;oBACR;iBACD;YACH;QACF,EAAE,OAAOE,OAAO;YACd,OAAO;gBACLhB,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAM,CAAC,OAAO,EAAEc,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH,QAAQ;oBAC1E;iBACD;YACH;QACF;IACF;AAEJ;AAEA,OAAO,SAASI,2BACdC,SAAiB,EACjBC,eAAuC,EACvCV,GAAuB;IAEvBzB,0BACEkC,WACAC,iBACAV,OAAO;AAEX;AAEA,SAASF,iCAAiCF,IAAqB;IAC7D,MAAMe,WAA0B,EAAE;IAElC,IAAIf,KAAKgB,WAAW,EAAE;QACpB,6CAA6C;QAC7C,SAASC,aAAaC,IAAqB;YACzC,IAAIA,KAAKC,KAAK,EAAE;gBACdJ,SAASZ,IAAI,CAAC;oBACZV,MAAMyB,KAAKC,KAAK,CAAC1B,IAAI;oBACrB2B,UAAUF,KAAKC,KAAK,CAACC,QAAQ;oBAC7BC,cAAcH,KAAKC,KAAK,CAACE,YAAY;gBACvC;YACF;YAEA,KAAK,MAAMC,aAAaC,OAAOC,MAAM,CAACN,KAAKO,QAAQ,EAAG;gBACpD,IAAIH,WAAW;oBACbL,aAAaK;gBACf;YACF;QACF;QAEAL,aAAajB,KAAKgB,WAAW;IAC/B;IAEA,OAAO;QACLD;QACAW,YAAY1B,KAAK0B,UAAU;IAC7B;AACF;AAEA,SAASnB,mBACPT,eAA+D;IAE/D,IAAIQ,SAAS,CAAC,qBAAqB,EAAER,gBAAgBD,MAAM,CAAC,uBAAuB,CAAC;IAEpF,KAAK,MAAM,EAAEO,GAAG,EAAEC,QAAQ,EAAE,IAAIP,gBAAiB;QAC/C,IAAI6B,aAAavB;QACjB,IAAI;YACF,MAAMwB,SAAS,IAAIC,IAAIzB;YACvBuB,aAAaC,OAAOE,QAAQ,GAAGF,OAAOG,MAAM,GAAGH,OAAOI,IAAI;QAC5D,EAAE,OAAM;QACN,6CAA6C;QAC/C;QAEA1B,UAAU,CAAC,YAAY,EAAEqB,WAAW,IAAI,CAAC;QACzCrB,UAAU,CAAC,iBAAiB,EAAED,SAASqB,UAAU,CAAC,IAAI,CAAC;QAEvD,IAAIrB,SAASU,QAAQ,CAAClB,MAAM,KAAK,GAAG;YAClCS,UAAU;QACZ,OAAO;YACLA,UAAU;YAEV,gDAAgD;YAChD,MAAM2B,iBAAiB;mBAAI5B,SAASU,QAAQ;aAAC,CAACmB,IAAI,CAAC,CAACC,GAAGC;gBACrD,MAAMC,YAAY,CAACC;oBACjB,MAAM7C,OAAO6C,QAAQjB,YAAY,IAAIiB,QAAQ7C,IAAI;oBACjD,IAAIA,SAAS,UAAU,OAAO;oBAC9B,IAAIA,KAAK8C,UAAU,CAAC,cAAc,OAAO;oBACzC,IAAI9C,SAAS,QAAQ,OAAO;oBAC5B,OAAO;gBACT;gBACA,MAAM+C,SAASH,UAAUF;gBACzB,MAAMM,SAASJ,UAAUD;gBACzB,IAAII,WAAWC,QAAQ,OAAOD,SAASC;gBACvC,OAAON,EAAEf,QAAQ,CAACsB,aAAa,CAACN,EAAEhB,QAAQ;YAC5C;YAEA,KAAK,MAAMkB,WAAWL,eAAgB;gBACpC,MAAMU,OAAOL,QAAQlB,QAAQ;gBAC7B,MAAMwB,YAAYD,KAAKJ,UAAU,CAAC;gBAClC,MAAM9C,OAAO6C,QAAQjB,YAAY,IAAIiB,QAAQ7C,IAAI;gBACjD,MAAMoD,aAAapD,KAAK8C,UAAU,CAAC;gBAEnC,IAAIO,cAAcH,KACfI,OAAO,CAAC,cAAc,IACtBA,OAAO,CAAC,qBAAqB;gBAEhC,IAAI,CAACH,aAAa,CAACE,YAAYP,UAAU,CAAC,SAAS;oBACjDO,cAAc,CAAC,IAAI,EAAEA,aAAa;gBACpC;gBAEA,MAAME,cAAwB,EAAE;gBAChC,IAAIH,YAAYG,YAAY7C,IAAI,CAAC;gBACjC,IAAIyC,WAAWI,YAAY7C,IAAI,CAAC;gBAEhC,MAAM8C,aACJD,YAAYnD,MAAM,GAAG,IAAI,CAAC,EAAE,EAAEmD,YAAYE,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG;gBAC5D5C,UAAU,CAAC,EAAE,EAAEwC,cAAcG,WAAW,EAAE,CAAC;YAC7C;YACA3C,UAAU;QACZ;QAEAA,UAAU;IACZ;IAEA,OAAOA,OAAO6C,IAAI;AACpB","ignoreList":[0]}