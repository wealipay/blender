{"version":3,"sources":["../../../src/server/app-render/postponed-state.ts"],"sourcesContent":["import type {\n  OpaqueFallbackRouteParamEntries,\n  OpaqueFallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { getDynamicParam } from '../../shared/lib/router/utils/get-dynamic-param'\nimport type { Params } from '../request/params'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport { stringifyResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport enum DynamicState {\n  /**\n   * The dynamic access occurred during the RSC render phase.\n   */\n  DATA = 1,\n\n  /**\n   * The dynamic access occurred during the HTML shell render phase.\n   */\n  HTML = 2,\n}\n\n/**\n * The postponed state for dynamic data.\n */\nexport type DynamicDataPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.DATA\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\n/**\n * The postponed state for dynamic HTML.\n */\nexport type DynamicHTMLPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.HTML\n\n  /**\n   * The postponed data used by React.\n   */\n  readonly data: [\n    preludeState: DynamicHTMLPreludeState,\n    postponed: ReactPostponed,\n  ]\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\nexport const enum DynamicHTMLPreludeState {\n  Empty = 0,\n  Full = 1,\n}\n\ntype ReactPostponed = NonNullable<\n  import('react-dom/static').PrerenderResult['postponed']\n>\n\nexport type PostponedState =\n  | DynamicDataPostponedState\n  | DynamicHTMLPostponedState\n\nexport async function getDynamicHTMLPostponedState(\n  postponed: ReactPostponed,\n  preludeState: DynamicHTMLPreludeState,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  resumeDataCache: PrerenderResumeDataCache | RenderResumeDataCache,\n  isCacheComponentsEnabled: boolean\n): Promise<string> {\n  const data: DynamicHTMLPostponedState['data'] = [preludeState, postponed]\n  const dataString = JSON.stringify(data)\n\n  // If there are no fallback route params, we can just serialize the postponed\n  // state as is.\n  if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n    // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n    return `${dataString.length}:${dataString}${await stringifyResumeDataCache(\n      createRenderResumeDataCache(resumeDataCache),\n      isCacheComponentsEnabled\n    )}`\n  }\n\n  const replacements: OpaqueFallbackRouteParamEntries = Array.from(\n    fallbackRouteParams.entries()\n  )\n  const replacementsString = JSON.stringify(replacements)\n\n  // Serialized as `<replacements.length><replacements><data>`\n  const postponedString = `${replacementsString.length}${replacementsString}${dataString}`\n\n  // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n  return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(resumeDataCache, isCacheComponentsEnabled)}`\n}\n\nexport async function getDynamicDataPostponedState(\n  resumeDataCache: PrerenderResumeDataCache | RenderResumeDataCache,\n  isCacheComponentsEnabled: boolean\n): Promise<string> {\n  return `4:null${await stringifyResumeDataCache(createRenderResumeDataCache(resumeDataCache), isCacheComponentsEnabled)}`\n}\n\nexport function parsePostponedState(\n  state: string,\n  interpolatedParams: Params\n): PostponedState {\n  try {\n    const postponedStringLengthMatch = state.match(/^([0-9]*):/)?.[1]\n    if (!postponedStringLengthMatch) {\n      throw new Error(`Invariant: invalid postponed state ${state}`)\n    }\n\n    const postponedStringLength = parseInt(postponedStringLengthMatch)\n\n    // We add a `:` to the end of the length as the first character of the\n    // postponed string is the length of the replacement entries.\n    const postponedString = state.slice(\n      postponedStringLengthMatch.length + 1,\n      postponedStringLengthMatch.length + postponedStringLength + 1\n    )\n\n    const renderResumeDataCache = createRenderResumeDataCache(\n      state.slice(postponedStringLengthMatch.length + postponedStringLength + 1)\n    )\n\n    try {\n      if (postponedString === 'null') {\n        return { type: DynamicState.DATA, renderResumeDataCache }\n      }\n\n      if (/^[0-9]/.test(postponedString)) {\n        const match = postponedString.match(/^([0-9]*)/)?.[1]\n        if (!match) {\n          throw new Error(\n            `Invariant: invalid postponed state ${JSON.stringify(postponedString)}`\n          )\n        }\n\n        // This is the length of the replacements entries.\n        const length = parseInt(match)\n        const replacements = JSON.parse(\n          postponedString.slice(\n            match.length,\n            // We then go to the end of the string.\n            match.length + length\n          )\n        ) as OpaqueFallbackRouteParamEntries\n\n        let postponed = postponedString.slice(match.length + length)\n        for (const [\n          segmentKey,\n          [searchValue, dynamicParamType],\n        ] of replacements) {\n          const {\n            treeSegment: [\n              ,\n              // This is the same value that'll be used in the postponed state\n              // as it's part of the tree data. That's why we use it as the\n              // replacement value.\n              value,\n            ],\n          } = getDynamicParam(\n            interpolatedParams,\n            segmentKey,\n            dynamicParamType,\n            null\n          )\n\n          postponed = postponed.replaceAll(searchValue, value)\n        }\n\n        return {\n          type: DynamicState.HTML,\n          data: JSON.parse(postponed),\n          renderResumeDataCache,\n        }\n      }\n\n      return {\n        type: DynamicState.HTML,\n        data: JSON.parse(postponedString),\n        renderResumeDataCache,\n      }\n    } catch (err) {\n      console.error('Failed to parse postponed state', err)\n      return { type: DynamicState.DATA, renderResumeDataCache }\n    }\n  } catch (err) {\n    console.error('Failed to parse postponed state', err)\n    return {\n      type: DynamicState.DATA,\n      renderResumeDataCache: createPrerenderResumeDataCache(),\n    }\n  }\n}\n\nexport function getPostponedFromState(state: DynamicHTMLPostponedState) {\n  const [preludeState, postponed] = state.data\n  return { preludeState, postponed }\n}\n"],"names":["getDynamicParam","createPrerenderResumeDataCache","createRenderResumeDataCache","stringifyResumeDataCache","DynamicState","DynamicHTMLPreludeState","getDynamicHTMLPostponedState","postponed","preludeState","fallbackRouteParams","resumeDataCache","isCacheComponentsEnabled","data","dataString","JSON","stringify","size","length","replacements","Array","from","entries","replacementsString","postponedString","getDynamicDataPostponedState","parsePostponedState","state","interpolatedParams","postponedStringLengthMatch","match","Error","postponedStringLength","parseInt","slice","renderResumeDataCache","type","test","parse","segmentKey","searchValue","dynamicParamType","treeSegment","value","replaceAll","err","console","error","getPostponedFromState"],"mappings":"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","ignoreList":[0]}