{"version":3,"sources":["../../../../src/server/lib/incremental-cache/index.ts"],"sourcesContent":["import type { CacheFs } from '../../../shared/lib/utils'\nimport type { PrerenderManifest } from '../../../build'\nimport {\n  type IncrementalCacheValue,\n  type IncrementalCacheEntry,\n  type IncrementalCache as IncrementalCacheType,\n  IncrementalCacheKind,\n  CachedRouteKind,\n  type IncrementalResponseCacheEntry,\n  type IncrementalFetchCacheEntry,\n  type GetIncrementalFetchCacheContext,\n  type GetIncrementalResponseCacheContext,\n  type CachedFetchValue,\n  type SetIncrementalFetchCacheContext,\n  type SetIncrementalResponseCacheContext,\n} from '../../response-cache'\nimport type { DeepReadonly } from '../../../shared/lib/deep-readonly'\nimport FileSystemCache from './file-system-cache'\nimport { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'\n\nimport {\n  CACHE_ONE_YEAR,\n  NEXT_CACHE_TAGS_HEADER,\n  PRERENDER_REVALIDATE_HEADER,\n} from '../../../lib/constants'\nimport { toRoute } from '../to-route'\nimport { SharedCacheControls } from './shared-cache-controls.external'\nimport {\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from '../../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../../shared/lib/invariant-error'\nimport type { Revalidate } from '../cache-control'\nimport { getPreviouslyRevalidatedTags } from '../../server-utils'\nimport { workAsyncStorage } from '../../app-render/work-async-storage.external'\nimport { DetachedPromise } from '../../../lib/detached-promise'\nimport { areTagsExpired, areTagsStale } from './tags-manifest.external'\n\nexport interface CacheHandlerContext {\n  fs?: CacheFs\n  dev?: boolean\n  flushToDisk?: boolean\n  serverDistDir?: string\n  maxMemoryCacheSize?: number\n  fetchCacheKeyPrefix?: string\n  prerenderManifest?: PrerenderManifest\n  revalidatedTags: string[]\n  _requestHeaders: IncrementalCache['requestHeaders']\n}\n\nexport interface CacheHandlerValue {\n  lastModified: number\n  age?: number\n  cacheState?: string\n  value: IncrementalCacheValue | null\n}\n\nexport class CacheHandler {\n  // eslint-disable-next-line\n  constructor(_ctx: CacheHandlerContext) {}\n\n  public async get(\n    _cacheKey: string,\n    _ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext\n  ): Promise<CacheHandlerValue | null> {\n    return {} as any\n  }\n\n  public async set(\n    _cacheKey: string,\n    _data: IncrementalCacheValue | null,\n    _ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext\n  ): Promise<void> {}\n\n  public async revalidateTag(\n    _tags: string | string[],\n    _durations?: { expire?: number }\n  ): Promise<void> {}\n\n  public resetRequestCache(): void {}\n}\n\nexport class IncrementalCache implements IncrementalCacheType {\n  readonly dev?: boolean\n  readonly disableForTestmode?: boolean\n  readonly cacheHandler?: CacheHandler\n  readonly hasCustomCacheHandler: boolean\n  readonly prerenderManifest: DeepReadonly<PrerenderManifest>\n  readonly requestHeaders: Record<string, undefined | string | string[]>\n  readonly allowedRevalidateHeaderKeys?: string[]\n  readonly minimalMode?: boolean\n  readonly fetchCacheKeyPrefix?: string\n  readonly isOnDemandRevalidate?: boolean\n  readonly revalidatedTags?: readonly string[]\n\n  private static readonly debug: boolean =\n    !!process.env.NEXT_PRIVATE_DEBUG_CACHE\n  private readonly locks = new Map<string, Promise<void>>()\n\n  /**\n   * The cache controls for routes. This will source the values from the\n   * prerender manifest until the in-memory cache is updated with new values.\n   */\n  private readonly cacheControls: SharedCacheControls\n\n  constructor({\n    fs,\n    dev,\n    flushToDisk,\n    minimalMode,\n    serverDistDir,\n    requestHeaders,\n    maxMemoryCacheSize,\n    getPrerenderManifest,\n    fetchCacheKeyPrefix,\n    CurCacheHandler,\n    allowedRevalidateHeaderKeys,\n  }: {\n    fs?: CacheFs\n    dev: boolean\n    minimalMode?: boolean\n    serverDistDir?: string\n    flushToDisk?: boolean\n    allowedRevalidateHeaderKeys?: string[]\n    requestHeaders: IncrementalCache['requestHeaders']\n    maxMemoryCacheSize?: number\n    getPrerenderManifest: () => DeepReadonly<PrerenderManifest>\n    fetchCacheKeyPrefix?: string\n    CurCacheHandler?: typeof CacheHandler\n  }) {\n    this.hasCustomCacheHandler = Boolean(CurCacheHandler)\n\n    const cacheHandlersSymbol = Symbol.for('@next/cache-handlers')\n    const _globalThis: typeof globalThis & {\n      [cacheHandlersSymbol]?: {\n        FetchCache?: typeof CacheHandler\n      }\n    } = globalThis\n\n    if (!CurCacheHandler) {\n      // if we have a global cache handler available leverage it\n      const globalCacheHandler = _globalThis[cacheHandlersSymbol]\n\n      if (globalCacheHandler?.FetchCache) {\n        CurCacheHandler = globalCacheHandler.FetchCache\n        if (IncrementalCache.debug) {\n          console.log('IncrementalCache: using global FetchCache cache handler')\n        }\n      } else {\n        if (fs && serverDistDir) {\n          if (IncrementalCache.debug) {\n            console.log('IncrementalCache: using filesystem cache handler')\n          }\n          CurCacheHandler = FileSystemCache\n        }\n      }\n    } else if (IncrementalCache.debug) {\n      console.log(\n        'IncrementalCache: using custom cache handler',\n        CurCacheHandler.name\n      )\n    }\n\n    if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n      // Allow cache size to be overridden for testing purposes\n      maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)\n    }\n    this.dev = dev\n    this.disableForTestmode = process.env.NEXT_PRIVATE_TEST_PROXY === 'true'\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n    this.requestHeaders = requestHeaders\n    this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys\n    this.prerenderManifest = getPrerenderManifest()\n    this.cacheControls = new SharedCacheControls(this.prerenderManifest)\n    this.fetchCacheKeyPrefix = fetchCacheKeyPrefix\n    let revalidatedTags: string[] = []\n\n    if (\n      requestHeaders[PRERENDER_REVALIDATE_HEADER] ===\n      this.prerenderManifest?.preview?.previewModeId\n    ) {\n      this.isOnDemandRevalidate = true\n    }\n\n    if (minimalMode) {\n      revalidatedTags = this.revalidatedTags = getPreviouslyRevalidatedTags(\n        requestHeaders,\n        this.prerenderManifest?.preview?.previewModeId\n      )\n    }\n\n    if (CurCacheHandler) {\n      this.cacheHandler = new CurCacheHandler({\n        dev,\n        fs,\n        flushToDisk,\n        serverDistDir,\n        revalidatedTags,\n        maxMemoryCacheSize,\n        _requestHeaders: requestHeaders,\n        fetchCacheKeyPrefix,\n      })\n    }\n  }\n\n  private calculateRevalidate(\n    pathname: string,\n    fromTime: number,\n    dev: boolean,\n    isFallback: boolean | undefined\n  ): Revalidate {\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    if (dev)\n      return Math.floor(performance.timeOrigin + performance.now() - 1000)\n\n    const cacheControl = this.cacheControls.get(toRoute(pathname))\n\n    // if an entry isn't present in routes we fallback to a default\n    // of revalidating after 1 second unless it's a fallback request.\n    const initialRevalidateSeconds = cacheControl\n      ? cacheControl.revalidate\n      : isFallback\n        ? false\n        : 1\n\n    const revalidateAfter =\n      typeof initialRevalidateSeconds === 'number'\n        ? initialRevalidateSeconds * 1000 + fromTime\n        : initialRevalidateSeconds\n\n    return revalidateAfter\n  }\n\n  _getPathname(pathname: string, fetchCache?: boolean) {\n    return fetchCache ? pathname : normalizePagePath(pathname)\n  }\n\n  resetRequestCache() {\n    this.cacheHandler?.resetRequestCache?.()\n  }\n\n  async lock(cacheKey: string): Promise<() => Promise<void> | void> {\n    // Wait for any existing lock on this cache key to be released\n    // This implements a simple queue-based locking mechanism\n    while (true) {\n      const lock = this.locks.get(cacheKey)\n\n      if (IncrementalCache.debug) {\n        console.log('IncrementalCache: lock get', cacheKey, !!lock)\n      }\n\n      // If no lock exists, we can proceed to acquire it\n      if (!lock) break\n\n      // Wait for the existing lock to be released before trying again\n      await lock\n    }\n\n    // Create a new detached promise that will represent this lock\n    // The resolve function (unlock) will be returned to the caller\n    const { resolve, promise } = new DetachedPromise<void>()\n\n    if (IncrementalCache.debug) {\n      console.log('IncrementalCache: successfully locked', cacheKey)\n    }\n\n    // Store the lock promise in the locks map\n    this.locks.set(cacheKey, promise)\n\n    return () => {\n      // Resolve the promise to release the lock.\n      resolve()\n\n      // Remove the lock from the map once it's released so that future gets\n      // can acquire the lock.\n      this.locks.delete(cacheKey)\n    }\n  }\n\n  async revalidateTag(\n    tags: string | string[],\n    durations?: { expire?: number }\n  ): Promise<void> {\n    return this.cacheHandler?.revalidateTag(tags, durations)\n  }\n\n  // x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23\n  async generateCacheKey(\n    url: string,\n    init: RequestInit | Request = {}\n  ): Promise<string> {\n    // this should be bumped anytime a fix is made to cache entries\n    // that should bust the cache\n    const MAIN_KEY_PREFIX = 'v3'\n\n    const bodyChunks: string[] = []\n\n    const encoder = new TextEncoder()\n    const decoder = new TextDecoder()\n\n    if (init.body) {\n      // handle Uint8Array body\n      if (init.body instanceof Uint8Array) {\n        bodyChunks.push(decoder.decode(init.body))\n        ;(init as any)._ogBody = init.body\n      } // handle ReadableStream body\n      else if (typeof (init.body as any).getReader === 'function') {\n        const readableBody = init.body as ReadableStream<Uint8Array | string>\n\n        const chunks: Uint8Array[] = []\n\n        try {\n          await readableBody.pipeTo(\n            new WritableStream({\n              write(chunk) {\n                if (typeof chunk === 'string') {\n                  chunks.push(encoder.encode(chunk))\n                  bodyChunks.push(chunk)\n                } else {\n                  chunks.push(chunk)\n                  bodyChunks.push(decoder.decode(chunk, { stream: true }))\n                }\n              },\n            })\n          )\n\n          // Flush the decoder.\n          bodyChunks.push(decoder.decode())\n\n          // Create a new buffer with all the chunks.\n          const length = chunks.reduce((total, arr) => total + arr.length, 0)\n          const arrayBuffer = new Uint8Array(length)\n\n          // Push each of the chunks into the new array buffer.\n          let offset = 0\n          for (const chunk of chunks) {\n            arrayBuffer.set(chunk, offset)\n            offset += chunk.length\n          }\n\n          ;(init as any)._ogBody = arrayBuffer\n        } catch (err) {\n          console.error('Problem reading body', err)\n        }\n      } // handle FormData or URLSearchParams bodies\n      else if (typeof (init.body as any).keys === 'function') {\n        const formData = init.body as FormData\n        ;(init as any)._ogBody = init.body\n        for (const key of new Set([...formData.keys()])) {\n          const values = formData.getAll(key)\n          bodyChunks.push(\n            `${key}=${(\n              await Promise.all(\n                values.map(async (val) => {\n                  if (typeof val === 'string') {\n                    return val\n                  } else {\n                    return await val.text()\n                  }\n                })\n              )\n            ).join(',')}`\n          )\n        }\n        // handle blob body\n      } else if (typeof (init.body as any).arrayBuffer === 'function') {\n        const blob = init.body as Blob\n        const arrayBuffer = await blob.arrayBuffer()\n        bodyChunks.push(await blob.text())\n        ;(init as any)._ogBody = new Blob([arrayBuffer], { type: blob.type })\n      } else if (typeof init.body === 'string') {\n        bodyChunks.push(init.body)\n        ;(init as any)._ogBody = init.body\n      }\n    }\n\n    const headers =\n      typeof (init.headers || {}).keys === 'function'\n        ? Object.fromEntries(init.headers as Headers)\n        : Object.assign({}, init.headers)\n\n    // w3c trace context headers can break request caching and deduplication\n    // so we remove them from the cache key\n    if ('traceparent' in headers) delete headers['traceparent']\n    if ('tracestate' in headers) delete headers['tracestate']\n\n    const cacheString = JSON.stringify([\n      MAIN_KEY_PREFIX,\n      this.fetchCacheKeyPrefix || '',\n      url,\n      init.method,\n      headers,\n      init.mode,\n      init.redirect,\n      init.credentials,\n      init.referrer,\n      init.referrerPolicy,\n      init.integrity,\n      init.cache,\n      bodyChunks,\n    ])\n\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      function bufferToHex(buffer: ArrayBuffer): string {\n        return Array.prototype.map\n          .call(new Uint8Array(buffer), (b) => b.toString(16).padStart(2, '0'))\n          .join('')\n      }\n      const buffer = encoder.encode(cacheString)\n      return bufferToHex(await crypto.subtle.digest('SHA-256', buffer))\n    } else {\n      const crypto = require('crypto') as typeof import('crypto')\n      return crypto.createHash('sha256').update(cacheString).digest('hex')\n    }\n  }\n\n  async get(\n    cacheKey: string,\n    ctx: GetIncrementalFetchCacheContext\n  ): Promise<IncrementalFetchCacheEntry | null>\n  async get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  async get(\n    cacheKey: string,\n    ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext\n  ): Promise<IncrementalCacheEntry | null> {\n    // Unlike other caches if we have a resume data cache, we use it even if\n    // testmode would normally disable it or if requestHeaders say 'no-cache'.\n    if (ctx.kind === IncrementalCacheKind.FETCH) {\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      const resumeDataCache = workUnitStore\n        ? getRenderResumeDataCache(workUnitStore)\n        : null\n      if (resumeDataCache) {\n        const memoryCacheData = resumeDataCache.fetch.get(cacheKey)\n        if (memoryCacheData?.kind === CachedRouteKind.FETCH) {\n          if (IncrementalCache.debug) {\n            console.log('IncrementalCache: rdc:hit', cacheKey)\n          }\n\n          return { isStale: false, value: memoryCacheData }\n        } else if (IncrementalCache.debug) {\n          console.log('IncrementalCache: rdc:miss', cacheKey)\n        }\n      } else {\n        if (IncrementalCache.debug) {\n          console.log('IncrementalCache: rdc:no-resume-data')\n        }\n      }\n    }\n\n    // we don't leverage the prerender cache in dev mode\n    // so that getStaticProps is always called for easier debugging\n    if (\n      this.disableForTestmode ||\n      (this.dev &&\n        (ctx.kind !== IncrementalCacheKind.FETCH ||\n          this.requestHeaders['cache-control'] === 'no-cache'))\n    ) {\n      return null\n    }\n\n    cacheKey = this._getPathname(\n      cacheKey,\n      ctx.kind === IncrementalCacheKind.FETCH\n    )\n\n    const cacheData = await this.cacheHandler?.get(cacheKey, ctx)\n\n    if (ctx.kind === IncrementalCacheKind.FETCH) {\n      if (!cacheData) {\n        return null\n      }\n\n      if (cacheData.value?.kind !== CachedRouteKind.FETCH) {\n        throw new InvariantError(\n          `Expected cached value for cache key ${JSON.stringify(cacheKey)} to be a \"FETCH\" kind, got ${JSON.stringify(cacheData.value?.kind)} instead.`\n        )\n      }\n\n      const workStore = workAsyncStorage.getStore()\n      const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])]\n      // if a tag was revalidated we don't return stale data\n      if (\n        combinedTags.some(\n          (tag) =>\n            this.revalidatedTags?.includes(tag) ||\n            workStore?.pendingRevalidatedTags?.some((item) => item.tag === tag)\n        )\n      ) {\n        if (IncrementalCache.debug) {\n          console.log('IncrementalCache: expired tag', cacheKey)\n        }\n\n        return null\n      }\n\n      // As we're able to get the cache entry for this fetch, and the prerender\n      // resume data cache (RDC) is available, it must have been populated by a\n      // previous fetch, but was not yet present in the in-memory cache. This\n      // could be the case when performing multiple renders in parallel during\n      // build time where we de-duplicate the fetch calls.\n      //\n      // We add it to the RDC so that the next fetch call will be able to use it\n      // and it won't have to reach into the fetch cache implementation.\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      if (workUnitStore) {\n        const prerenderResumeDataCache =\n          getPrerenderResumeDataCache(workUnitStore)\n        if (prerenderResumeDataCache) {\n          if (IncrementalCache.debug) {\n            console.log('IncrementalCache: rdc:set', cacheKey)\n          }\n\n          prerenderResumeDataCache.fetch.set(cacheKey, cacheData.value)\n        }\n      }\n\n      const revalidate = ctx.revalidate || cacheData.value.revalidate\n      const age =\n        (performance.timeOrigin +\n          performance.now() -\n          (cacheData.lastModified || 0)) /\n        1000\n\n      let isStale = age > revalidate\n      const data = cacheData.value.data\n\n      if (areTagsExpired(combinedTags, cacheData.lastModified)) {\n        return null\n      } else if (areTagsStale(combinedTags, cacheData.lastModified)) {\n        isStale = true\n      }\n\n      return {\n        isStale,\n        value: { kind: CachedRouteKind.FETCH, data, revalidate },\n      }\n    } else if (cacheData?.value?.kind === CachedRouteKind.FETCH) {\n      throw new InvariantError(\n        `Expected cached value for cache key ${JSON.stringify(cacheKey)} not to be a ${JSON.stringify(ctx.kind)} kind, got \"FETCH\" instead.`\n      )\n    }\n\n    let entry: IncrementalResponseCacheEntry | null = null\n    const cacheControl = this.cacheControls.get(toRoute(cacheKey))\n\n    let isStale: boolean | -1 | undefined\n    let revalidateAfter: Revalidate\n\n    if (cacheData?.lastModified === -1) {\n      isStale = -1\n      revalidateAfter = -1 * CACHE_ONE_YEAR\n    } else {\n      const now = performance.timeOrigin + performance.now()\n      const lastModified = cacheData?.lastModified || now\n\n      revalidateAfter = this.calculateRevalidate(\n        cacheKey,\n        lastModified,\n        this.dev ?? false,\n        ctx.isFallback\n      )\n\n      isStale =\n        revalidateAfter !== false && revalidateAfter < now ? true : undefined\n\n      // If the stale time couldn't be determined based on the revalidation\n      // time, we check if the tags are expired or stale.\n      if (\n        isStale === undefined &&\n        (cacheData?.value?.kind === CachedRouteKind.APP_PAGE ||\n          cacheData?.value?.kind === CachedRouteKind.APP_ROUTE)\n      ) {\n        const tagsHeader = cacheData.value.headers?.[NEXT_CACHE_TAGS_HEADER]\n\n        if (typeof tagsHeader === 'string') {\n          const cacheTags = tagsHeader.split(',')\n\n          if (cacheTags.length > 0) {\n            if (areTagsExpired(cacheTags, lastModified)) {\n              isStale = -1\n            } else if (areTagsStale(cacheTags, lastModified)) {\n              isStale = true\n            }\n          }\n        }\n      }\n    }\n\n    if (cacheData) {\n      entry = {\n        isStale,\n        cacheControl,\n        revalidateAfter,\n        value: cacheData.value,\n      }\n    }\n\n    if (\n      !cacheData &&\n      this.prerenderManifest.notFoundRoutes.includes(cacheKey)\n    ) {\n      // for the first hit after starting the server the cache\n      // may not have a way to save notFound: true so if\n      // the prerender-manifest marks this as notFound then we\n      // return that entry and trigger a cache set to give it a\n      // chance to update in-memory entries\n      entry = {\n        isStale,\n        value: null,\n        cacheControl,\n        revalidateAfter,\n      }\n      this.set(cacheKey, entry.value, { ...ctx, cacheControl })\n    }\n    return entry\n  }\n\n  async set(\n    pathname: string,\n    data: CachedFetchValue | null,\n    ctx: SetIncrementalFetchCacheContext\n  ): Promise<void>\n  async set(\n    pathname: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n  async set(\n    pathname: string,\n    data: IncrementalCacheValue | null,\n    ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext\n  ): Promise<void> {\n    // Even if we otherwise disable caching for testMode or if no fetchCache is\n    // configured we still always stash results in the resume data cache if one\n    // exists. This is because this is a transient in memory cache that\n    // populates caches ahead of a dynamic render in dev mode to allow the RSC\n    // debug info to have the right environment associated to it.\n    if (data?.kind === CachedRouteKind.FETCH) {\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      const prerenderResumeDataCache = workUnitStore\n        ? getPrerenderResumeDataCache(workUnitStore)\n        : null\n      if (prerenderResumeDataCache) {\n        if (IncrementalCache.debug) {\n          console.log('IncrementalCache: rdc:set', pathname)\n        }\n\n        prerenderResumeDataCache.fetch.set(pathname, data)\n      }\n    }\n\n    if (this.disableForTestmode || (this.dev && !ctx.fetchCache)) return\n\n    pathname = this._getPathname(pathname, ctx.fetchCache)\n\n    // FetchCache has upper limit of 2MB per-entry currently\n    const itemSize = JSON.stringify(data).length\n    if (\n      ctx.fetchCache &&\n      itemSize > 2 * 1024 * 1024 &&\n      // We ignore the size limit when custom cache handler is being used, as it\n      // might not have this limit\n      !this.hasCustomCacheHandler &&\n      // We also ignore the size limit when it's an implicit build-time-only\n      // caching that the user isn't even aware of.\n      !ctx.isImplicitBuildTimeCache\n    ) {\n      const warningText = `Failed to set Next.js data cache for ${ctx.fetchUrl || pathname}, items over 2MB can not be cached (${itemSize} bytes)`\n\n      if (this.dev) {\n        throw new Error(warningText)\n      }\n      console.warn(warningText)\n      return\n    }\n\n    try {\n      if (!ctx.fetchCache && ctx.cacheControl) {\n        this.cacheControls.set(toRoute(pathname), ctx.cacheControl)\n      }\n\n      await this.cacheHandler?.set(pathname, data, ctx)\n    } catch (error) {\n      console.warn('Failed to update prerender cache for', pathname, error)\n    }\n  }\n}\n"],"names":["IncrementalCacheKind","CachedRouteKind","FileSystemCache","normalizePagePath","CACHE_ONE_YEAR","NEXT_CACHE_TAGS_HEADER","PRERENDER_REVALIDATE_HEADER","toRoute","SharedCacheControls","getPrerenderResumeDataCache","getRenderResumeDataCache","workUnitAsyncStorage","InvariantError","getPreviouslyRevalidatedTags","workAsyncStorage","DetachedPromise","areTagsExpired","areTagsStale","CacheHandler","constructor","_ctx","get","_cacheKey","set","_data","revalidateTag","_tags","_durations","resetRequestCache","IncrementalCache","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","fs","dev","flushToDisk","minimalMode","serverDistDir","requestHeaders","maxMemoryCacheSize","getPrerenderManifest","fetchCacheKeyPrefix","CurCacheHandler","allowedRevalidateHeaderKeys","locks","Map","hasCustomCacheHandler","Boolean","cacheHandlersSymbol","Symbol","for","_globalThis","globalThis","globalCacheHandler","FetchCache","console","log","name","__NEXT_TEST_MAX_ISR_CACHE","parseInt","disableForTestmode","NEXT_PRIVATE_TEST_PROXY","minimalModeKey","prerenderManifest","cacheControls","revalidatedTags","preview","previewModeId","isOnDemandRevalidate","cacheHandler","_requestHeaders","calculateRevalidate","pathname","fromTime","isFallback","Math","floor","performance","timeOrigin","now","cacheControl","initialRevalidateSeconds","revalidate","revalidateAfter","_getPathname","fetchCache","lock","cacheKey","resolve","promise","delete","tags","durations","generateCacheKey","url","init","MAIN_KEY_PREFIX","bodyChunks","encoder","TextEncoder","decoder","TextDecoder","body","Uint8Array","push","decode","_ogBody","getReader","readableBody","chunks","pipeTo","WritableStream","write","chunk","encode","stream","length","reduce","total","arr","arrayBuffer","offset","err","error","keys","formData","key","Set","values","getAll","Promise","all","map","val","text","join","blob","Blob","type","headers","Object","fromEntries","assign","cacheString","JSON","stringify","method","mode","redirect","credentials","referrer","referrerPolicy","integrity","cache","NEXT_RUNTIME","bufferToHex","buffer","Array","prototype","call","b","toString","padStart","crypto","subtle","digest","require","createHash","update","ctx","cacheData","kind","FETCH","workUnitStore","getStore","resumeDataCache","memoryCacheData","fetch","isStale","value","workStore","combinedTags","softTags","some","tag","includes","pendingRevalidatedTags","item","prerenderResumeDataCache","age","lastModified","data","entry","undefined","APP_PAGE","APP_ROUTE","tagsHeader","cacheTags","split","notFoundRoutes","itemSize","isImplicitBuildTimeCache","warningText","fetchUrl","Error","warn"],"mappings":"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","ignoreList":[0]}