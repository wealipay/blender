{"version":3,"sources":["../../../src/server/lib/dedupe-fetch.ts"],"sourcesContent":["/**\n * Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js\n */\nimport * as React from 'react'\nimport { cloneResponse } from './clone-response'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst simpleCacheKey = '[\"GET\",[],null,\"follow\",null,null,null,null]' // generateCacheKey(new Request('https://blank'));\n\n// Headers that should not affect deduplication\n// traceparent and tracestate are used for distributed tracing and should not affect cache keys\nconst headersToExcludeInCacheKey = new Set(['traceparent', 'tracestate'])\n\nfunction generateCacheKey(request: Request): string {\n  // We pick the fields that goes into the key used to dedupe requests.\n  // We don't include the `cache` field, because we end up using whatever\n  // caching resulted from the first request.\n  // Notably we currently don't consider non-standard (or future) options.\n  // This might not be safe. TODO: warn for non-standard extensions differing.\n  // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.\n\n  const filteredHeaders = Array.from(request.headers.entries()).filter(\n    ([key]) => !headersToExcludeInCacheKey.has(key.toLowerCase())\n  )\n\n  return JSON.stringify([\n    request.method,\n    filteredHeaders,\n    request.mode,\n    request.redirect,\n    request.credentials,\n    request.referrer,\n    request.referrerPolicy,\n    request.integrity,\n  ])\n}\n\ntype CacheEntry = [\n  key: string,\n  promise: Promise<Response>,\n  response: Response | null,\n]\n\nexport function createDedupeFetch(originalFetch: typeof fetch) {\n  const getCacheEntries = React.cache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key\n    (url: string): CacheEntry[] => []\n  )\n\n  return function dedupeFetch(\n    resource: URL | RequestInfo,\n    options?: RequestInit\n  ): Promise<Response> {\n    if (options && options.signal) {\n      // If we're passed a signal, then we assume that\n      // someone else controls the lifetime of this object and opts out of\n      // caching. It's effectively the opt-out mechanism.\n      // Ideally we should be able to check this on the Request but\n      // it always gets initialized with its own signal so we don't\n      // know if it's supposed to override - unless we also override the\n      // Request constructor.\n      return originalFetch(resource, options)\n    }\n    // Normalize the Request\n    let url: string\n    let cacheKey: string\n    if (typeof resource === 'string' && !options) {\n      // Fast path.\n      cacheKey = simpleCacheKey\n      url = resource\n    } else {\n      // Normalize the request.\n      // if resource is not a string or a URL (its an instance of Request)\n      // then do not instantiate a new Request but instead\n      // reuse the request as to not disturb the body in the event it's a ReadableStream.\n      const request =\n        typeof resource === 'string' || resource instanceof URL\n          ? new Request(resource, options)\n          : resource\n      if (\n        (request.method !== 'GET' && request.method !== 'HEAD') ||\n        request.keepalive\n      ) {\n        // We currently don't dedupe requests that might have side-effects. Those\n        // have to be explicitly cached. We assume that the request doesn't have a\n        // body if it's GET or HEAD.\n        // keepalive gets treated the same as if you passed a custom cache signal.\n        return originalFetch(resource, options)\n      }\n      cacheKey = generateCacheKey(request)\n      url = request.url\n    }\n\n    const cacheEntries = getCacheEntries(url)\n    for (let i = 0, j = cacheEntries.length; i < j; i += 1) {\n      const [key, promise] = cacheEntries[i]\n      if (key === cacheKey) {\n        return promise.then(() => {\n          const response = cacheEntries[i][2]\n          if (!response) throw new InvariantError('No cached response')\n\n          // We're cloning the response using this utility because there exists\n          // a bug in the undici library around response cloning. See the\n          // following pull request for more details:\n          // https://github.com/vercel/next.js/pull/73274\n          const [cloned1, cloned2] = cloneResponse(response)\n          cacheEntries[i][2] = cloned2\n          return cloned1\n        })\n      }\n    }\n\n    // We pass the original arguments here in case normalizing the Request\n    // doesn't include all the options in this environment.\n    const promise = originalFetch(resource, options)\n    const entry: CacheEntry = [cacheKey, promise, null]\n    cacheEntries.push(entry)\n\n    return promise.then((response) => {\n      // We're cloning the response using this utility because there exists\n      // a bug in the undici library around response cloning. See the\n      // following pull request for more details:\n      // https://github.com/vercel/next.js/pull/73274\n      const [cloned1, cloned2] = cloneResponse(response)\n      entry[2] = cloned2\n      return cloned1\n    })\n  }\n}\n"],"names":["React","cloneResponse","InvariantError","simpleCacheKey","headersToExcludeInCacheKey","Set","generateCacheKey","request","filteredHeaders","Array","from","headers","entries","filter","key","has","toLowerCase","JSON","stringify","method","mode","redirect","credentials","referrer","referrerPolicy","integrity","createDedupeFetch","originalFetch","getCacheEntries","cache","url","dedupeFetch","resource","options","signal","cacheKey","URL","Request","keepalive","cacheEntries","i","j","length","promise","then","response","cloned1","cloned2","entry","push"],"mappings":"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","ignoreList":[0]}