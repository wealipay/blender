{"version":3,"sources":["../../../src/client/components/app-router.tsx"],"sourcesContent":["import React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type {\n  AppHistoryState,\n  AppRouterState,\n} from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\nimport type { StaticIndicatorState } from '../dev/hot-reloader/app/hot-reloader-app'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState\n\n    const appHistoryState: AppHistoryState = {\n      tree,\n      renderedSearch,\n    }\n\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n      pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n    }\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nexport function createEmptyCacheNode(): CacheNode {\n  return {\n    lazyData: null,\n    rsc: null,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    parallelRoutes: new Map(),\n    loading: null,\n    navigatedAt: -1,\n  }\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { cache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        tree,\n      }\n    }, [cache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const appHistoryState: AppHistoryState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          historyState: appHistoryState,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  // Create instrumented promises for navigation hooks (dev-only)\n  // These are specially instrumented promises to show in the Suspense DevTools\n  // Promises are cached outside of render to survive suspense retries.\n  let instrumentedNavigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createRootNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    instrumentedNavigationPromises = createRootNavigationPromises(\n      tree,\n      pathname,\n      searchParams,\n      pathParams\n    )\n  }\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      parentParams: {},\n      // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n      // It represents the root of the app.\n      debugNameContext: '/',\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n      // Root segment is always active\n      isActive: true,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n      previousNextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl, previousNextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader\n        globalError={globalError}\n        webSocket={webSocket}\n        staticIndicatorState={staticIndicatorState}\n      >\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <NavigationPromisesContext.Provider\n        value={instrumentedNavigationPromises}\n      >\n        <PathParamsContext.Provider value={pathParams}>\n          <PathnameContext.Provider value={pathname}>\n            <SearchParamsContext.Provider value={searchParams}>\n              <GlobalLayoutRouterContext.Provider\n                value={globalLayoutRouterContext}\n              >\n                {/* TODO: We should be able to remove this context. useRouter\n                    should import from app-router-instance instead. It's only\n                    necessary because useRouter is shared between Pages and\n                    App Router. We should fork that module, then remove this\n                    context provider. */}\n                <AppRouterContext.Provider value={publicAppRouterInstance}>\n                  <LayoutRouterContext.Provider value={layoutRouterContext}>\n                    {content}\n                  </LayoutRouterContext.Provider>\n                </AppRouterContext.Provider>\n              </GlobalLayoutRouterContext.Provider>\n            </SearchParamsContext.Provider>\n          </PathnameContext.Provider>\n        </PathParamsContext.Provider>\n      </NavigationPromisesContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  webSocket?: WebSocket\n  staticIndicatorState?: StaticIndicatorState\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      globalError={globalErrorState}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = process.env.NEXT_DEPLOYMENT_ID\n    ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n    : ''\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n"],"names":["React","useEffect","useMemo","startTransition","useInsertionEffect","useDeferredValue","AppRouterContext","LayoutRouterContext","GlobalLayoutRouterContext","ACTION_RESTORE","createHrefFromUrl","SearchParamsContext","PathnameContext","PathParamsContext","NavigationPromisesContext","dispatchAppRouterAction","useActionQueue","AppRouterAnnouncer","RedirectBoundary","findHeadInCache","unresolvedThenable","removeBasePath","hasBasePath","getSelectedParams","useNavFailureHandler","dispatchTraverseAction","publicAppRouterInstance","getRedirectTypeFromError","getURLFromRedirectError","isRedirectError","RedirectType","pingVisibleLinks","RootErrorBoundary","DefaultGlobalError","RootLayoutBoundary","globalMutable","HistoryUpdater","appRouterState","process","env","__NEXT_APP_NAV_FAIL_HANDLING","window","next","__pendingUrl","undefined","tree","pushRef","canonicalUrl","renderedSearch","appHistoryState","historyState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","URL","location","href","pushState","replaceState","__NEXT_CLIENT_SEGMENT_CACHE","nextUrl","createEmptyCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","parallelRoutes","Map","loading","navigatedAt","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","resolvedPrefetchRsc","Router","actionQueue","globalError","webSocket","staticIndicatorState","searchParams","pathname","url","NODE_ENV","cache","nd","router","handlePageShow","event","persisted","pendingMpaPath","type","addEventListener","removeEventListener","handleUnhandledRedirect","error","reason","preventDefault","redirectType","push","replace","mpaNavigation","assign","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","_unused","_N","onPopState","reload","focusAndScrollRef","previousNextUrl","matchingHead","pathParams","instrumentedNavigationPromises","createRootNavigationPromises","require","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","debugNameContext","isActive","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","DevRootHTTPAccessFallbackBoundary","HotReloader","default","errorComponent","errorStyles","RuntimeStyles","Provider","value","AppRouter","globalErrorState","runtimeStyles","Set","runtimeStyleChanged","globalThis","_N_E_STYLE_LOAD","len","size","add","forEach","cb","Promise","resolve","forceUpdate","useState","renderedStylesSize","changed","c","delete","dplId","NEXT_DEPLOYMENT_ID","map","i","link","rel","precedence"],"mappings":"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","ignoreList":[0]}