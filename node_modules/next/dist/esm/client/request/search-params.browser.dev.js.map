{"version":3,"sources":["../../../src/client/request/search-params.browser.dev.ts"],"sourcesContent":["import type { SearchParams } from '../../server/request/search-params'\n\nimport { ReflectAdapter } from '../../server/web/spec-extension/adapters/reflect'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      warnForSyncSpread()\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction warnForSyncAccess(expression: string) {\n  console.error(\n    `A searchParam property was accessed directly with ${expression}. ` +\n      `\\`searchParams\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction warnForSyncSpread() {\n  console.error(\n    `The keys of \\`searchParams\\` were accessed directly. ` +\n      `\\`searchParams\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nexport function createRenderSearchParamsFromClient(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams)\n}\n"],"names":["ReflectAdapter","describeStringPropertyAccess","describeHasCheckingStringProperty","wellKnownProperties","CachedSearchParams","WeakMap","makeUntrackedSearchParamsWithDevWarnings","underlyingSearchParams","cachedSearchParams","get","proxiedProperties","Set","promise","Promise","resolve","Object","keys","forEach","prop","has","add","proxiedPromise","Proxy","target","receiver","Reflect","expression","warnForSyncAccess","set","value","delete","ownKeys","warnForSyncSpread","console","error","createRenderSearchParamsFromClient"],"mappings":"AAEA,SAASA,cAAc,QAAQ,mDAAkD;AACjF,SACEC,4BAA4B,EAC5BC,iCAAiC,EACjCC,mBAAmB,QACd,uCAAsC;AAG7C,MAAMC,qBAAqB,IAAIC;AAE/B,SAASC,yCACPC,sBAAoC;IAEpC,MAAMC,qBAAqBJ,mBAAmBK,GAAG,CAACF;IAClD,IAAIC,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAME,oBAAoB,IAAIC;IAC9B,MAAMC,UAAUC,QAAQC,OAAO,CAACP;IAEhCQ,OAAOC,IAAI,CAACT,wBAAwBU,OAAO,CAAC,CAACC;QAC3C,IAAIf,oBAAoBgB,GAAG,CAACD,OAAO;QACjC,kEAAkE;QAClE,kEAAkE;QACpE,OAAO;YACLR,kBAAkBU,GAAG,CAACF;QACxB;IACF;IAEA,MAAMG,iBAAiB,IAAIC,MAAMV,SAAS;QACxCH,KAAIc,MAAM,EAAEL,IAAI,EAAEM,QAAQ;YACxB,IAAI,OAAON,SAAS,UAAU;gBAC5B,IACE,CAACf,oBAAoBgB,GAAG,CAACD,SACxBR,CAAAA,kBAAkBS,GAAG,CAACD,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BO,QAAQN,GAAG,CAACI,QAAQL,UAAU,KAAI,GACpC;oBACA,MAAMQ,aAAazB,6BAA6B,gBAAgBiB;oBAChES,kBAAkBD;gBACpB;YACF;YACA,OAAO1B,eAAeS,GAAG,CAACc,QAAQL,MAAMM;QAC1C;QACAI,KAAIL,MAAM,EAAEL,IAAI,EAAEW,KAAK,EAAEL,QAAQ;YAC/B,IAAI,OAAON,SAAS,UAAU;gBAC5BR,kBAAkBoB,MAAM,CAACZ;YAC3B;YACA,OAAOO,QAAQG,GAAG,CAACL,QAAQL,MAAMW,OAAOL;QAC1C;QACAL,KAAII,MAAM,EAAEL,IAAI;YACd,IAAI,OAAOA,SAAS,UAAU;gBAC5B,IACE,CAACf,oBAAoBgB,GAAG,CAACD,SACxBR,CAAAA,kBAAkBS,GAAG,CAACD,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BO,QAAQN,GAAG,CAACI,QAAQL,UAAU,KAAI,GACpC;oBACA,MAAMQ,aAAaxB,kCACjB,gBACAgB;oBAEFS,kBAAkBD;gBACpB;YACF;YACA,OAAOD,QAAQN,GAAG,CAACI,QAAQL;QAC7B;QACAa,SAAQR,MAAM;YACZS;YACA,OAAOP,QAAQM,OAAO,CAACR;QACzB;IACF;IAEAnB,mBAAmBwB,GAAG,CAACrB,wBAAwBc;IAC/C,OAAOA;AACT;AAEA,SAASM,kBAAkBD,UAAkB;IAC3CO,QAAQC,KAAK,CACX,CAAC,kDAAkD,EAAER,WAAW,EAAE,CAAC,GACjE,CAAC,0GAA0G,CAAC,GAC5G,CAAC,8DAA8D,CAAC;AAEtE;AAEA,SAASM;IACPC,QAAQC,KAAK,CACX,CAAC,qDAAqD,CAAC,GACrD,CAAC,0GAA0G,CAAC,GAC5G,CAAC,8DAA8D,CAAC;AAEtE;AAEA,OAAO,SAASC,mCACd5B,sBAAoC;IAEpC,OAAOD,yCAAyCC;AAClD","ignoreList":[0]}