{"version":3,"sources":["../../../src/build/adapter/build-complete.ts"],"sourcesContent":["import path from 'path'\nimport fs from 'fs/promises'\nimport { pathToFileURL } from 'url'\nimport * as Log from '../output/log'\nimport { isMiddlewareFilename } from '../utils'\nimport { RenderingMode } from '../rendering-mode'\nimport { interopDefault } from '../../lib/interop-default'\nimport type { RouteHas } from '../../lib/load-custom-routes'\nimport { recursiveReadDir } from '../../lib/recursive-readdir'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { Revalidate } from '../../server/lib/cache-control'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { AdapterOutputType, type PHASE_TYPE } from '../../shared/lib/constants'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\nimport {\n  convertRedirects,\n  convertRewrites,\n  convertHeaders,\n} from 'next/dist/compiled/@vercel/routing-utils'\n\nimport type {\n  MiddlewareManifest,\n  EdgeFunctionDefinition,\n} from '../webpack/plugins/middleware-plugin'\n\nimport type {\n  RoutesManifest,\n  PrerenderManifest,\n  ManifestRewriteRoute,\n  FunctionsConfigManifest,\n  DynamicPrerenderManifestRoute,\n} from '..'\n\nimport {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../../lib/constants'\nimport { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { getRedirectStatus, modifyRouteRegex } from '../../lib/redirect-status'\nimport { getNamedRouteRegex } from '../../shared/lib/router/utils/route-regex'\nimport { escapeStringRegexp } from '../../shared/lib/escape-regexp'\nimport { sortSortableRoutes } from '../../shared/lib/router/utils/sortable-routes'\nimport { nodeFileTrace } from 'next/dist/compiled/@vercel/nft'\nimport { defaultOverrides } from '../../server/require-hook'\nimport { makeIgnoreFn } from '../collect-build-traces'\n\ninterface SharedRouteFields {\n  /**\n   * id is the unique identifier of the output\n   */\n  id: string\n  /**\n   * filePath is the location on disk of the built entrypoint asset\n   */\n  filePath: string\n  /**\n   * pathname is the URL pathname the asset should be served at\n   */\n  pathname: string\n\n  /**\n   * sourcePage is the original source in the app or pages folder\n   */\n  sourcePage: string\n\n  /**\n   * runtime is which runtime the entrypoint is built for\n   */\n  runtime: 'nodejs' | 'edge'\n  /**\n   * assets are all necessary traced assets that could be\n   * loaded by the output to handle a request e.g. traced\n   * node_modules or necessary manifests for Next.js.\n   * The key is the relative path from the repo root and the value\n   * is the absolute path to the file\n   */\n  assets: Record<string, string>\n\n  /**\n   * wasmAssets are bundled wasm files with mapping of name\n   * to filePath on disk\n   */\n  wasmAssets?: Record<string, string>\n\n  /**\n   * config related to the route\n   */\n  config: {\n    /**\n     * maxDuration is a segment config to signal the max\n     * execution duration a route should be allowed before\n     * it's timed out\n     */\n    maxDuration?: number\n    /**\n     * preferredRegion is a segment config to signal deployment\n     * region preferences to the provider being used\n     */\n    preferredRegion?: string | string[]\n\n    /**\n     * env is the environment variables to expose, this is only\n     * populated for edge runtime currently\n     */\n    env?: Record<string, string>\n  }\n}\n\nexport interface AdapterOutput {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES: SharedRouteFields & {\n    type: AdapterOutputType.PAGES\n  }\n\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API: SharedRouteFields & {\n    type: AdapterOutputType.PAGES_API\n  }\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE: SharedRouteFields & {\n    type: AdapterOutputType.APP_PAGE\n  }\n\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE: SharedRouteFields & {\n    type: AdapterOutputType.APP_ROUTE\n  }\n\n  /**\n   * `PRERENDER` represents an ISR enabled route that might\n   * have a seeded cache entry or fallback generated during build\n   */\n  PRERENDER: {\n    id: string\n    pathname: string\n    type: AdapterOutputType.PRERENDER\n\n    /**\n     * For prerenders the parent output is the originating\n     * page that the prerender is created from\n     */\n    parentOutputId: string\n\n    /**\n     * groupId is the identifier for a group of prerenders that should be\n     * revalidated together\n     */\n    groupId: number\n\n    pprChain?: {\n      headers: Record<string, string>\n    }\n\n    /**\n     * parentFallbackMode signals whether additional routes can be generated\n     * e.g. fallback: false or 'blocking' in getStaticPaths in pages router\n     */\n    parentFallbackMode?: DynamicPrerenderManifestRoute['fallback']\n\n    /**\n     * fallback is initial cache data generated during build for a prerender\n     */\n    fallback?: {\n      /**\n       * path to the fallback file can be HTML/JSON/RSC\n       */\n      filePath: string\n      /**\n       * initialStatus is the status code that should be applied\n       * when serving the fallback\n       */\n      initialStatus?: number\n      /**\n       * initialHeaders are the headers that should be sent when\n       * serving the fallback\n       */\n      initialHeaders?: Record<string, string | string[]>\n      /**\n       * initial expiration is how long until the fallback entry\n       * is considered expired and no longer valid to serve\n       */\n      initialExpiration?: number\n      /**\n       * initial revalidate is how long until the fallback is\n       * considered stale and should be revalidated\n       */\n      initialRevalidate?: Revalidate\n\n      /**\n       * postponedState is the PPR state when it postponed and is used for resuming\n       */\n      postponedState?: string\n    }\n    /**\n     * config related to the route\n     */\n    config: {\n      /**\n       * allowQuery is the allowed query values to be passed\n       * to an ISR function and what should be considered for the cacheKey\n       * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n       */\n      allowQuery?: string[]\n      /**\n       * allowHeader is the allowed headers to be passed to an\n       * ISR function to prevent accidentally poisoning the cache\n       * from leaking additional information that can impact the render\n       */\n      allowHeader?: string[]\n      /**\n       * bypass for is a list of has conditions the cache\n       * should be bypassed and invoked directly e.g. action header\n       */\n      bypassFor?: RouteHas[]\n      /**\n       * renderingMode signals PPR or not for a prerender\n       */\n      renderingMode?: RenderingMode\n\n      /**\n       * bypassToken is the generated token that signals a prerender cache\n       * should be bypassed\n       */\n      bypassToken?: string\n    }\n  }\n\n  /**\n   * `STATIC_FILE` represents a static file (ie /_next/static) or a purely\n   * static HTML asset e.g. an automatically statically optimized page\n   * that does not use ISR\n   */\n  STATIC_FILE: {\n    id: string\n    filePath: string\n    pathname: string\n    type: AdapterOutputType.STATIC_FILE\n  }\n\n  /**\n   * `MIDDLEWARE` represents the middleware output if present\n   */\n  MIDDLEWARE: SharedRouteFields & {\n    type: AdapterOutputType.MIDDLEWARE\n    /**\n     * config related to the route\n     */\n    config: SharedRouteFields['config'] & {\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: Array<{\n        source: string\n        sourceRegex: string\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n      }>\n    }\n  }\n}\n\nexport interface AdapterOutputs {\n  pages: Array<AdapterOutput['PAGES']>\n  middleware?: AdapterOutput['MIDDLEWARE']\n  appPages: Array<AdapterOutput['APP_PAGE']>\n  pagesApi: Array<AdapterOutput['PAGES_API']>\n  appRoutes: Array<AdapterOutput['APP_ROUTE']>\n  prerenders: Array<AdapterOutput['PRERENDER']>\n  staticFiles: Array<AdapterOutput['STATIC_FILE']>\n}\n\ntype RewriteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\ntype DynamicRouteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\nexport interface NextAdapter {\n  name: string\n  /**\n   * modifyConfig is called for any CLI command that loads the next.config\n   * to only apply for specific commands the \"phase\" should be used\n   * @param config\n   * @param ctx\n   * @returns\n   */\n  modifyConfig?: (\n    config: NextConfigComplete,\n    ctx: {\n      phase: PHASE_TYPE\n    }\n  ) => Promise<NextConfigComplete> | NextConfigComplete\n  onBuildComplete?: (ctx: {\n    routes: {\n      headers: Array<{\n        source: string\n        sourceRegex: string\n        headers: Record<string, string>\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n        priority?: boolean\n      }>\n      redirects: Array<{\n        source: string\n        sourceRegex: string\n        destination: string\n        statusCode: number\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n        priority?: boolean\n      }>\n      rewrites: {\n        beforeFiles: RewriteItem[]\n        afterFiles: RewriteItem[]\n        fallback: RewriteItem[]\n      }\n      dynamicRoutes: Array<DynamicRouteItem>\n    }\n    outputs: AdapterOutputs\n    /**\n     * projectDir is the absolute directory the Next.js application is in\n     */\n    projectDir: string\n    /**\n     * repoRoot is the absolute path of the detected root of the repo\n     */\n    repoRoot: string\n    /**\n     * distDir is the absolute path to the dist directory\n     */\n    distDir: string\n    /**\n     * config is the loaded next.config (has modifyConfig applied)\n     */\n    config: NextConfigComplete\n    /**\n     * nextVersion is the current version of Next.js being used\n     */\n    nextVersion: string\n    /**\n     * buildId is the current unique ID for the build, this can be\n     * influenced by NextConfig.generateBuildId\n     */\n    buildId: string\n  }) => Promise<void> | void\n}\n\nfunction normalizePathnames(\n  config: NextConfigComplete,\n  outputs: AdapterOutputs\n) {\n  // normalize pathname field with basePath\n  if (config.basePath) {\n    for (const output of [\n      ...outputs.pages,\n      ...outputs.pagesApi,\n      ...outputs.appPages,\n      ...outputs.appRoutes,\n      ...outputs.prerenders,\n      ...outputs.staticFiles,\n    ]) {\n      output.pathname =\n        addPathPrefix(output.pathname, config.basePath).replace(/\\/$/, '') ||\n        '/'\n    }\n  }\n}\n\nexport async function handleBuildComplete({\n  dir,\n  config,\n  buildId,\n  configOutDir,\n  distDir,\n  pageKeys,\n  tracingRoot,\n  adapterPath,\n  appPageKeys,\n  staticPages,\n  nextVersion,\n  hasStatic404,\n  hasStatic500,\n  routesManifest,\n  serverPropsPages,\n  hasNodeMiddleware,\n  prerenderManifest,\n  middlewareManifest,\n  requiredServerFiles,\n  hasInstrumentationHook,\n  functionsConfigManifest,\n}: {\n  dir: string\n  distDir: string\n  buildId: string\n  configOutDir: string\n  adapterPath: string\n  tracingRoot: string\n  nextVersion: string\n  hasStatic404: boolean\n  hasStatic500: boolean\n  staticPages: Set<string>\n  hasNodeMiddleware: boolean\n  config: NextConfigComplete\n  pageKeys: readonly string[]\n  serverPropsPages: Set<string>\n  requiredServerFiles: string[]\n  routesManifest: RoutesManifest\n  hasInstrumentationHook: boolean\n  prerenderManifest: PrerenderManifest\n  middlewareManifest: MiddlewareManifest\n  appPageKeys?: readonly string[] | undefined\n  functionsConfigManifest: FunctionsConfigManifest\n}) {\n  const adapterMod = interopDefault(\n    await import(pathToFileURL(require.resolve(adapterPath)).href)\n  ) as NextAdapter\n\n  if (typeof adapterMod.onBuildComplete === 'function') {\n    const outputs: AdapterOutputs = {\n      pages: [],\n      pagesApi: [],\n      appPages: [],\n      appRoutes: [],\n      prerenders: [],\n      staticFiles: [],\n    }\n\n    if (config.output === 'export') {\n      // collect export assets and provide as static files\n      const exportFiles = await recursiveReadDir(configOutDir)\n\n      for (const file of exportFiles) {\n        let pathname = (\n          file.endsWith('.html') ? file.replace(/\\.html$/, '') : file\n        ).replace(/\\\\/g, '/')\n\n        pathname = pathname.startsWith('/') ? pathname : `/${pathname}`\n\n        outputs.staticFiles.push({\n          id: file,\n          pathname,\n          filePath: path.join(configOutDir, file),\n          type: AdapterOutputType.STATIC_FILE,\n        } satisfies AdapterOutput['STATIC_FILE'])\n      }\n    } else {\n      const staticFiles = await recursiveReadDir(path.join(distDir, 'static'))\n\n      for (const file of staticFiles) {\n        const pathname = path.posix.join('/_next/static', file)\n        const filePath = path.join(distDir, 'static', file)\n        outputs.staticFiles.push({\n          type: AdapterOutputType.STATIC_FILE,\n          id: path.join('static', file),\n          pathname,\n          filePath,\n        })\n      }\n\n      const sharedNodeAssets: Record<string, string> = {}\n      const pagesSharedNodeAssets: Record<string, string> = {}\n      const appPagesSharedNodeAssets: Record<string, string> = {}\n\n      const sharedTraceIgnores = [\n        '**/next/dist/compiled/next-server/**/*.dev.js',\n        '**/next/dist/compiled/webpack/*',\n        '**/node_modules/webpack5/**/*',\n        '**/next/dist/server/lib/route-resolver*',\n        'next/dist/compiled/semver/semver/**/*.js',\n        '**/node_modules/react{,-dom,-dom-server-turbopack}/**/*.development.js',\n        '**/*.d.ts',\n        '**/*.map',\n        '**/next/dist/pages/**/*',\n        '**/node_modules/sharp/**/*',\n        '**/@img/sharp-libvips*/**/*',\n        '**/next/dist/compiled/edge-runtime/**/*',\n        '**/next/dist/server/web/sandbox/**/*',\n        '**/next/dist/server/post-process.js',\n      ]\n      const sharedIgnoreFn = makeIgnoreFn(tracingRoot, sharedTraceIgnores)\n\n      for (const file of requiredServerFiles) {\n        // add to shared node assets\n        const filePath = path.join(dir, file)\n        const fileOutputPath = path.relative(tracingRoot, filePath)\n        sharedNodeAssets[fileOutputPath] = filePath\n      }\n\n      const moduleTypes = ['app-page', 'pages'] as const\n\n      for (const type of moduleTypes) {\n        const currentDependencies: string[] = []\n        const modulePath = require.resolve(\n          `next/dist/server/route-modules/${type}/module.compiled`\n        )\n        const contextDir = path.join(\n          path.dirname(modulePath),\n          'vendored',\n          'contexts'\n        )\n\n        for (const item of await fs.readdir(contextDir)) {\n          if (item.match(/\\.(mjs|cjs|js)$/)) {\n            currentDependencies.push(path.join(contextDir, item))\n          }\n        }\n\n        const { fileList, esmFileList } = await nodeFileTrace(\n          currentDependencies,\n          {\n            base: tracingRoot,\n            ignore: sharedIgnoreFn,\n          }\n        )\n        esmFileList.forEach((item) => fileList.add(item))\n\n        for (const rootRelativeFilePath of fileList) {\n          if (type === 'pages') {\n            pagesSharedNodeAssets[rootRelativeFilePath] = path.join(\n              tracingRoot,\n              rootRelativeFilePath\n            )\n          } else {\n            appPagesSharedNodeAssets[rootRelativeFilePath] = path.join(\n              tracingRoot,\n              rootRelativeFilePath\n            )\n          }\n        }\n      }\n\n      // These are modules that are necessary for bootstrapping node env\n      const necessaryNodeDependencies = [\n        require.resolve('next/dist/server/node-environment'),\n        require.resolve('next/dist/server/require-hook'),\n        require.resolve('next/dist/server/node-polyfill-crypto'),\n        ...Object.values(defaultOverrides).filter((item) => path.extname(item)),\n      ]\n\n      const { fileList, esmFileList } = await nodeFileTrace(\n        necessaryNodeDependencies,\n        {\n          base: tracingRoot,\n          ignore: sharedIgnoreFn,\n        }\n      )\n      esmFileList.forEach((item) => fileList.add(item))\n\n      for (const rootRelativeFilePath of fileList) {\n        sharedNodeAssets[rootRelativeFilePath] = path.join(\n          tracingRoot,\n          rootRelativeFilePath\n        )\n      }\n\n      if (hasInstrumentationHook) {\n        const assets = await handleTraceFiles(\n          path.join(distDir, 'server', 'instrumentation.js.nft.json'),\n          'neutral'\n        )\n        const fileOutputPath = path.relative(\n          tracingRoot,\n          path.join(distDir, 'server', 'instrumentation.js')\n        )\n        sharedNodeAssets[fileOutputPath] = path.join(\n          distDir,\n          'server',\n          'instrumentation.js'\n        )\n        Object.assign(sharedNodeAssets, assets)\n      }\n\n      async function handleTraceFiles(\n        traceFilePath: string,\n        type: 'pages' | 'app' | 'neutral'\n      ): Promise<Record<string, string>> {\n        const assets: Record<string, string> = Object.assign(\n          {},\n          sharedNodeAssets,\n          type === 'pages' ? pagesSharedNodeAssets : {},\n          type === 'app' ? appPagesSharedNodeAssets : {}\n        )\n        const traceData = JSON.parse(\n          await fs.readFile(traceFilePath, 'utf8')\n        ) as {\n          files: string[]\n        }\n        const traceFileDir = path.dirname(traceFilePath)\n\n        for (const relativeFile of traceData.files) {\n          const tracedFilePath = path.join(traceFileDir, relativeFile)\n          const fileOutputPath = path.relative(tracingRoot, tracedFilePath)\n          assets[fileOutputPath] = tracedFilePath\n        }\n        return assets\n      }\n\n      async function handleEdgeFunction(\n        page: EdgeFunctionDefinition,\n        isMiddleware: boolean = false\n      ) {\n        let type: AdapterOutputType = AdapterOutputType.PAGES\n        const isAppPrefix = page.name.startsWith('app/')\n        const isAppPage = isAppPrefix && page.name.endsWith('/page')\n        const isAppRoute = isAppPrefix && page.name.endsWith('/route')\n        let currentOutputs: Array<\n          | AdapterOutput['PAGES']\n          | AdapterOutput['PAGES_API']\n          | AdapterOutput['APP_PAGE']\n          | AdapterOutput['APP_ROUTE']\n        > = outputs.pages\n\n        if (isMiddleware) {\n          type = AdapterOutputType.MIDDLEWARE\n        } else if (isAppPage) {\n          currentOutputs = outputs.appPages\n          type = AdapterOutputType.APP_PAGE\n        } else if (isAppRoute) {\n          currentOutputs = outputs.appRoutes\n          type = AdapterOutputType.APP_ROUTE\n        } else if (page.page.startsWith('/api')) {\n          currentOutputs = outputs.pagesApi\n          type = AdapterOutputType.PAGES_API\n        }\n\n        const route = page.page.replace(/^(app|pages)\\//, '')\n\n        const output: Omit<AdapterOutput[typeof type], 'type'> & {\n          type: any\n        } = {\n          type,\n          id: page.name,\n          runtime: 'edge',\n          sourcePage: route,\n          pathname: isAppPrefix ? normalizeAppPath(route) : route,\n          filePath: path.join(\n            distDir,\n            page.files.find(\n              (item) =>\n                item.startsWith('server/app') || item.startsWith('server/pages')\n            ) ||\n              // TODO: turbopack build doesn't name the main entry chunk\n              // identifiably so we don't know which to mark here but\n              // technically edge needs all chunks to load always so\n              // should this field even be provided?\n              page.files[0] ||\n              ''\n          ),\n          assets: {},\n          wasmAssets: {},\n          config: {\n            env: page.env,\n          },\n        }\n\n        function handleFile(file: string) {\n          const originalPath = path.join(distDir, file)\n          const fileOutputPath = path.join(\n            path.relative(tracingRoot, distDir),\n            file\n          )\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[fileOutputPath] = originalPath\n        }\n        for (const file of page.files) {\n          handleFile(file)\n        }\n        for (const item of [...(page.assets || [])]) {\n          handleFile(item.filePath)\n        }\n        for (const item of page.wasm || []) {\n          if (!output.wasmAssets) {\n            output.wasmAssets = {}\n          }\n          output.wasmAssets[item.name] = path.join(distDir, item.filePath)\n        }\n\n        if (type === AdapterOutputType.MIDDLEWARE) {\n          ;(output as AdapterOutput['MIDDLEWARE']).config.matchers =\n            page.matchers.map((item) => {\n              return {\n                source: item.originalSource,\n                sourceRegex: item.regexp,\n                has: item.has,\n                missing: [\n                  ...(item.missing || []),\n                  // always skip middleware for on-demand revalidate\n                  {\n                    type: 'header',\n                    key: 'x-prerender-revalidate',\n                    value: prerenderManifest.preview.previewModeId,\n                  },\n                ],\n              }\n            })\n          output.pathname = '/_middleware'\n          output.id = page.name\n          outputs.middleware = output\n        } else {\n          currentOutputs.push(output)\n        }\n\n        // need to add matching .rsc output\n        if (isAppPage) {\n          const rscPathname =\n            (output.pathname === '/' ? '/index' : output.pathname) + '.rsc'\n          outputs.appPages.push({\n            ...output,\n            pathname: rscPathname,\n            id: page.name + '.rsc',\n          })\n        }\n      }\n\n      const edgeFunctionHandlers: Promise<any>[] = []\n\n      for (const middleware of Object.values(middlewareManifest.middleware)) {\n        if (isMiddlewareFilename(middleware.name)) {\n          edgeFunctionHandlers.push(handleEdgeFunction(middleware, true))\n        }\n      }\n\n      for (const page of Object.values(middlewareManifest.functions)) {\n        edgeFunctionHandlers.push(handleEdgeFunction(page))\n      }\n      const pagesDistDir = path.join(distDir, 'server', 'pages')\n      const pageOutputMap: Record<\n        string,\n        AdapterOutput['PAGES'] | AdapterOutput['PAGES_API']\n      > = {}\n\n      const rscFallbackPath = path.join(distDir, 'server', 'rsc-fallback.json')\n\n      if (appPageKeys && appPageKeys.length > 0 && pageKeys.length > 0) {\n        await fs.writeFile(rscFallbackPath, '{}')\n      }\n\n      for (const page of pageKeys) {\n        if (page === '/_app' || page === '/_document') {\n          continue\n        }\n\n        if (middlewareManifest.functions.hasOwnProperty(page)) {\n          continue\n        }\n\n        const route = normalizePagePath(page)\n        const pageFile = path.join(pagesDistDir, `${route}.js`)\n\n        // if it's an auto static optimized page it's just\n        // a static file\n        if (staticPages.has(page)) {\n          if (config.i18n) {\n            for (const locale of config.i18n.locales || []) {\n              const localePage =\n                page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n              const localeOutput = {\n                id: localePage,\n                pathname: localePage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: path.join(\n                  pagesDistDir,\n                  `${normalizePagePath(localePage)}.html`\n                ),\n              } satisfies AdapterOutput['STATIC_FILE']\n\n              outputs.staticFiles.push(localeOutput)\n\n              if (appPageKeys && appPageKeys.length > 0) {\n                outputs.staticFiles.push({\n                  id: `${localePage}.rsc`,\n                  pathname: `${localePage}.rsc`,\n                  type: AdapterOutputType.STATIC_FILE,\n                  filePath: rscFallbackPath,\n                })\n              }\n            }\n          } else {\n            const staticOutput = {\n              id: page,\n              pathname: route,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: pageFile.replace(/\\.js$/, '.html'),\n            } satisfies AdapterOutput['STATIC_FILE']\n\n            outputs.staticFiles.push(staticOutput)\n\n            if (appPageKeys && appPageKeys.length > 0) {\n              outputs.staticFiles.push({\n                id: `${page}.rsc`,\n                pathname: `${route}.rsc`,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n          }\n          // if was a static file output don't create page output as well\n          continue\n        }\n\n        const pageTraceFile = `${pageFile}.nft.json`\n        const assets = await handleTraceFiles(pageTraceFile, 'pages').catch(\n          (err) => {\n            if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n              Log.warn(`Failed to locate traced assets for ${pageFile}`, err)\n            }\n            return {} as Record<string, string>\n          }\n        )\n        const functionConfig = functionsConfigManifest.functions[route] || {}\n        let sourcePage = route.replace(/^\\//, '')\n\n        sourcePage = sourcePage === 'api' ? 'api/index' : sourcePage\n\n        const output: AdapterOutput['PAGES'] | AdapterOutput['PAGES_API'] = {\n          id: route,\n          type: page.startsWith('/api')\n            ? AdapterOutputType.PAGES_API\n            : AdapterOutputType.PAGES,\n          filePath: pageTraceFile.replace(/\\.nft\\.json$/, ''),\n          pathname: route,\n          sourcePage,\n          assets,\n          runtime: 'nodejs',\n          config: {\n            maxDuration: functionConfig.maxDuration,\n            preferredRegion: functionConfig.regions,\n          },\n        }\n        pageOutputMap[page] = output\n\n        if (output.type === AdapterOutputType.PAGES) {\n          outputs.pages.push(output)\n\n          // if page is get server side props we need to create\n          // the _next/data output as well\n          if (serverPropsPages.has(page)) {\n            const dataPathname = path.posix.join(\n              '/_next/data',\n              buildId,\n              page + '.json'\n            )\n            outputs.pages.push({\n              ...output,\n              pathname: dataPathname,\n              id: dataPathname,\n            })\n          }\n\n          for (const locale of config.i18n?.locales || []) {\n            const localePage =\n              page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n            outputs.pages.push({\n              ...output,\n              id: localePage,\n              pathname: localePage,\n            })\n\n            if (serverPropsPages.has(page)) {\n              const dataPathname = path.posix.join(\n                '/_next/data',\n                buildId,\n                localePage + '.json'\n              )\n              outputs.pages.push({\n                ...output,\n                pathname: dataPathname,\n                id: dataPathname,\n              })\n            }\n          }\n        } else {\n          outputs.pagesApi.push(output)\n        }\n\n        if (appPageKeys && appPageKeys.length > 0) {\n          outputs.staticFiles.push({\n            id: `${output.id}.rsc`,\n            pathname: `${output.pathname}.rsc`,\n            type: AdapterOutputType.STATIC_FILE,\n            filePath: rscFallbackPath,\n          })\n        }\n      }\n\n      if (hasNodeMiddleware) {\n        const middlewareFile = path.join(distDir, 'server', 'middleware.js')\n        const middlewareTrace = `${middlewareFile}.nft.json`\n        const assets = await handleTraceFiles(middlewareTrace, 'neutral')\n        const functionConfig =\n          functionsConfigManifest.functions['/_middleware'] || {}\n\n        outputs.middleware = {\n          pathname: '/_middleware',\n          id: '/_middleware',\n          sourcePage: 'middleware',\n          assets,\n          type: AdapterOutputType.MIDDLEWARE,\n          runtime: 'nodejs',\n          filePath: middlewareFile,\n          config: {\n            matchers:\n              functionConfig.matchers?.map((item) => {\n                return {\n                  source: item.originalSource,\n                  sourceRegex: item.regexp,\n                  has: item.has,\n                  missing: [\n                    ...(item.missing || []),\n                    // always skip middleware for on-demand revalidate\n                    {\n                      type: 'header',\n                      key: 'x-prerender-revalidate',\n                      value: prerenderManifest.preview.previewModeId,\n                    },\n                  ],\n                }\n              }) || [],\n          },\n        } satisfies AdapterOutput['MIDDLEWARE']\n      }\n      const appOutputMap: Record<\n        string,\n        AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE']\n      > = {}\n      const appDistDir = path.join(distDir, 'server', 'app')\n\n      if (appPageKeys) {\n        for (const page of appPageKeys) {\n          if (middlewareManifest.functions.hasOwnProperty(page)) {\n            continue\n          }\n          const normalizedPage = normalizeAppPath(page)\n          const pageFile = path.join(appDistDir, `${page}.js`)\n          const pageTraceFile = `${pageFile}.nft.json`\n          const assets = await handleTraceFiles(pageTraceFile, 'app').catch(\n            (err) => {\n              Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n              return {} as Record<string, string>\n            }\n          )\n          const functionConfig =\n            functionsConfigManifest.functions[normalizedPage] || {}\n\n          const output: AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE'] =\n            {\n              pathname: normalizedPage,\n              id: normalizedPage,\n              sourcePage: page,\n              assets,\n              type: page.endsWith('/route')\n                ? AdapterOutputType.APP_ROUTE\n                : AdapterOutputType.APP_PAGE,\n              runtime: 'nodejs',\n              filePath: pageFile,\n              config: {\n                maxDuration: functionConfig.maxDuration,\n                preferredRegion: functionConfig.regions,\n              },\n            }\n          appOutputMap[normalizedPage] = output\n\n          if (output.type === AdapterOutputType.APP_PAGE) {\n            outputs.appPages.push({\n              ...output,\n              pathname:\n                (output.pathname === '/' ? '/index' : output.pathname) + '.rsc',\n              id: (output.id === '/' ? '/index' : output.pathname) + '.rsc',\n            })\n            outputs.appPages.push(output)\n          } else {\n            outputs.appRoutes.push(output)\n          }\n        }\n      }\n\n      const getParentOutput = (\n        srcRoute: string,\n        childRoute: string,\n        allowMissing?: boolean\n      ) => {\n        const normalizedSrcRoute = normalizeLocalePath(\n          srcRoute,\n          config.i18n?.locales || []\n        ).pathname\n        const parentOutput =\n          pageOutputMap[normalizedSrcRoute] || appOutputMap[normalizedSrcRoute]\n\n        if (!parentOutput && !allowMissing) {\n          console.error({\n            appOutputs: Object.keys(appOutputMap),\n            pageOutputs: Object.keys(pageOutputMap),\n          })\n          throw new Error(\n            `Invariant: failed to find source route ${srcRoute} for prerender ${childRoute}`\n          )\n        }\n        return parentOutput\n      }\n\n      const {\n        prefetchSegmentDirSuffix,\n        prefetchSegmentSuffix,\n        varyHeader,\n        didPostponeHeader,\n        contentTypeHeader: rscContentTypeHeader,\n      } = routesManifest.rsc\n\n      const handleAppMeta = async (\n        route: string,\n        initialOutput: AdapterOutput['PRERENDER'],\n        meta: {\n          postponed?: string\n          segmentPaths?: string[]\n        }\n      ) => {\n        if (meta.postponed && initialOutput.fallback) {\n          initialOutput.fallback.postponedState = meta.postponed\n        }\n\n        if (meta?.segmentPaths) {\n          const segmentsDir = path.join(\n            appDistDir,\n            `${route}${prefetchSegmentDirSuffix}`\n          )\n\n          for (const segmentPath of meta.segmentPaths) {\n            const outputSegmentPath =\n              path.join(route + prefetchSegmentDirSuffix, segmentPath) +\n              prefetchSegmentSuffix\n\n            const fallbackPathname = path.join(\n              segmentsDir,\n              segmentPath + prefetchSegmentSuffix\n            )\n\n            outputs.prerenders.push({\n              id: outputSegmentPath,\n              pathname: outputSegmentPath,\n              type: AdapterOutputType.PRERENDER,\n              parentOutputId: initialOutput.parentOutputId,\n              groupId: initialOutput.groupId,\n\n              config: {\n                ...initialOutput.config,\n              },\n\n              fallback: {\n                filePath: fallbackPathname,\n                initialExpiration: initialOutput.fallback?.initialExpiration,\n                initialRevalidate: initialOutput.fallback?.initialRevalidate,\n\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  vary: varyHeader,\n                  'content-type': rscContentTypeHeader,\n                  [didPostponeHeader]: '2',\n                },\n              },\n            } satisfies AdapterOutput['PRERENDER'])\n          }\n        }\n      }\n\n      let prerenderGroupId = 1\n\n      type AppRouteMeta = {\n        segmentPaths?: string[]\n        postponed?: string\n        headers?: Record<string, string>\n        status?: number\n      }\n\n      const getAppRouteMeta = async (\n        route: string,\n        isAppPage: boolean\n      ): Promise<AppRouteMeta> => {\n        const meta: AppRouteMeta = isAppPage\n          ? JSON.parse(\n              await fs\n                .readFile(path.join(appDistDir, `${route}.meta`), 'utf8')\n                .catch(() => '{}')\n            )\n          : {}\n\n        if (meta.headers) {\n          // normalize these for consistency\n          for (const key of Object.keys(meta.headers)) {\n            const keyLower = key.toLowerCase()\n            if (keyLower !== key) {\n              const value = meta.headers[key]\n              delete meta.headers[key]\n              meta.headers[keyLower] = value\n            }\n          }\n        }\n\n        return meta\n      }\n\n      const filePathCache = new Map<string, Promise<boolean>>()\n      const cachedFilePathCheck = async (filePath: string) => {\n        if (filePathCache.has(filePath)) {\n          return filePathCache.get(filePath)\n        }\n        const newCheck = fs\n          .access(filePath)\n          .then(() => true)\n          .catch(() => false)\n        filePathCache.set(filePath, newCheck)\n\n        return newCheck\n      }\n\n      for (const route in prerenderManifest.routes) {\n        const {\n          initialExpireSeconds: initialExpiration,\n          initialRevalidateSeconds: initialRevalidate,\n          initialHeaders,\n          initialStatus,\n          prefetchDataRoute,\n          dataRoute,\n          renderingMode,\n          allowHeader,\n          experimentalBypassFor,\n        } = prerenderManifest.routes[route]\n\n        const srcRoute = prerenderManifest.routes[route].srcRoute || route\n        const srcRouteInfo = prerenderManifest.dynamicRoutes[srcRoute]\n\n        const isAppPage =\n          Boolean(appOutputMap[srcRoute]) || srcRoute === '/_not-found'\n\n        const isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route)\n\n        let allowQuery: string[] | undefined\n        const routeKeys = routesManifest.dynamicRoutes.find(\n          (item) => item.page === srcRoute\n        )?.routeKeys\n\n        if (!isDynamicRoute(srcRoute)) {\n          // for non-dynamic routes we use an empty array since\n          // no query values bust the cache for non-dynamic prerenders\n          // prerendered paths also do not pass allowQuery as they match\n          // during handle: 'filesystem' so should not cache differently\n          // by query values\n          allowQuery = []\n        } else if (routeKeys) {\n          // if we have routeKeys in the routes-manifest we use those\n          // for allowQuery for dynamic routes\n          allowQuery = Object.values(routeKeys)\n        }\n\n        let filePath = path.join(\n          isAppPage ? appDistDir : pagesDistDir,\n          `${route === '/' ? 'index' : route}.${isAppPage && !dataRoute ? 'body' : 'html'}`\n        )\n\n        // we use the static 404 for notFound: true if available\n        // if not we do a blocking invoke on first request\n        if (isNotFoundTrue && hasStatic404) {\n          const locale =\n            config.i18n &&\n            normalizeLocalePath(route, config.i18n?.locales).detectedLocale\n\n          for (const currentFilePath of [\n            path.join(pagesDistDir, locale || '', '404.html'),\n            path.join(pagesDistDir, '404.html'),\n          ]) {\n            if (await cachedFilePathCheck(currentFilePath)) {\n              filePath = currentFilePath\n              break\n            }\n          }\n        }\n\n        const meta = await getAppRouteMeta(route, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: route,\n          type: AdapterOutputType.PRERENDER,\n          pathname: route,\n          parentOutputId:\n            srcRoute === '/_not-found'\n              ? srcRoute\n              : getParentOutput(srcRoute, route).id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && config.experimental.ppr\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          parentFallbackMode: srcRouteInfo?.fallback,\n\n          fallback:\n            !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n              ? {\n                  filePath,\n                  initialStatus:\n                    (initialStatus ?? isNotFoundTrue) ? 404 : undefined,\n                  initialHeaders: {\n                    ...initialHeaders,\n                    vary: varyHeader,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration,\n                  initialRevalidate:\n                    typeof initialRevalidate === 'undefined'\n                      ? 1\n                      : initialRevalidate,\n                }\n              : undefined,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (dataRoute) {\n          let dataFilePath = path.join(\n            pagesDistDir,\n            `${route === '/' ? 'index' : route}.json`\n          )\n\n          if (isAppPage) {\n            // When experimental PPR is enabled, we expect that the data\n            // that should be served as a part of the prerender should\n            // be from the prefetch data route. If this isn't enabled\n            // for ppr, the only way to get the data is from the data\n            // route.\n            dataFilePath = path.join(\n              appDistDir,\n              prefetchDataRoute &&\n                renderingMode === RenderingMode.PARTIALLY_STATIC\n                ? prefetchDataRoute\n                : dataRoute\n            )\n          }\n\n          outputs.prerenders.push({\n            ...initialOutput,\n            id: dataRoute,\n            pathname: dataRoute,\n            fallback: isNotFoundTrue\n              ? undefined\n              : {\n                  ...initialOutput.fallback,\n                  initialHeaders: {\n                    ...initialOutput.fallback?.initialHeaders,\n                    'content-type': isAppPage\n                      ? rscContentTypeHeader\n                      : JSON_CONTENT_TYPE_HEADER,\n                  },\n                  filePath: dataFilePath,\n                },\n          })\n        }\n\n        if (isAppPage) {\n          await handleAppMeta(route, initialOutput, meta)\n        }\n        prerenderGroupId += 1\n      }\n\n      for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n        const {\n          fallback,\n          fallbackExpire,\n          fallbackRevalidate,\n          fallbackHeaders,\n          fallbackStatus,\n          allowHeader,\n          dataRoute,\n          renderingMode,\n          experimentalBypassFor,\n        } = prerenderManifest.dynamicRoutes[dynamicRoute]\n\n        const isAppPage = Boolean(appOutputMap[dynamicRoute])\n\n        const allowQuery = Object.values(\n          routesManifest.dynamicRoutes.find(\n            (item) => item.page === dynamicRoute\n          )?.routeKeys || {}\n        )\n        const meta = await getAppRouteMeta(dynamicRoute, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: dynamicRoute,\n          type: AdapterOutputType.PRERENDER,\n          pathname: dynamicRoute,\n          parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,\n          groupId: prerenderGroupId,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n          fallback:\n            typeof fallback === 'string'\n              ? {\n                  filePath: path.join(\n                    isAppPage ? appDistDir : pagesDistDir,\n                    // app router dynamic route fallbacks don't have the\n                    // extension so ensure it's added here\n                    fallback.endsWith('.html') ? fallback : `${fallback}.html`\n                  ),\n                  initialStatus: fallbackStatus,\n                  initialHeaders: {\n                    ...fallbackHeaders,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                  },\n                  initialExpiration: fallbackExpire,\n                  initialRevalidate: fallbackRevalidate || 1,\n                }\n              : undefined,\n        }\n\n        if (!config.i18n || isAppPage) {\n          outputs.prerenders.push(initialOutput)\n\n          if (isAppPage) {\n            await handleAppMeta(dynamicRoute, initialOutput, meta)\n          }\n\n          if (dataRoute) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: undefined,\n            })\n          }\n          prerenderGroupId += 1\n        } else {\n          for (const locale of config.i18n.locales) {\n            const currentOutput = {\n              ...initialOutput,\n              pathname: path.posix.join(`/${locale}`, initialOutput.pathname),\n              id: path.posix.join(`/${locale}`, initialOutput.id),\n              fallback:\n                typeof fallback === 'string'\n                  ? {\n                      ...initialOutput.fallback,\n                      filePath: path.join(\n                        pagesDistDir,\n                        locale,\n                        // app router dynamic route fallbacks don't have the\n                        // extension so ensure it's added here\n                        fallback.endsWith('.html')\n                          ? fallback\n                          : `${fallback}.html`\n                      ),\n                    }\n                  : undefined,\n              groupId: prerenderGroupId,\n            }\n            outputs.prerenders.push(currentOutput)\n\n            if (dataRoute) {\n              const dataPathname = path.posix.join(\n                `/_next/data`,\n                buildId,\n                locale,\n                dynamicRoute + '.json'\n              )\n              outputs.prerenders.push({\n                ...initialOutput,\n                id: dataPathname,\n                pathname: dataPathname,\n                // data route doesn't have skeleton fallback\n                fallback: undefined,\n                groupId: prerenderGroupId,\n              })\n            }\n            prerenderGroupId += 1\n          }\n        }\n      }\n\n      // ensure 404\n      const staticErrorDocs = [\n        ...(hasStatic404 ? ['/404'] : []),\n        ...(hasStatic500 ? ['/500'] : []),\n      ]\n\n      for (const errorDoc of staticErrorDocs) {\n        const errorDocPath = path.posix.join(\n          '/',\n          config.i18n?.defaultLocale || '',\n          errorDoc\n        )\n\n        if (!prerenderManifest.routes[errorDocPath]) {\n          for (const currentDocPath of [\n            errorDocPath,\n            ...(config.i18n?.locales?.map((locale) =>\n              path.posix.join('/', locale, errorDoc)\n            ) || []),\n          ]) {\n            const currentFilePath = path.join(\n              pagesDistDir,\n              `${currentDocPath}.html`\n            )\n            if (await cachedFilePathCheck(currentFilePath)) {\n              outputs.staticFiles.push({\n                pathname: currentDocPath,\n                id: currentDocPath,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: currentFilePath,\n              })\n            }\n          }\n        }\n      }\n    }\n\n    normalizePathnames(config, outputs)\n\n    const dynamicRoutes: DynamicRouteItem[] = []\n    const dynamicDataRoutes: DynamicRouteItem[] = []\n    const dynamicSegmentRoutes: DynamicRouteItem[] = []\n\n    const getDestinationQuery = (routeKeys: Record<string, string>) => {\n      const items = Object.entries(routeKeys ?? {})\n      if (items.length === 0) return ''\n\n      return '?' + items.map(([key, value]) => `${value}=$${key}`).join('&')\n    }\n\n    const fallbackFalseHasCondition: RouteHas[] = [\n      {\n        type: 'cookie',\n        key: '__prerender_bypass',\n        value: prerenderManifest.preview.previewModeId,\n      },\n      {\n        type: 'cookie',\n        key: '__next_preview_data',\n      },\n    ]\n\n    for (const route of routesManifest.dynamicRoutes) {\n      const shouldLocalize = config.i18n\n\n      const routeRegex = getNamedRouteRegex(route.page, {\n        prefixRouteKeys: true,\n      })\n\n      const isFallbackFalse =\n        prerenderManifest.dynamicRoutes[route.page]?.fallback === false\n\n      const { hasFallbackRootParams } = route\n\n      const sourceRegex = routeRegex.namedRegex.replace(\n        '^',\n        `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})?' : ''}`\n      )\n      const destination =\n        path.posix.join(\n          '/',\n          config.basePath,\n          shouldLocalize ? '/$nextLocale' : '',\n          route.page\n        ) + getDestinationQuery(route.routeKeys)\n\n      if (\n        appPageKeys &&\n        appPageKeys.length > 0 &&\n        (config.experimental.cacheComponents ||\n          config.experimental.clientSegmentCache)\n      ) {\n        // If we have fallback root params (implying we've already\n        // emitted a rewrite for the /_tree request), or if the route\n        // has PPR enabled and client param parsing is enabled, then\n        // we don't need to include any other suffixes.\n        const shouldSkipSuffixes = hasFallbackRootParams\n\n        dynamicRoutes.push({\n          source: route.page + '.rsc',\n          sourceRegex: sourceRegex.replace(\n            new RegExp(escapeStringRegexp('(?:/)?$')),\n            // Now than the upstream issues has been resolved, we can safely\n            // add the suffix back, this resolves a bug related to segment\n            // rewrites not capturing the correct suffix values when\n            // enabled.\n            shouldSkipSuffixes\n              ? '(?<rscSuffix>\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n              : '(?<rscSuffix>\\\\.rsc|\\\\.prefetch\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n          ),\n          destination: destination?.replace(/($|\\?)/, '$rscSuffix$1'),\n          has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n          missing: undefined,\n        })\n      }\n\n      // needs basePath and locale handling if pages router\n      dynamicRoutes.push({\n        source: route.page,\n        sourceRegex,\n        destination,\n        has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n        missing: undefined,\n      })\n\n      for (const segmentRoute of route.prefetchSegmentDataRoutes || []) {\n        dynamicSegmentRoutes.push({\n          source: route.page,\n          sourceRegex: segmentRoute.source.replace(\n            '^',\n            `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?`\n          ),\n          destination: path.posix.join(\n            '/',\n            config.basePath,\n            segmentRoute.destination +\n              getDestinationQuery(segmentRoute.routeKeys)\n          ),\n          has: undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const needsMiddlewareResolveRoutes =\n      outputs.middleware && outputs.pages.length > 0\n\n    const dataRoutePages = new Set([\n      ...routesManifest.dataRoutes.map((item) => item.page),\n    ])\n    const sortedDataPages = sortSortableRoutes([\n      ...(needsMiddlewareResolveRoutes\n        ? [...staticPages].map((page) => ({ sourcePage: page, page }))\n        : []),\n      ...routesManifest.dataRoutes.map((item) => ({\n        sourcePage: item.page,\n        page: item.page,\n      })),\n    ])\n\n    for (const { page } of sortedDataPages) {\n      if (needsMiddlewareResolveRoutes || isDynamicRoute(page)) {\n        const shouldLocalize = config.i18n\n        const isFallbackFalse =\n          prerenderManifest.dynamicRoutes[page]?.fallback === false\n\n        const routeRegex = getNamedRouteRegex(page + '.json', {\n          prefixRouteKeys: true,\n          includeSuffix: true,\n        })\n        const destination = path.posix.join(\n          '/',\n          config.basePath,\n          ...(dataRoutePages.has(page) ? [`_next/data`, buildId] : ''),\n          ...(page === '/'\n            ? [shouldLocalize ? '$nextLocale.json' : 'index.json']\n            : [\n                shouldLocalize ? '$nextLocale' : '',\n                page +\n                  '.json' +\n                  getDestinationQuery(routeRegex.routeKeys || {}),\n              ])\n        )\n\n        dynamicDataRoutes.push({\n          source: page,\n          sourceRegex:\n            shouldLocalize && page === '/'\n              ? '^' +\n                path.posix.join(\n                  '/',\n                  config.basePath,\n                  '_next/data',\n                  escapeStringRegexp(buildId),\n                  '(?<nextLocale>[^/]{1,}).json'\n                )\n              : routeRegex.namedRegex.replace(\n                  '^',\n                  `^${path.posix.join(\n                    '/',\n                    config.basePath,\n                    `_next/data`,\n                    escapeStringRegexp(buildId)\n                  )}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})?' : ''}`\n                ),\n          destination,\n          has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const buildRewriteItem = (route: ManifestRewriteRoute): RewriteItem => {\n      const converted = convertRewrites([route], ['nextInternalLocale'])[0]\n      const regex = converted.src || route.regex\n\n      return {\n        source: route.source,\n        sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n        destination: converted.dest || route.destination,\n        has: route.has,\n        missing: route.missing,\n      }\n    }\n\n    try {\n      Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n      await adapterMod.onBuildComplete({\n        routes: {\n          dynamicRoutes: [\n            ...dynamicDataRoutes,\n            ...dynamicSegmentRoutes,\n            ...dynamicRoutes,\n          ],\n          rewrites: {\n            beforeFiles:\n              routesManifest.rewrites.beforeFiles.map(buildRewriteItem),\n            afterFiles:\n              routesManifest.rewrites.afterFiles.map(buildRewriteItem),\n            fallback: routesManifest.rewrites.fallback.map(buildRewriteItem),\n          },\n          redirects: routesManifest.redirects.map((route) => {\n            const converted = convertRedirects([route], 307)[0]\n            let dest = 'headers' in converted && converted.headers?.Location\n            const regex = converted.src || route.regex\n\n            return {\n              source: route.source,\n              sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n              destination: dest || route.destination,\n              statusCode: converted.status || getRedirectStatus(route),\n              has: route.has,\n              missing: route.missing,\n              priority: route.internal || undefined,\n            }\n          }),\n          headers: routesManifest.headers.map((route) => {\n            const converted = convertHeaders([route])[0]\n            const regex = converted.src || route.regex\n\n            return {\n              source: route.source,\n              sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n              headers: 'headers' in converted ? converted.headers || {} : {},\n              has: route.has,\n              missing: route.missing,\n              priority: route.internal || undefined,\n            }\n          }),\n        },\n        outputs,\n\n        config,\n        distDir,\n        buildId,\n        nextVersion,\n        projectDir: dir,\n        repoRoot: tracingRoot,\n      })\n    } catch (err) {\n      Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)\n      throw err\n    }\n  }\n}\n"],"names":["path","fs","pathToFileURL","Log","isMiddlewareFilename","RenderingMode","interopDefault","recursiveReadDir","isDynamicRoute","normalizeAppPath","AdapterOutputType","normalizePagePath","convertRedirects","convertRewrites","convertHeaders","HTML_CONTENT_TYPE_HEADER","JSON_CONTENT_TYPE_HEADER","NEXT_RESUME_HEADER","normalizeLocalePath","addPathPrefix","getRedirectStatus","modifyRouteRegex","getNamedRouteRegex","escapeStringRegexp","sortSortableRoutes","nodeFileTrace","defaultOverrides","makeIgnoreFn","normalizePathnames","config","outputs","basePath","output","pages","pagesApi","appPages","appRoutes","prerenders","staticFiles","pathname","replace","handleBuildComplete","dir","buildId","configOutDir","distDir","pageKeys","tracingRoot","adapterPath","appPageKeys","staticPages","nextVersion","hasStatic404","hasStatic500","routesManifest","serverPropsPages","hasNodeMiddleware","prerenderManifest","middlewareManifest","requiredServerFiles","hasInstrumentationHook","functionsConfigManifest","adapterMod","require","resolve","href","onBuildComplete","exportFiles","file","endsWith","startsWith","push","id","filePath","join","type","STATIC_FILE","posix","sharedNodeAssets","pagesSharedNodeAssets","appPagesSharedNodeAssets","sharedTraceIgnores","sharedIgnoreFn","fileOutputPath","relative","moduleTypes","currentDependencies","modulePath","contextDir","dirname","item","readdir","match","fileList","esmFileList","base","ignore","forEach","add","rootRelativeFilePath","necessaryNodeDependencies","Object","values","filter","extname","assets","handleTraceFiles","assign","traceFilePath","traceData","JSON","parse","readFile","traceFileDir","relativeFile","files","tracedFilePath","handleEdgeFunction","page","isMiddleware","PAGES","isAppPrefix","name","isAppPage","isAppRoute","currentOutputs","MIDDLEWARE","APP_PAGE","APP_ROUTE","PAGES_API","route","runtime","sourcePage","find","wasmAssets","env","handleFile","originalPath","wasm","matchers","map","source","originalSource","sourceRegex","regexp","has","missing","key","value","preview","previewModeId","middleware","rscPathname","edgeFunctionHandlers","functions","pagesDistDir","pageOutputMap","rscFallbackPath","length","writeFile","hasOwnProperty","pageFile","i18n","locale","locales","localePage","localeOutput","staticOutput","pageTraceFile","catch","err","code","warn","functionConfig","maxDuration","preferredRegion","regions","dataPathname","middlewareFile","middlewareTrace","appOutputMap","appDistDir","normalizedPage","getParentOutput","srcRoute","childRoute","allowMissing","normalizedSrcRoute","parentOutput","console","error","appOutputs","keys","pageOutputs","Error","prefetchSegmentDirSuffix","prefetchSegmentSuffix","varyHeader","didPostponeHeader","contentTypeHeader","rscContentTypeHeader","rsc","handleAppMeta","initialOutput","meta","postponed","fallback","postponedState","segmentPaths","segmentsDir","segmentPath","outputSegmentPath","fallbackPathname","PRERENDER","parentOutputId","groupId","initialExpiration","initialRevalidate","initialHeaders","vary","prerenderGroupId","getAppRouteMeta","headers","keyLower","toLowerCase","filePathCache","Map","cachedFilePathCheck","get","newCheck","access","then","set","routes","initialExpireSeconds","initialRevalidateSeconds","initialStatus","prefetchDataRoute","dataRoute","renderingMode","allowHeader","experimentalBypassFor","srcRouteInfo","dynamicRoutes","Boolean","isNotFoundTrue","notFoundRoutes","includes","allowQuery","routeKeys","detectedLocale","currentFilePath","pprChain","experimental","ppr","undefined","parentFallbackMode","bypassFor","bypassToken","dataFilePath","PARTIALLY_STATIC","dynamicRoute","fallbackExpire","fallbackRevalidate","fallbackHeaders","fallbackStatus","currentOutput","staticErrorDocs","errorDoc","errorDocPath","defaultLocale","currentDocPath","dynamicDataRoutes","dynamicSegmentRoutes","getDestinationQuery","items","entries","fallbackFalseHasCondition","shouldLocalize","routeRegex","prefixRouteKeys","isFallbackFalse","hasFallbackRootParams","namedRegex","destination","cacheComponents","clientSegmentCache","shouldSkipSuffixes","RegExp","segmentRoute","prefetchSegmentDataRoutes","needsMiddlewareResolveRoutes","dataRoutePages","Set","dataRoutes","sortedDataPages","includeSuffix","buildRewriteItem","converted","regex","src","internal","dest","info","rewrites","beforeFiles","afterFiles","redirects","Location","statusCode","status","priority","projectDir","repoRoot"],"mappings":"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","ignoreList":[0]}