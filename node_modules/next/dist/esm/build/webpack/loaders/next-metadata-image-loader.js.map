{"version":3,"sources":["../../../../src/build/webpack/loaders/next-metadata-image-loader.ts"],"sourcesContent":["/*\n * This loader is responsible for extracting the metadata image info for rendering in html\n */\n\nimport type webpack from 'webpack'\nimport type {\n  MetadataImageModule,\n  PossibleImageFileNameConvention,\n} from './metadata/types'\nimport { existsSync, promises as fs } from 'fs'\nimport path from 'path'\nimport loaderUtils from 'next/dist/compiled/loader-utils3'\nimport { getImageSize } from '../../../server/image-optimizer'\nimport { imageExtMimeTypeMap } from '../../../lib/mime-type'\nimport { WEBPACK_RESOURCE_QUERIES } from '../../../lib/constants'\nimport { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep'\nimport type { PageExtensions } from '../../page-extensions-type'\nimport { getLoaderModuleNamedExports } from './utils'\n\ninterface Options {\n  segment: string\n  type: PossibleImageFileNameConvention\n  pageExtensions: PageExtensions\n  basePath: string\n}\n\n// [NOTE] For turbopack, refer to app_page_loader_tree's write_metadata_item for\n// corresponding features.\nasync function nextMetadataImageLoader(\n  this: webpack.LoaderContext<Options>,\n  content: Buffer\n) {\n  const options: Options = this.getOptions()\n  const { type, segment, pageExtensions, basePath } = options\n  const { resourcePath, rootContext: context } = this\n  const { name: fileNameBase, ext } = path.parse(resourcePath)\n  const useNumericSizes = type === 'twitter' || type === 'openGraph'\n\n  let extension = ext.slice(1)\n  if (extension === 'jpg') {\n    extension = 'jpeg'\n  }\n\n  const opts = { context, content }\n\n  const contentHash = loaderUtils.interpolateName(this, '[contenthash]', opts)\n\n  const interpolatedName = loaderUtils.interpolateName(\n    this,\n    '[name].[ext]',\n    opts\n  )\n\n  const isDynamicResource = pageExtensions.includes(extension)\n  const pageSegment = isDynamicResource ? fileNameBase : interpolatedName\n  const hashQuery = contentHash ? '?' + contentHash : ''\n  const pathnamePrefix = normalizePathSep(path.join(basePath, segment))\n\n  if (isDynamicResource) {\n    const exportedFieldsExcludingDefault = (\n      await getLoaderModuleNamedExports(resourcePath, this)\n    ).filter((name) => name !== 'default')\n\n    // re-export and spread as `exportedImageData` to avoid non-exported error\n    return `\\\n    import {\n      ${exportedFieldsExcludingDefault\n        .map((field) => `${field} as _${field}`)\n        .join(',')}\n    } from ${JSON.stringify(\n      // This is an arbitrary resource query to ensure it's a new request, instead\n      // of sharing the same module with next-metadata-route-loader.\n      // Since here we only need export fields such as `size`, `alt` and\n      // `generateImageMetadata`, avoid sharing the same module can make this entry\n      // smaller.\n      resourcePath + '?' + WEBPACK_RESOURCE_QUERIES.metadataImageMeta\n    )}\n    import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n    const imageModule = {\n      ${exportedFieldsExcludingDefault\n        .map((field) => `${field}: _${field}`)\n        .join(',')}\n    }\n\n    function getImageMetadata(imageMetadata, idParam, resolvedParams) {\n      const imageUrl = fillMetadataSegment(${JSON.stringify(\n        pathnamePrefix\n      )}, resolvedParams, ${JSON.stringify(pageSegment)})\n      const data = {\n        alt: imageMetadata.alt,\n        type: imageMetadata.contentType || 'image/png',\n      url: imageUrl + (idParam ? ('/' + idParam) : '') + ${JSON.stringify(\n        hashQuery\n      )},\n      }\n      const { size } = imageMetadata\n      if (size) {\n        ${\n          type === 'twitter' || type === 'openGraph'\n            ? 'data.width = size.width; data.height = size.height;'\n            : 'data.sizes = size.width + \"x\" + size.height;'\n        }\n      }\n      return data\n    }\n\n    export default async function (props) {\n      const { generateImageMetadata } = imageModule\n      const resolvedParams = await props.params\n\n      if (generateImageMetadata) {\n        const imageMetadataArray = await generateImageMetadata({ params: resolvedParams })\n        return imageMetadataArray.map((imageMetadata, index) => {\n          const idParam = imageMetadata.id + ''\n          return getImageMetadata(imageMetadata, idParam, resolvedParams)\n        })\n      } else {\n        return [getImageMetadata(imageModule, '', resolvedParams)]\n      }\n    }`\n  }\n\n  let imageError\n  const imageSize: { width?: number; height?: number } = await getImageSize(\n    content\n  ).catch((error) => {\n    const message = `Process image \"${path.posix.join(segment || '/', interpolatedName)}\" failed: ${error}`\n    imageError = new Error(message)\n    return {}\n  })\n\n  if (imageError) {\n    throw imageError\n  }\n\n  const imageData: Omit<MetadataImageModule, 'url'> = {\n    ...(extension in imageExtMimeTypeMap && {\n      type: imageExtMimeTypeMap[extension as keyof typeof imageExtMimeTypeMap],\n    }),\n    ...(useNumericSizes && imageSize.width != null && imageSize.height != null\n      ? imageSize\n      : {\n          sizes:\n            // For SVGs, skip sizes and use \"any\" to let it scale automatically based on viewport,\n            // For the images doesn't provide the size properly, use \"any\" as well.\n            // If the size is presented, use the actual size for the image.\n            extension !== 'svg' &&\n            imageSize.width != null &&\n            imageSize.height != null\n              ? `${imageSize.width}x${imageSize.height}`\n              : 'any',\n        }),\n  }\n  if (type === 'openGraph' || type === 'twitter') {\n    const altPath = path.join(\n      path.dirname(resourcePath),\n      fileNameBase + '.alt.txt'\n    )\n\n    if (existsSync(altPath)) {\n      imageData.alt = await fs.readFile(altPath, 'utf8')\n    }\n  }\n\n  return `\\\n  import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n  export default async (props) => {\n    const imageData = ${JSON.stringify(imageData)}\n    const imageUrl = fillMetadataSegment(${JSON.stringify(\n      pathnamePrefix\n    )}, await props.params, ${JSON.stringify(pageSegment)})\n\n    return [{\n      ...imageData,\n      url: imageUrl + ${JSON.stringify(hashQuery)},\n    }]\n  }`\n}\n\nexport const raw = true\nexport default nextMetadataImageLoader\n"],"names":["existsSync","promises","fs","path","loaderUtils","getImageSize","imageExtMimeTypeMap","WEBPACK_RESOURCE_QUERIES","normalizePathSep","getLoaderModuleNamedExports","nextMetadataImageLoader","content","options","getOptions","type","segment","pageExtensions","basePath","resourcePath","rootContext","context","name","fileNameBase","ext","parse","useNumericSizes","extension","slice","opts","contentHash","interpolateName","interpolatedName","isDynamicResource","includes","pageSegment","hashQuery","pathnamePrefix","join","exportedFieldsExcludingDefault","filter","map","field","JSON","stringify","metadataImageMeta","imageError","imageSize","catch","error","message","posix","Error","imageData","width","height","sizes","altPath","dirname","alt","readFile","raw"],"mappings":"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","ignoreList":[0]}