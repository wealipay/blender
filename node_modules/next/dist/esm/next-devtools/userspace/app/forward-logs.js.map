{"version":3,"sources":["../../../../src/next-devtools/userspace/app/forward-logs.ts"],"sourcesContent":["import {\n  getOwnerStack,\n  setOwnerStackIfAvailable,\n} from './errors/stitched-error'\nimport { getErrorSource } from '../../../shared/lib/error-source'\nimport { getIsTerminalLoggingEnabled } from './terminal-logging-config'\nimport {\n  type ConsoleEntry,\n  type ConsoleErrorEntry,\n  type FormattedErrorEntry,\n  type ClientLogEntry,\n  type LogMethod,\n  patchConsoleMethod,\n} from '../../shared/forward-logs-shared'\nimport {\n  preLogSerializationClone,\n  logStringify,\n  safeStringifyWithDepth,\n} from './forward-logs-utils'\n\n// Client-side file logger for browser logs\nclass ClientFileLogger {\n  private logEntries: Array<{\n    timestamp: string\n    level: string // log level\n    message: string // log message\n  }> = []\n\n  private formatTimestamp(): string {\n    const now = new Date()\n    const hours = now.getHours().toString().padStart(2, '0')\n    const minutes = now.getMinutes().toString().padStart(2, '0')\n    const seconds = now.getSeconds().toString().padStart(2, '0')\n    const milliseconds = now.getMilliseconds().toString().padStart(3, '0')\n\n    return `${hours}:${minutes}:${seconds}.${milliseconds}`\n  }\n\n  log(level: string, args: any[]): void {\n    if (isReactServerReplayedLog(args)) {\n      return\n    }\n\n    // Format the args into a message string\n    const message = args\n      .map((arg) => {\n        if (typeof arg === 'string') return arg\n        if (typeof arg === 'number' || typeof arg === 'boolean')\n          return String(arg)\n        if (arg === null) return 'null'\n        if (arg === undefined) return 'undefined'\n        // Handle DOM nodes - only log the tag name to avoid React proxied elements\n        if (arg instanceof Element) {\n          return `<${arg.tagName.toLowerCase()}>`\n        }\n        return safeStringifyWithDepth(arg)\n      })\n      .join(' ')\n\n    const logEntry = {\n      timestamp: this.formatTimestamp(),\n      level: level.toUpperCase(),\n      message,\n    }\n    this.logEntries.push(logEntry)\n\n    // Schedule flush when new log is added\n    scheduleLogFlush()\n  }\n  getLogs(): Array<{ timestamp: string; level: string; message: string }> {\n    return [...this.logEntries]\n  }\n\n  clear(): void {\n    this.logEntries = []\n  }\n}\n\nconst clientFileLogger = new ClientFileLogger()\n\n// Set up flush-based sending of client file logs\nlet logFlushTimeout: NodeJS.Timeout | null = null\nlet heartbeatInterval: NodeJS.Timeout | null = null\n\nconst scheduleLogFlush = () => {\n  if (logFlushTimeout) {\n    clearTimeout(logFlushTimeout)\n  }\n\n  logFlushTimeout = setTimeout(() => {\n    sendClientFileLogs()\n    logFlushTimeout = null\n  }, 100) // Send after 100ms (much faster with debouncing)\n}\n\nconst cancelLogFlush = () => {\n  if (logFlushTimeout) {\n    clearTimeout(logFlushTimeout)\n    logFlushTimeout = null\n  }\n}\n\nconst startHeartbeat = () => {\n  if (heartbeatInterval) return\n\n  heartbeatInterval = setInterval(() => {\n    if (logQueue.socket && logQueue.socket.readyState === WebSocket.OPEN) {\n      try {\n        // Send a ping to keep the connection alive\n        logQueue.socket.send(JSON.stringify({ event: 'ping' }))\n      } catch (error) {\n        // Connection might be closed, stop heartbeat\n        stopHeartbeat()\n      }\n    } else {\n      stopHeartbeat()\n    }\n  }, 5000) // Send ping every 5 seconds\n}\n\nconst stopHeartbeat = () => {\n  if (heartbeatInterval) {\n    clearInterval(heartbeatInterval)\n    heartbeatInterval = null\n  }\n}\n\nconst isTerminalLoggingEnabled = getIsTerminalLoggingEnabled()\n\nconst methods: Array<LogMethod> = [\n  'log',\n  'info',\n  'warn',\n  'debug',\n  'table',\n  'assert',\n  'dir',\n  'dirxml',\n  'group',\n  'groupCollapsed',\n  'groupEnd',\n  'trace',\n]\n\nconst afterThisFrame = (cb: () => void) => {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const rafId = requestAnimationFrame(() => {\n    timeout = setTimeout(() => {\n      cb()\n    })\n  })\n\n  return () => {\n    cancelAnimationFrame(rafId)\n    clearTimeout(timeout)\n  }\n}\n\nlet isPatched = false\n\nconst serializeEntries = (entries: Array<ClientLogEntry>) =>\n  entries.map((clientEntry) => {\n    switch (clientEntry.kind) {\n      case 'any-logged-error':\n      case 'console': {\n        return {\n          ...clientEntry,\n          args: clientEntry.args.map(stringifyUserArg),\n        }\n      }\n      case 'formatted-error': {\n        return clientEntry\n      }\n      default: {\n        return null!\n      }\n    }\n  })\n\n// Function to send client file logs to server\nconst sendClientFileLogs = () => {\n  if (!logQueue.socket || logQueue.socket.readyState !== WebSocket.OPEN) {\n    return\n  }\n\n  const logs = clientFileLogger.getLogs()\n  if (logs.length === 0) {\n    return\n  }\n\n  try {\n    const payload = JSON.stringify({\n      event: 'client-file-logs',\n      logs: logs,\n    })\n\n    logQueue.socket.send(payload)\n  } catch (error) {\n    console.error(error)\n  } finally {\n    // Clear logs regardless of send success to prevent memory leaks\n    clientFileLogger.clear()\n  }\n}\n\n// Combined state and public API\nexport const logQueue: {\n  entries: Array<ClientLogEntry>\n  onSocketReady: (socket: WebSocket) => void\n  flushScheduled: boolean\n  socket: WebSocket | null\n  cancelFlush: (() => void) | null\n  sourceType?: 'server' | 'edge-server'\n  router: 'app' | 'pages' | null\n  scheduleLogSend: (entry: ClientLogEntry) => void\n} = {\n  entries: [],\n  flushScheduled: false,\n  cancelFlush: null,\n  socket: null,\n  sourceType: undefined,\n  router: null,\n  scheduleLogSend: (entry: ClientLogEntry) => {\n    logQueue.entries.push(entry)\n    if (logQueue.flushScheduled) {\n      return\n    }\n    // safe to deref and use in setTimeout closure since we cancel on new socket\n    const socket = logQueue.socket\n    if (!socket) {\n      return\n    }\n\n    // we probably dont need this\n    logQueue.flushScheduled = true\n\n    // non blocking log flush, runs at most once per frame\n    logQueue.cancelFlush = afterThisFrame(() => {\n      logQueue.flushScheduled = false\n\n      // just incase\n      try {\n        const payload = JSON.stringify({\n          event: 'browser-logs',\n          entries: serializeEntries(logQueue.entries),\n          router: logQueue.router,\n          // needed for source mapping, we just assign the sourceType from the last error for the whole batch\n          sourceType: logQueue.sourceType,\n        })\n\n        socket.send(payload)\n        logQueue.entries = []\n        logQueue.sourceType = undefined\n\n        // Also send client file logs\n        sendClientFileLogs()\n      } catch {\n        // error (make sure u don't infinite loop)\n        /* noop */\n      }\n    })\n  },\n  onSocketReady: (socket: WebSocket) => {\n    // When MCP or terminal logging is enabled, we enable the socket connection,\n    // otherwise it will not proceed.\n    if (!isTerminalLoggingEnabled && !process.env.__NEXT_MCP_SERVER) {\n      return\n    }\n    if (socket.readyState !== WebSocket.OPEN) {\n      // invariant\n      return\n    }\n\n    // incase an existing timeout was going to run with a stale socket\n    logQueue.cancelFlush?.()\n    logQueue.socket = socket\n\n    // Add socket event listeners to track connection state\n    socket.addEventListener('close', () => {\n      cancelLogFlush()\n      stopHeartbeat()\n    })\n\n    // Only send terminal logs if enabled\n    if (isTerminalLoggingEnabled) {\n      try {\n        const payload = JSON.stringify({\n          event: 'browser-logs',\n          entries: serializeEntries(logQueue.entries),\n          router: logQueue.router,\n          sourceType: logQueue.sourceType,\n        })\n\n        socket.send(payload)\n        logQueue.entries = []\n        logQueue.sourceType = undefined\n      } catch {\n        /** noop just incase */\n      }\n    }\n\n    // Always send client file logs when socket is ready\n    sendClientFileLogs()\n\n    // Start heartbeat to keep connection alive\n    startHeartbeat()\n  },\n}\n\nconst stringifyUserArg = (\n  arg:\n    | {\n        kind: 'arg'\n        data: unknown\n      }\n    | {\n        kind: 'formatted-error-arg'\n      }\n) => {\n  if (arg.kind !== 'arg') {\n    return arg\n  }\n  return {\n    ...arg,\n    data: logStringify(arg.data),\n  }\n}\n\nconst createErrorArg = (error: Error) => {\n  const stack = stackWithOwners(error)\n  return {\n    kind: 'formatted-error-arg' as const,\n    prefix: error.message ? `${error.name}: ${error.message}` : `${error.name}`,\n    stack,\n  }\n}\n\nconst createLogEntry = (level: LogMethod, args: any[]) => {\n  // Always log to client file logger with args (formatting done inside log method)\n  clientFileLogger.log(level, args)\n\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  // do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers\n  // error capture stack trace maybe\n  const stack = stackWithOwners(new Error())\n  const stackLines = stack?.split('\\n')\n  const cleanStack = stackLines?.slice(3).join('\\n') // this is probably ignored anyways\n  const entry: ConsoleEntry<unknown> = {\n    kind: 'console',\n    consoleMethodStack: cleanStack ?? null, // depending on browser we might not have stack\n    method: level,\n    args: args.map((arg) => {\n      if (arg instanceof Error) {\n        return createErrorArg(arg)\n      }\n      return {\n        kind: 'arg',\n        data: preLogSerializationClone(arg),\n      }\n    }),\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nexport const forwardErrorLog = (args: any[]) => {\n  // Always log to client file logger with args (formatting done inside log method)\n  clientFileLogger.log('error', args)\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  const errorObjects = args.filter((arg) => arg instanceof Error)\n  const first = errorObjects.at(0)\n  if (first) {\n    const source = getErrorSource(first)\n    if (source) {\n      logQueue.sourceType = source\n    }\n  }\n  /**\n   * browser shows stack regardless of type of data passed to console.error, so we should do the same\n   *\n   * do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers\n   */\n  const stack = stackWithOwners(new Error())\n  const stackLines = stack?.split('\\n')\n  const cleanStack = stackLines?.slice(3).join('\\n')\n\n  const entry: ConsoleErrorEntry<unknown> = {\n    kind: 'any-logged-error',\n    method: 'error',\n    consoleErrorStack: cleanStack ?? '',\n    args: args.map((arg) => {\n      if (arg instanceof Error) {\n        return createErrorArg(arg)\n      }\n      return {\n        kind: 'arg',\n        data: preLogSerializationClone(arg),\n      }\n    }),\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst createUncaughtErrorEntry = (\n  errorName: string,\n  errorMessage: string,\n  fullStack: string\n) => {\n  const entry: FormattedErrorEntry = {\n    kind: 'formatted-error',\n    prefix: `Uncaught ${errorName}: ${errorMessage}`,\n    stack: fullStack,\n    method: 'error',\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst stackWithOwners = (error: Error) => {\n  let ownerStack = ''\n  setOwnerStackIfAvailable(error)\n  ownerStack = getOwnerStack(error) || ''\n  const stack = (error.stack || '') + ownerStack\n  return stack\n}\n\nexport function logUnhandledRejection(reason: unknown) {\n  // Always log to client file logger\n  const message =\n    reason instanceof Error\n      ? `${reason.name}: ${reason.message}`\n      : JSON.stringify(reason)\n  clientFileLogger.log('error', [`unhandledRejection: ${message}`])\n\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  if (reason instanceof Error) {\n    createUnhandledRejectionErrorEntry(reason, stackWithOwners(reason))\n    return\n  }\n  createUnhandledRejectionNonErrorEntry(reason)\n}\n\nconst createUnhandledRejectionErrorEntry = (\n  error: Error,\n  fullStack: string\n) => {\n  const source = getErrorSource(error)\n  if (source) {\n    logQueue.sourceType = source\n  }\n\n  const entry: ClientLogEntry = {\n    kind: 'formatted-error',\n    prefix: `⨯ unhandledRejection: ${error.name}: ${error.message}`,\n    stack: fullStack,\n    method: 'error',\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst createUnhandledRejectionNonErrorEntry = (reason: unknown) => {\n  const entry: ClientLogEntry = {\n    kind: 'any-logged-error',\n    // we can't access the stack since the event is dispatched async and creating an inline error would be meaningless\n    consoleErrorStack: '',\n    method: 'error',\n    args: [\n      {\n        kind: 'arg',\n        data: `⨯ unhandledRejection:`,\n        isRejectionMessage: true,\n      },\n      {\n        kind: 'arg',\n        data: preLogSerializationClone(reason),\n      },\n    ],\n  }\n\n  logQueue.scheduleLogSend(entry)\n}\n\nconst isHMR = (args: any[]) => {\n  const firstArg = args[0]\n  if (typeof firstArg !== 'string') {\n    return false\n  }\n  if (firstArg.startsWith('[Fast Refresh]')) {\n    return true\n  }\n\n  if (firstArg.startsWith('[HMR]')) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Matches the format of logs arguments React replayed from the RSC.\n */\nconst isReactServerReplayedLog = (args: any[]) => {\n  if (args.length < 3) {\n    return false\n  }\n\n  const [format, styles, label] = args\n\n  if (\n    typeof format !== 'string' ||\n    typeof styles !== 'string' ||\n    typeof label !== 'string'\n  ) {\n    return false\n  }\n\n  return format.startsWith('%c%s%c') && styles.includes('background:')\n}\n\nexport function forwardUnhandledError(error: Error) {\n  // Always log to client file logger\n  clientFileLogger.log('error', [\n    `uncaughtError: ${error.name}: ${error.message}`,\n  ])\n\n  // Only forward to terminal if enabled\n  if (!isTerminalLoggingEnabled) {\n    return\n  }\n\n  createUncaughtErrorEntry(error.name, error.message, stackWithOwners(error))\n}\n\n// TODO: this router check is brittle, we need to update based on the current router the user is using\nexport const initializeDebugLogForwarding = (router: 'app' | 'pages'): void => {\n  // probably don't need this\n  if (isPatched) {\n    return\n  }\n  // TODO(rob): why does this break rendering on server, important to know incase the same bug appears in browser\n  if (typeof window === 'undefined') {\n    return\n  }\n\n  // better to be safe than sorry\n  try {\n    methods.forEach((method) =>\n      patchConsoleMethod(method, (_, ...args) => {\n        if (isHMR(args)) {\n          return\n        }\n        if (isReactServerReplayedLog(args)) {\n          return\n        }\n        createLogEntry(method, args)\n      })\n    )\n  } catch {}\n  logQueue.router = router\n  isPatched = true\n\n  // Cleanup on page unload\n  window.addEventListener('beforeunload', () => {\n    cancelLogFlush()\n    stopHeartbeat()\n    // Send any remaining logs before page unloads\n    sendClientFileLogs()\n  })\n}\n"],"names":["getOwnerStack","setOwnerStackIfAvailable","getErrorSource","getIsTerminalLoggingEnabled","patchConsoleMethod","preLogSerializationClone","logStringify","safeStringifyWithDepth","ClientFileLogger","formatTimestamp","now","Date","hours","getHours","toString","padStart","minutes","getMinutes","seconds","getSeconds","milliseconds","getMilliseconds","log","level","args","isReactServerReplayedLog","message","map","arg","String","undefined","Element","tagName","toLowerCase","join","logEntry","timestamp","toUpperCase","logEntries","push","scheduleLogFlush","getLogs","clear","clientFileLogger","logFlushTimeout","heartbeatInterval","clearTimeout","setTimeout","sendClientFileLogs","cancelLogFlush","startHeartbeat","setInterval","logQueue","socket","readyState","WebSocket","OPEN","send","JSON","stringify","event","error","stopHeartbeat","clearInterval","isTerminalLoggingEnabled","methods","afterThisFrame","cb","timeout","rafId","requestAnimationFrame","cancelAnimationFrame","isPatched","serializeEntries","entries","clientEntry","kind","stringifyUserArg","logs","length","payload","console","flushScheduled","cancelFlush","sourceType","router","scheduleLogSend","entry","onSocketReady","process","env","__NEXT_MCP_SERVER","addEventListener","data","createErrorArg","stack","stackWithOwners","prefix","name","createLogEntry","Error","stackLines","split","cleanStack","slice","consoleMethodStack","method","forwardErrorLog","errorObjects","filter","first","at","source","consoleErrorStack","createUncaughtErrorEntry","errorName","errorMessage","fullStack","ownerStack","logUnhandledRejection","reason","createUnhandledRejectionErrorEntry","createUnhandledRejectionNonErrorEntry","isRejectionMessage","isHMR","firstArg","startsWith","format","styles","label","includes","forwardUnhandledError","initializeDebugLogForwarding","window","forEach","_"],"mappings":"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","ignoreList":[0]}