{"version":3,"sources":["../../src/lib/has-necessary-dependencies.ts"],"sourcesContent":["import { existsSync, realpathSync } from 'fs'\nimport { resolveFrom } from './resolve-from'\nimport { dirname, join, relative } from 'path'\n\nexport interface MissingDependency {\n  file: string\n  /**\n   * The package's package.json (e.g. require(`${pkg}/package.json`)) MUST resolve.\n   * If `exportsRestrict` is false, `${file}` MUST also resolve.\n   */\n  pkg: string\n  /**\n   * If true, the pkg's package.json needs to be resolvable.\n   * If true, will resolve `file` relative to the real path of the package.json.\n   *\n   * For example, `{ file: '@types/react/index.d.ts', pkg: '@types/react', exportsRestrict: true }`\n   * will try to resolve '@types/react/package.json' first and then assume `@types/react/index.d.ts`\n   * resolves to `path.join(dirname(resolvedPackageJsonPath), 'index.d.ts')`.\n   *\n   * If false, will resolve `file` relative to the baseDir.\n   * ForFor example, `{ file: '@types/react/index.d.ts', pkg: '@types/react', exportsRestrict: true }`\n   * will try to resolve `@types/react/index.d.ts` directly.\n   */\n  exportsRestrict: boolean\n}\n\nexport type NecessaryDependencies = {\n  resolved: Map<string, string>\n  missing: MissingDependency[]\n}\n\nexport function hasNecessaryDependencies(\n  baseDir: string,\n  requiredPackages: MissingDependency[]\n): NecessaryDependencies {\n  let resolutions = new Map<string, string>()\n  const missingPackages: MissingDependency[] = []\n\n  for (const p of requiredPackages) {\n    try {\n      const pkgPath = realpathSync(\n        resolveFrom(baseDir, `${p.pkg}/package.json`)\n      )\n      const pkgDir = dirname(pkgPath)\n\n      resolutions.set(join(p.pkg, 'package.json'), pkgPath)\n\n      if (p.exportsRestrict) {\n        const fileNameToVerify = relative(p.pkg, p.file)\n        if (fileNameToVerify) {\n          const fileToVerify = join(pkgDir, fileNameToVerify)\n          if (existsSync(fileToVerify)) {\n            resolutions.set(p.pkg, fileToVerify)\n          } else {\n            missingPackages.push(p)\n            continue\n          }\n        } else {\n          resolutions.set(p.pkg, pkgPath)\n        }\n      } else {\n        resolutions.set(p.pkg, resolveFrom(baseDir, p.file))\n      }\n    } catch (_) {\n      missingPackages.push(p)\n      continue\n    }\n  }\n\n  return {\n    resolved: resolutions,\n    missing: missingPackages,\n  }\n}\n"],"names":["hasNecessaryDependencies","baseDir","requiredPackages","resolutions","Map","missingPackages","p","pkgPath","realpathSync","resolveFrom","pkg","pkgDir","dirname","set","join","exportsRestrict","fileNameToVerify","relative","file","fileToVerify","existsSync","push","_","resolved","missing"],"mappings":";;;;+BA+BgBA;;;eAAAA;;;oBA/ByB;6BACb;sBACY;AA6BjC,SAASA,yBACdC,OAAe,EACfC,gBAAqC;IAErC,IAAIC,cAAc,IAAIC;IACtB,MAAMC,kBAAuC,EAAE;IAE/C,KAAK,MAAMC,KAAKJ,iBAAkB;QAChC,IAAI;YACF,MAAMK,UAAUC,IAAAA,gBAAY,EAC1BC,IAAAA,wBAAW,EAACR,SAAS,GAAGK,EAAEI,GAAG,CAAC,aAAa,CAAC;YAE9C,MAAMC,SAASC,IAAAA,aAAO,EAACL;YAEvBJ,YAAYU,GAAG,CAACC,IAAAA,UAAI,EAACR,EAAEI,GAAG,EAAE,iBAAiBH;YAE7C,IAAID,EAAES,eAAe,EAAE;gBACrB,MAAMC,mBAAmBC,IAAAA,cAAQ,EAACX,EAAEI,GAAG,EAAEJ,EAAEY,IAAI;gBAC/C,IAAIF,kBAAkB;oBACpB,MAAMG,eAAeL,IAAAA,UAAI,EAACH,QAAQK;oBAClC,IAAII,IAAAA,cAAU,EAACD,eAAe;wBAC5BhB,YAAYU,GAAG,CAACP,EAAEI,GAAG,EAAES;oBACzB,OAAO;wBACLd,gBAAgBgB,IAAI,CAACf;wBACrB;oBACF;gBACF,OAAO;oBACLH,YAAYU,GAAG,CAACP,EAAEI,GAAG,EAAEH;gBACzB;YACF,OAAO;gBACLJ,YAAYU,GAAG,CAACP,EAAEI,GAAG,EAAED,IAAAA,wBAAW,EAACR,SAASK,EAAEY,IAAI;YACpD;QACF,EAAE,OAAOI,GAAG;YACVjB,gBAAgBgB,IAAI,CAACf;YACrB;QACF;IACF;IAEA,OAAO;QACLiB,UAAUpB;QACVqB,SAASnB;IACX;AACF","ignoreList":[0]}