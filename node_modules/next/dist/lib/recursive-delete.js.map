{"version":3,"sources":["../../src/lib/recursive-delete.ts"],"sourcesContent":["import type { Dirent } from 'node:fs'\nimport * as fs from 'node:fs'\nimport { join } from 'node:path'\nimport isError from './is-error'\nimport { wait } from './wait'\n\n// We use an exponential backoff. See the unit test for example values.\n//\n// - Node's `fs` module uses a linear backoff, starting with 100ms.\n// - Rust tries 64 times with only a `thread::yield_now` in between.\n//\n// We want something more aggressive, as `recursiveDelete` is in the critical\n// path of `next dev` and `next build` startup.\nconst INITIAL_RETRY_MS = 8\nconst MAX_RETRY_MS = 64\nconst MAX_RETRIES = 6\n\n/**\n * Used in unit test.\n * @ignore\n */\nexport function calcBackoffMs(attempt: number): number {\n  return Math.min(INITIAL_RETRY_MS * Math.pow(2, attempt), MAX_RETRY_MS)\n}\n\nfunction unlinkPath(\n  p: string,\n  isDir = false,\n  attempt = 0\n): Promise<void> | void {\n  try {\n    if (isDir) {\n      fs.rmdirSync(p)\n    } else {\n      fs.unlinkSync(p)\n    }\n  } catch (e) {\n    const code = isError(e) && e.code\n    if (\n      (code === 'EBUSY' ||\n        code === 'ENOTEMPTY' ||\n        code === 'EPERM' ||\n        code === 'EMFILE') &&\n      attempt < MAX_RETRIES\n    ) {\n      // retrying is unlikely to succeed on POSIX platforms, but Windows can\n      // fail due to temporarily-open files\n      return (async () => {\n        await wait(calcBackoffMs(attempt))\n        return unlinkPath(p, isDir, attempt + 1)\n      })()\n    }\n\n    if (code === 'ENOENT') {\n      return\n    }\n\n    throw e\n  }\n}\n\n/**\n * Recursively delete directory contents.\n *\n * This is used when cleaning the `distDir`, and is part of the critical path\n * for starting the server, so we use synchronous file IO, as we're always\n * blocked on it anyways.\n *\n * Despite using sync IO, the function signature is still `async` because we\n * asynchronously perform retries.\n */\nexport async function recursiveDeleteSyncWithAsyncRetries(\n  /** Directory to delete the contents of */\n  dir: string,\n  /** Exclude based on relative file path */\n  exclude?: RegExp,\n  /** Relative path to the directory being deleted, used for exclude */\n  previousPath: string = ''\n): Promise<void> {\n  let result\n  try {\n    result = fs.readdirSync(dir, { withFileTypes: true })\n  } catch (e) {\n    if (isError(e) && e.code === 'ENOENT') {\n      return\n    }\n    throw e\n  }\n\n  await Promise.all(\n    result.map(async (part: Dirent) => {\n      const absolutePath = join(dir, part.name)\n      const pp = join(previousPath, part.name)\n      const isNotExcluded = !exclude || !exclude.test(pp)\n\n      if (isNotExcluded) {\n        // Note: readdir does not follow symbolic links, that's good: we want to\n        // delete the links and not the destination.\n        let isDirectory = part.isDirectory()\n        if (isDirectory) {\n          await recursiveDeleteSyncWithAsyncRetries(absolutePath, exclude, pp)\n        }\n        return unlinkPath(absolutePath, isDirectory)\n      }\n    })\n  )\n}\n"],"names":["calcBackoffMs","recursiveDeleteSyncWithAsyncRetries","INITIAL_RETRY_MS","MAX_RETRY_MS","MAX_RETRIES","attempt","Math","min","pow","unlinkPath","p","isDir","fs","rmdirSync","unlinkSync","e","code","isError","wait","dir","exclude","previousPath","result","readdirSync","withFileTypes","Promise","all","map","part","absolutePath","join","name","pp","isNotExcluded","test","isDirectory"],"mappings":";;;;;;;;;;;;;;;IAqBgBA,aAAa;eAAbA;;IAkDMC,mCAAmC;eAAnCA;;;gEAtEF;0BACC;gEACD;sBACC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAErB,uEAAuE;AACvE,EAAE;AACF,mEAAmE;AACnE,oEAAoE;AACpE,EAAE;AACF,6EAA6E;AAC7E,+CAA+C;AAC/C,MAAMC,mBAAmB;AACzB,MAAMC,eAAe;AACrB,MAAMC,cAAc;AAMb,SAASJ,cAAcK,OAAe;IAC3C,OAAOC,KAAKC,GAAG,CAACL,mBAAmBI,KAAKE,GAAG,CAAC,GAAGH,UAAUF;AAC3D;AAEA,SAASM,WACPC,CAAS,EACTC,QAAQ,KAAK,EACbN,UAAU,CAAC;IAEX,IAAI;QACF,IAAIM,OAAO;YACTC,QAAGC,SAAS,CAACH;QACf,OAAO;YACLE,QAAGE,UAAU,CAACJ;QAChB;IACF,EAAE,OAAOK,GAAG;QACV,MAAMC,OAAOC,IAAAA,gBAAO,EAACF,MAAMA,EAAEC,IAAI;QACjC,IACE,AAACA,CAAAA,SAAS,WACRA,SAAS,eACTA,SAAS,WACTA,SAAS,QAAO,KAClBX,UAAUD,aACV;YACA,sEAAsE;YACtE,qCAAqC;YACrC,OAAO,AAAC,CAAA;gBACN,MAAMc,IAAAA,UAAI,EAAClB,cAAcK;gBACzB,OAAOI,WAAWC,GAAGC,OAAON,UAAU;YACxC,CAAA;QACF;QAEA,IAAIW,SAAS,UAAU;YACrB;QACF;QAEA,MAAMD;IACR;AACF;AAYO,eAAed,oCACpB,wCAAwC,GACxCkB,GAAW,EACX,wCAAwC,GACxCC,OAAgB,EAChB,mEAAmE,GACnEC,eAAuB,EAAE;IAEzB,IAAIC;IACJ,IAAI;QACFA,SAASV,QAAGW,WAAW,CAACJ,KAAK;YAAEK,eAAe;QAAK;IACrD,EAAE,OAAOT,GAAG;QACV,IAAIE,IAAAA,gBAAO,EAACF,MAAMA,EAAEC,IAAI,KAAK,UAAU;YACrC;QACF;QACA,MAAMD;IACR;IAEA,MAAMU,QAAQC,GAAG,CACfJ,OAAOK,GAAG,CAAC,OAAOC;QAChB,MAAMC,eAAeC,IAAAA,cAAI,EAACX,KAAKS,KAAKG,IAAI;QACxC,MAAMC,KAAKF,IAAAA,cAAI,EAACT,cAAcO,KAAKG,IAAI;QACvC,MAAME,gBAAgB,CAACb,WAAW,CAACA,QAAQc,IAAI,CAACF;QAEhD,IAAIC,eAAe;YACjB,wEAAwE;YACxE,4CAA4C;YAC5C,IAAIE,cAAcP,KAAKO,WAAW;YAClC,IAAIA,aAAa;gBACf,MAAMlC,oCAAoC4B,cAAcT,SAASY;YACnE;YACA,OAAOvB,WAAWoB,cAAcM;QAClC;IACF;AAEJ","ignoreList":[0]}