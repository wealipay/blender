{"version":3,"sources":["../../../../../src/shared/lib/router/utils/get-segment-param.tsx"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'\nimport type { DynamicParamTypes } from '../../app-router-types'\n\n/**\n * Parse dynamic route segment to type of parameter\n */\nexport function getSegmentParam(segment: string): {\n  param: string\n  type: DynamicParamTypes\n} | null {\n  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker) =>\n    segment.startsWith(marker)\n  )\n\n  // if an interception marker is part of the path segment, we need to jump ahead\n  // to the relevant portion for param parsing\n  if (interceptionMarker) {\n    segment = segment.slice(interceptionMarker.length)\n  }\n\n  if (segment.startsWith('[[...') && segment.endsWith(']]')) {\n    return {\n      // TODO-APP: Optional catchall does not currently work with parallel routes,\n      // so for now aren't handling a potential interception marker.\n      type: 'optional-catchall',\n      param: segment.slice(5, -2),\n    }\n  }\n\n  if (segment.startsWith('[...') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'catchall-intercepted' : 'catchall',\n      param: segment.slice(4, -1),\n    }\n  }\n\n  if (segment.startsWith('[') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'dynamic-intercepted' : 'dynamic',\n      param: segment.slice(1, -1),\n    }\n  }\n\n  return null\n}\n\nexport function isCatchAll(\n  type: DynamicParamTypes\n): type is 'catchall' | 'catchall-intercepted' | 'optional-catchall' {\n  return (\n    type === 'catchall' ||\n    type === 'catchall-intercepted' ||\n    type === 'optional-catchall'\n  )\n}\n\nexport function getParamProperties(paramType: DynamicParamTypes): {\n  repeat: boolean\n  optional: boolean\n} {\n  let repeat = false\n  let optional = false\n\n  switch (paramType) {\n    case 'catchall':\n    case 'catchall-intercepted':\n      repeat = true\n      break\n    case 'optional-catchall':\n      repeat = true\n      optional = true\n      break\n    case 'dynamic':\n    case 'dynamic-intercepted':\n      break\n    default:\n      paramType satisfies never\n  }\n\n  return { repeat, optional }\n}\n"],"names":["getParamProperties","getSegmentParam","isCatchAll","segment","interceptionMarker","INTERCEPTION_ROUTE_MARKERS","find","marker","startsWith","slice","length","endsWith","type","param","paramType","repeat","optional"],"mappings":";;;;;;;;;;;;;;;;IAwDgBA,kBAAkB;eAAlBA;;IAlDAC,eAAe;eAAfA;;IAwCAC,UAAU;eAAVA;;;oCA9C2B;AAMpC,SAASD,gBAAgBE,OAAe;IAI7C,MAAMC,qBAAqBC,8CAA0B,CAACC,IAAI,CAAC,CAACC,SAC1DJ,QAAQK,UAAU,CAACD;IAGrB,+EAA+E;IAC/E,4CAA4C;IAC5C,IAAIH,oBAAoB;QACtBD,UAAUA,QAAQM,KAAK,CAACL,mBAAmBM,MAAM;IACnD;IAEA,IAAIP,QAAQK,UAAU,CAAC,YAAYL,QAAQQ,QAAQ,CAAC,OAAO;QACzD,OAAO;YACL,4EAA4E;YAC5E,8DAA8D;YAC9DC,MAAM;YACNC,OAAOV,QAAQM,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIN,QAAQK,UAAU,CAAC,WAAWL,QAAQQ,QAAQ,CAAC,MAAM;QACvD,OAAO;YACLC,MAAMR,qBAAqB,yBAAyB;YACpDS,OAAOV,QAAQM,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIN,QAAQK,UAAU,CAAC,QAAQL,QAAQQ,QAAQ,CAAC,MAAM;QACpD,OAAO;YACLC,MAAMR,qBAAqB,wBAAwB;YACnDS,OAAOV,QAAQM,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,OAAO;AACT;AAEO,SAASP,WACdU,IAAuB;IAEvB,OACEA,SAAS,cACTA,SAAS,0BACTA,SAAS;AAEb;AAEO,SAASZ,mBAAmBc,SAA4B;IAI7D,IAAIC,SAAS;IACb,IAAIC,WAAW;IAEf,OAAQF;QACN,KAAK;QACL,KAAK;YACHC,SAAS;YACT;QACF,KAAK;YACHA,SAAS;YACTC,WAAW;YACX;QACF,KAAK;QACL,KAAK;YACH;QACF;YACEF;IACJ;IAEA,OAAO;QAAEC;QAAQC;IAAS;AAC5B","ignoreList":[0]}