{"version":3,"sources":["../../../../src/server/route-modules/app-page/module.ts"],"sourcesContent":["import type { AppPageRouteDefinition } from '../../route-definitions/app-page-route-definition'\nimport type RenderResult from '../../render-result'\nimport type { RenderOpts } from '../../app-render/types'\nimport type { NextParsedUrlQuery } from '../../request-meta'\nimport type { LoaderTree } from '../../lib/app-dir-module'\nimport type { PrerenderManifest } from '../../../build'\n\nimport {\n  renderToHTMLOrFlight,\n  type AppSharedContext,\n} from '../../app-render/app-render'\nimport {\n  RouteModule,\n  type RouteModuleOptions,\n  type RouteModuleHandleContext,\n} from '../route-module'\nimport * as vendoredContexts from './vendored/contexts/entrypoints'\nimport type { BaseNextRequest, BaseNextResponse } from '../../base-http'\nimport type { ServerComponentsHmrCache } from '../../response-cache'\nimport type { OpaqueFallbackRouteParams } from '../../request/fallback-params'\nimport { PrerenderManifestMatcher } from './helpers/prerender-manifest-matcher'\nimport type { DeepReadonly } from '../../../shared/lib/deep-readonly'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n} from '../../../client/components/app-router-headers'\nimport { isInterceptionRouteAppPath } from '../../../shared/lib/router/utils/interception-routes'\n\nlet vendoredReactRSC\nlet vendoredReactSSR\n\n// the vendored Reacts are loaded from their original source in the edge runtime\nif (process.env.NEXT_RUNTIME !== 'edge') {\n  vendoredReactRSC =\n    require('./vendored/rsc/entrypoints') as typeof import('./vendored/rsc/entrypoints')\n  vendoredReactSSR =\n    require('./vendored/ssr/entrypoints') as typeof import('./vendored/ssr/entrypoints')\n\n  // In Node environments we augment console logging with information contextual to a React render.\n  // This patching is global so we need to register the cacheSignal getter from our bundled React instances\n  // here when we load them rather than in the external module itself when the patch is applied.\n  const { registerGetCacheSignal } =\n    require('../../node-environment-extensions/console-dim.external') as typeof import('../../node-environment-extensions/console-dim.external')\n  registerGetCacheSignal(vendoredReactRSC.React.cacheSignal)\n  registerGetCacheSignal(vendoredReactSSR.React.cacheSignal)\n}\n\n/**\n * The AppPageModule is the type of the module exported by the bundled app page\n * module.\n */\nexport type AppPageModule = typeof import('../../../build/templates/app-page')\n\ntype AppPageUserlandModule = {\n  /**\n   * The tree created in next-app-loader that holds component segments and modules\n   */\n  loaderTree: LoaderTree\n}\n\nexport interface AppPageRouteHandlerContext extends RouteModuleHandleContext {\n  page: string\n  query: NextParsedUrlQuery\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n  renderOpts: RenderOpts\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  sharedContext: AppSharedContext\n}\n\nexport type AppPageRouteModuleOptions = RouteModuleOptions<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n>\n\nexport class AppPageRouteModule extends RouteModule<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n> {\n  private matchers = new WeakMap<\n    DeepReadonly<PrerenderManifest>,\n    PrerenderManifestMatcher\n  >()\n  public match(\n    pathname: string,\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n  ) {\n    // Lazily create the matcher based on the provided prerender manifest.\n    let matcher = this.matchers.get(prerenderManifest)\n    if (!matcher) {\n      matcher = new PrerenderManifestMatcher(\n        this.definition.pathname,\n        prerenderManifest\n      )\n      this.matchers.set(prerenderManifest, matcher)\n    }\n\n    // Match the pathname to the dynamic route.\n    return matcher.match(pathname)\n  }\n\n  public render(\n    req: BaseNextRequest,\n    res: BaseNextResponse,\n    context: AppPageRouteHandlerContext\n  ): Promise<RenderResult> {\n    return renderToHTMLOrFlight(\n      req,\n      res,\n      context.page,\n      context.query,\n      context.fallbackRouteParams,\n      context.renderOpts,\n      context.serverComponentsHmrCache,\n      context.sharedContext\n    )\n  }\n\n  private pathCouldBeIntercepted(\n    resolvedPathname: string,\n    interceptionRoutePatterns: RegExp[]\n  ): boolean {\n    return (\n      isInterceptionRouteAppPath(resolvedPathname) ||\n      interceptionRoutePatterns.some((regexp) => {\n        return regexp.test(resolvedPathname)\n      })\n    )\n  }\n\n  public getVaryHeader(\n    resolvedPathname: string,\n    interceptionRoutePatterns: RegExp[]\n  ): string {\n    const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`\n\n    if (\n      this.pathCouldBeIntercepted(resolvedPathname, interceptionRoutePatterns)\n    ) {\n      // Interception route responses can vary based on the `Next-URL` header.\n      // We use the Vary header to signal this behavior to the client to properly cache the response.\n      return `${baseVaryHeader}, ${NEXT_URL}`\n    } else {\n      // We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.\n      // We also set this header for pages to avoid caching issues when navigating between pages and app.\n      return baseVaryHeader\n    }\n  }\n}\n\nconst vendored = {\n  'react-rsc': vendoredReactRSC,\n  'react-ssr': vendoredReactSSR,\n  contexts: vendoredContexts,\n}\n\nexport { renderToHTMLOrFlight, vendored }\n\nexport default AppPageRouteModule\n"],"names":["AppPageRouteModule","renderToHTMLOrFlight","vendored","vendoredReactRSC","vendoredReactSSR","process","env","NEXT_RUNTIME","require","registerGetCacheSignal","React","cacheSignal","RouteModule","match","pathname","prerenderManifest","matcher","matchers","get","PrerenderManifestMatcher","definition","set","render","req","res","context","page","query","fallbackRouteParams","renderOpts","serverComponentsHmrCache","sharedContext","pathCouldBeIntercepted","resolvedPathname","interceptionRoutePatterns","isInterceptionRouteAppPath","some","regexp","test","getVaryHeader","baseVaryHeader","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","WeakMap","contexts","vendoredContexts"],"mappings":";;;;;;;;;;;;;;;;;IA6EaA,kBAAkB;eAAlBA;;IAmFb,OAAiC;eAAjC;;IAFSC,oBAAoB;eAApBA,+BAAoB;;IAAEC,QAAQ;eAARA;;;2BApJxB;6BAKA;qEAC2B;0CAIO;kCAQlC;oCACoC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3C,IAAIC;AACJ,IAAIC;AAEJ,gFAAgF;AAChF,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;IACvCJ,mBACEK,QAAQ;IACVJ,mBACEI,QAAQ;IAEV,iGAAiG;IACjG,yGAAyG;IACzG,8FAA8F;IAC9F,MAAM,EAAEC,sBAAsB,EAAE,GAC9BD,QAAQ;IACVC,uBAAuBN,iBAAiBO,KAAK,CAACC,WAAW;IACzDF,uBAAuBL,iBAAiBM,KAAK,CAACC,WAAW;AAC3D;AA6BO,MAAMX,2BAA2BY,wBAAW;IAQ1CC,MACLC,QAAgB,EAChBC,iBAAkD,EAClD;QACA,sEAAsE;QACtE,IAAIC,UAAU,IAAI,CAACC,QAAQ,CAACC,GAAG,CAACH;QAChC,IAAI,CAACC,SAAS;YACZA,UAAU,IAAIG,kDAAwB,CACpC,IAAI,CAACC,UAAU,CAACN,QAAQ,EACxBC;YAEF,IAAI,CAACE,QAAQ,CAACI,GAAG,CAACN,mBAAmBC;QACvC;QAEA,2CAA2C;QAC3C,OAAOA,QAAQH,KAAK,CAACC;IACvB;IAEOQ,OACLC,GAAoB,EACpBC,GAAqB,EACrBC,OAAmC,EACZ;QACvB,OAAOxB,IAAAA,+BAAoB,EACzBsB,KACAC,KACAC,QAAQC,IAAI,EACZD,QAAQE,KAAK,EACbF,QAAQG,mBAAmB,EAC3BH,QAAQI,UAAU,EAClBJ,QAAQK,wBAAwB,EAChCL,QAAQM,aAAa;IAEzB;IAEQC,uBACNC,gBAAwB,EACxBC,yBAAmC,EAC1B;QACT,OACEC,IAAAA,8CAA0B,EAACF,qBAC3BC,0BAA0BE,IAAI,CAAC,CAACC;YAC9B,OAAOA,OAAOC,IAAI,CAACL;QACrB;IAEJ;IAEOM,cACLN,gBAAwB,EACxBC,yBAAmC,EAC3B;QACR,MAAMM,iBAAiB,GAAGC,4BAAU,CAAC,EAAE,EAAEC,+CAA6B,CAAC,EAAE,EAAEC,6CAA2B,CAAC,EAAE,EAAEC,qDAAmC,EAAE;QAEhJ,IACE,IAAI,CAACZ,sBAAsB,CAACC,kBAAkBC,4BAC9C;YACA,wEAAwE;YACxE,+FAA+F;YAC/F,OAAO,GAAGM,eAAe,EAAE,EAAEK,0BAAQ,EAAE;QACzC,OAAO;YACL,yHAAyH;YACzH,mGAAmG;YACnG,OAAOL;QACT;IACF;;QAxEK,qBAIGvB,WAAW,IAAI6B;;AAqEzB;AAEA,MAAM5C,WAAW;IACf,aAAaC;IACb,aAAaC;IACb2C,UAAUC;AACZ;MAIA,WAAehD","ignoreList":[0]}