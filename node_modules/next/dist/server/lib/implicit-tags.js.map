{"version":3,"sources":["../../../src/server/lib/implicit-tags.ts"],"sourcesContent":["import { NEXT_CACHE_IMPLICIT_TAG_ID } from '../../lib/constants'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\nimport { getCacheHandlerEntries } from '../use-cache/handlers'\nimport { createLazyResult, type LazyResult } from './lazy-result'\n\nexport interface ImplicitTags {\n  /**\n   * For legacy usage, the implicit tags are passed to the incremental cache\n   * handler in `get` calls.\n   */\n  readonly tags: string[]\n\n  /**\n   * Modern cache handlers don't receive implicit tags. Instead, the implicit\n   * tags' expirations are stored in the work unit store, and used to compare\n   * with a cache entry's timestamp.\n   *\n   * Note: This map contains lazy results so that we can evaluate them when the\n   * first cache entry is read. It allows us to skip fetching the expiration\n   * values if no caches are read at all.\n   */\n  readonly expirationsByCacheKind: Map<string, LazyResult<number>>\n}\n\nconst getDerivedTags = (pathname: string): string[] => {\n  const derivedTags: string[] = [`/layout`]\n\n  // we automatically add the current path segments as tags\n  // for revalidatePath handling\n  if (pathname.startsWith('/')) {\n    const pathnameParts = pathname.split('/')\n\n    for (let i = 1; i < pathnameParts.length + 1; i++) {\n      let curPathname = pathnameParts.slice(0, i).join('/')\n\n      if (curPathname) {\n        // all derived tags other than the page are layout tags\n        if (!curPathname.endsWith('/page') && !curPathname.endsWith('/route')) {\n          curPathname = `${curPathname}${\n            !curPathname.endsWith('/') ? '/' : ''\n          }layout`\n        }\n        derivedTags.push(curPathname)\n      }\n    }\n  }\n  return derivedTags\n}\n\n/**\n * Creates a map with lazy results that fetch the expiration value for the given\n * tags and respective cache kind when they're awaited for the first time.\n */\nfunction createTagsExpirationsByCacheKind(\n  tags: string[]\n): Map<string, LazyResult<number>> {\n  const expirationsByCacheKind = new Map<string, LazyResult<number>>()\n  const cacheHandlers = getCacheHandlerEntries()\n\n  if (cacheHandlers) {\n    for (const [kind, cacheHandler] of cacheHandlers) {\n      if ('getExpiration' in cacheHandler) {\n        expirationsByCacheKind.set(\n          kind,\n          createLazyResult(async () => cacheHandler.getExpiration(tags))\n        )\n      }\n    }\n  }\n\n  return expirationsByCacheKind\n}\n\nexport async function getImplicitTags(\n  page: string,\n  url: {\n    pathname: string\n    search?: string\n  },\n  fallbackRouteParams: null | OpaqueFallbackRouteParams\n): Promise<ImplicitTags> {\n  const tags = new Set<string>()\n\n  // Add the derived tags from the page.\n  const derivedTags = getDerivedTags(page)\n  for (let tag of derivedTags) {\n    tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`\n    tags.add(tag)\n  }\n\n  // Add the tags from the pathname. If the route has unknown params, we don't\n  // want to add the pathname as a tag, as it will be invalid.\n  if (\n    url.pathname &&\n    (!fallbackRouteParams || fallbackRouteParams.size === 0)\n  ) {\n    const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${url.pathname}`\n    tags.add(tag)\n  }\n\n  if (tags.has(`${NEXT_CACHE_IMPLICIT_TAG_ID}/`)) {\n    tags.add(`${NEXT_CACHE_IMPLICIT_TAG_ID}/index`)\n  }\n\n  if (tags.has(`${NEXT_CACHE_IMPLICIT_TAG_ID}/index`)) {\n    tags.add(`${NEXT_CACHE_IMPLICIT_TAG_ID}/`)\n  }\n\n  const tagsArray = Array.from(tags)\n  return {\n    tags: tagsArray,\n    expirationsByCacheKind: createTagsExpirationsByCacheKind(tagsArray),\n  }\n}\n"],"names":["getImplicitTags","getDerivedTags","pathname","derivedTags","startsWith","pathnameParts","split","i","length","curPathname","slice","join","endsWith","push","createTagsExpirationsByCacheKind","tags","expirationsByCacheKind","Map","cacheHandlers","getCacheHandlerEntries","kind","cacheHandler","set","createLazyResult","getExpiration","page","url","fallbackRouteParams","Set","tag","NEXT_CACHE_IMPLICIT_TAG_ID","add","size","has","tagsArray","Array","from"],"mappings":";;;;+BAyEsBA;;;eAAAA;;;2BAzEqB;0BAEJ;4BACW;AAqBlD,MAAMC,iBAAiB,CAACC;IACtB,MAAMC,cAAwB;QAAC,CAAC,OAAO,CAAC;KAAC;IAEzC,yDAAyD;IACzD,8BAA8B;IAC9B,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,gBAAgBH,SAASI,KAAK,CAAC;QAErC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,cAAcG,MAAM,GAAG,GAAGD,IAAK;YACjD,IAAIE,cAAcJ,cAAcK,KAAK,CAAC,GAAGH,GAAGI,IAAI,CAAC;YAEjD,IAAIF,aAAa;gBACf,uDAAuD;gBACvD,IAAI,CAACA,YAAYG,QAAQ,CAAC,YAAY,CAACH,YAAYG,QAAQ,CAAC,WAAW;oBACrEH,cAAc,GAAGA,cACf,CAACA,YAAYG,QAAQ,CAAC,OAAO,MAAM,GACpC,MAAM,CAAC;gBACV;gBACAT,YAAYU,IAAI,CAACJ;YACnB;QACF;IACF;IACA,OAAON;AACT;AAEA;;;CAGC,GACD,SAASW,iCACPC,IAAc;IAEd,MAAMC,yBAAyB,IAAIC;IACnC,MAAMC,gBAAgBC,IAAAA,gCAAsB;IAE5C,IAAID,eAAe;QACjB,KAAK,MAAM,CAACE,MAAMC,aAAa,IAAIH,cAAe;YAChD,IAAI,mBAAmBG,cAAc;gBACnCL,uBAAuBM,GAAG,CACxBF,MACAG,IAAAA,4BAAgB,EAAC,UAAYF,aAAaG,aAAa,CAACT;YAE5D;QACF;IACF;IAEA,OAAOC;AACT;AAEO,eAAehB,gBACpByB,IAAY,EACZC,GAGC,EACDC,mBAAqD;IAErD,MAAMZ,OAAO,IAAIa;IAEjB,sCAAsC;IACtC,MAAMzB,cAAcF,eAAewB;IACnC,KAAK,IAAII,OAAO1B,YAAa;QAC3B0B,MAAM,GAAGC,qCAA0B,GAAGD,KAAK;QAC3Cd,KAAKgB,GAAG,CAACF;IACX;IAEA,4EAA4E;IAC5E,4DAA4D;IAC5D,IACEH,IAAIxB,QAAQ,IACX,CAAA,CAACyB,uBAAuBA,oBAAoBK,IAAI,KAAK,CAAA,GACtD;QACA,MAAMH,MAAM,GAAGC,qCAA0B,GAAGJ,IAAIxB,QAAQ,EAAE;QAC1Da,KAAKgB,GAAG,CAACF;IACX;IAEA,IAAId,KAAKkB,GAAG,CAAC,GAAGH,qCAA0B,CAAC,CAAC,CAAC,GAAG;QAC9Cf,KAAKgB,GAAG,CAAC,GAAGD,qCAA0B,CAAC,MAAM,CAAC;IAChD;IAEA,IAAIf,KAAKkB,GAAG,CAAC,GAAGH,qCAA0B,CAAC,MAAM,CAAC,GAAG;QACnDf,KAAKgB,GAAG,CAAC,GAAGD,qCAA0B,CAAC,CAAC,CAAC;IAC3C;IAEA,MAAMI,YAAYC,MAAMC,IAAI,CAACrB;IAC7B,OAAO;QACLA,MAAMmB;QACNlB,wBAAwBF,iCAAiCoB;IAC3D;AACF","ignoreList":[0]}