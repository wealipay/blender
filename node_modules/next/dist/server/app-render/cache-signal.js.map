{"version":3,"sources":["../../../src/server/app-render/cache-signal.ts"],"sourcesContent":["/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the cacheComponents flag is on\n * and should only be used in codepaths gated with this feature.\n */\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport class CacheSignal {\n  private count = 0\n  private earlyListeners: Array<() => void> = []\n  private listeners: Array<() => void> = []\n  private tickPending = false\n  private pendingTimeoutCleanup: (() => void) | null = null\n\n  private subscribedSignals: Set<CacheSignal> | null = null\n\n  constructor() {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      // we rely on `process.nextTick`, which is not supported in edge\n      throw new InvariantError(\n        'CacheSignal cannot be used in the edge runtime, because `cacheComponents` does not support it.'\n      )\n    }\n  }\n\n  private noMorePendingCaches() {\n    if (!this.tickPending) {\n      this.tickPending = true\n      queueMicrotask(() =>\n        process.nextTick(() => {\n          this.tickPending = false\n          if (this.count === 0) {\n            for (let i = 0; i < this.earlyListeners.length; i++) {\n              this.earlyListeners[i]()\n            }\n            this.earlyListeners.length = 0\n          }\n        })\n      )\n    }\n\n    // After a cache resolves, React will schedule new rendering work:\n    // - in a microtask (when prerendering)\n    // - in setImmediate (when rendering)\n    // To cover both of these, we have to make sure that we let immediates execute at least once after each cache resolved.\n    // We don't know when the pending timeout was scheduled (and if it's about to resolve),\n    // so by scheduling a new one, we can be sure that we'll go around the event loop at least once.\n    if (this.pendingTimeoutCleanup) {\n      // We cancel the timeout in beginRead, so this shouldn't ever be active here,\n      // but we still cancel it defensively.\n      this.pendingTimeoutCleanup()\n    }\n    this.pendingTimeoutCleanup = scheduleImmediateAndTimeoutWithCleanup(\n      this.invokeListenersIfNoPendingReads\n    )\n  }\n\n  private invokeListenersIfNoPendingReads = () => {\n    this.pendingTimeoutCleanup = null\n    if (this.count === 0) {\n      for (let i = 0; i < this.listeners.length; i++) {\n        this.listeners[i]()\n      }\n      this.listeners.length = 0\n    }\n  }\n\n  /**\n   * This promise waits until there are no more in progress cache reads but no later.\n   * This allows for adding more cache reads after to delay cacheReady.\n   */\n  inputReady() {\n    return new Promise<void>((resolve) => {\n      this.earlyListeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */\n  cacheReady() {\n    return new Promise<void>((resolve) => {\n      this.listeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  beginRead() {\n    this.count++\n\n    // There's a new pending cache, so if there's a `noMorePendingCaches` timeout running,\n    // we should cancel it.\n    if (this.pendingTimeoutCleanup) {\n      this.pendingTimeoutCleanup()\n      this.pendingTimeoutCleanup = null\n    }\n\n    if (this.subscribedSignals !== null) {\n      for (const subscriber of this.subscribedSignals) {\n        subscriber.beginRead()\n      }\n    }\n  }\n\n  endRead() {\n    if (this.count === 0) {\n      throw new InvariantError(\n        'CacheSignal got more endRead() calls than beginRead() calls'\n      )\n    }\n\n    // If this is the last read we need to wait a task before we can claim the cache is settled.\n    // The cache read will likely ping a Server Component which can read from the cache again and this\n    // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n    // after at least one task.\n    // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n    // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n    this.count--\n    if (this.count === 0) {\n      this.noMorePendingCaches()\n    }\n\n    if (this.subscribedSignals !== null) {\n      for (const subscriber of this.subscribedSignals) {\n        subscriber.endRead()\n      }\n    }\n  }\n\n  hasPendingReads(): boolean {\n    return this.count > 0\n  }\n\n  trackRead<T>(promise: Promise<T>) {\n    this.beginRead()\n    // `promise.finally()` still rejects, so don't use it here to avoid unhandled rejections\n    const onFinally = this.endRead.bind(this)\n    promise.then(onFinally, onFinally)\n    return promise\n  }\n\n  subscribeToReads(subscriber: CacheSignal): () => void {\n    if (subscriber === this) {\n      throw new InvariantError('A CacheSignal cannot subscribe to itself')\n    }\n    if (this.subscribedSignals === null) {\n      this.subscribedSignals = new Set()\n    }\n    this.subscribedSignals.add(subscriber)\n\n    // we'll notify the subscriber of each endRead() on this signal,\n    // so we need to give it a corresponding beginRead() for each read we have in flight now.\n    for (let i = 0; i < this.count; i++) {\n      subscriber.beginRead()\n    }\n\n    return this.unsubscribeFromReads.bind(this, subscriber)\n  }\n\n  unsubscribeFromReads(subscriber: CacheSignal) {\n    if (!this.subscribedSignals) {\n      return\n    }\n    this.subscribedSignals.delete(subscriber)\n\n    // we don't need to set the set back to `null` if it's empty --\n    // if other signals are subscribing to this one, it'll likely get more subscriptions later,\n    // so we'd have to allocate a fresh set again when that happens.\n  }\n}\n\nfunction scheduleImmediateAndTimeoutWithCleanup(cb: () => void): () => void {\n  // If we decide to clean up the timeout, we want to remove\n  // either the immediate or the timeout, whichever is still pending.\n  let clearPending: () => void\n\n  const immediate = setImmediate(() => {\n    const timeout = setTimeout(cb, 0)\n    clearPending = clearTimeout.bind(null, timeout)\n  })\n  clearPending = clearImmediate.bind(null, immediate)\n\n  return () => clearPending()\n}\n"],"names":["CacheSignal","constructor","count","earlyListeners","listeners","tickPending","pendingTimeoutCleanup","subscribedSignals","invokeListenersIfNoPendingReads","i","length","process","env","NEXT_RUNTIME","InvariantError","noMorePendingCaches","queueMicrotask","nextTick","scheduleImmediateAndTimeoutWithCleanup","inputReady","Promise","resolve","push","cacheReady","beginRead","subscriber","endRead","hasPendingReads","trackRead","promise","onFinally","bind","then","subscribeToReads","Set","add","unsubscribeFromReads","delete","cb","clearPending","immediate","setImmediate","timeout","setTimeout","clearTimeout","clearImmediate"],"mappings":"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","ignoreList":[0]}