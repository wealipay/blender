{"version":3,"sources":["../../../src/server/response-cache/index.ts"],"sourcesContent":["import type {\n  ResponseCacheEntry,\n  ResponseGenerator,\n  ResponseCacheBase,\n  IncrementalResponseCacheEntry,\n  IncrementalResponseCache,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly getBatcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalResponseCacheEntry | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private readonly revalidateBatcher = Batcher.create<\n    string,\n    IncrementalResponseCacheEntry | null\n  >({\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalResponseCacheEntry | null\n    expiresAt: number\n  }\n\n  // we don't use minimal_mode name here as this.minimal_mode is\n  // statically replace for server runtimes but we need it to\n  // be dynamic here\n  private minimal_mode?: boolean\n\n  constructor(minimal_mode: boolean) {\n    this.minimal_mode = minimal_mode\n  }\n\n  /**\n   * Gets the response cache entry for the given key.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @returns The response cache entry.\n   */\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalResponseCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n      waitUntil?: (prom: Promise<any>) => void\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({\n        hasResolved: false,\n        previousCacheEntry: null,\n      })\n    }\n\n    // Check minimal mode cache before doing any other work\n    if (\n      this.minimal_mode &&\n      this.previousCacheItem?.key === key &&\n      this.previousCacheItem.expiresAt > Date.now()\n    ) {\n      return toResponseCacheEntry(this.previousCacheItem.entry)\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n      isPrefetch = false,\n      waitUntil,\n      routeKind,\n    } = context\n\n    const response = await this.getBatcher.batch(\n      { key, isOnDemandRevalidate },\n      ({ resolve }) => {\n        const promise = this.handleGet(\n          key,\n          responseGenerator,\n          {\n            incrementalCache,\n            isOnDemandRevalidate,\n            isFallback,\n            isRoutePPREnabled,\n            isPrefetch,\n            routeKind,\n          },\n          resolve\n        )\n\n        // We need to ensure background revalidates are passed to waitUntil.\n        if (waitUntil) waitUntil(promise)\n\n        return promise\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n\n  /**\n   * Handles the get request for the response cache.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @param resolve - The resolve function to use to resolve the response cache entry.\n   * @returns The response cache entry.\n   */\n  private async handleGet(\n    key: string,\n    responseGenerator: ResponseGenerator,\n    context: {\n      incrementalCache: IncrementalResponseCache\n      isOnDemandRevalidate: boolean\n      isFallback: boolean\n      isRoutePPREnabled: boolean\n      isPrefetch: boolean\n      routeKind: RouteKind\n    },\n    resolve: (value: IncrementalResponseCacheEntry | null) => void\n  ): Promise<IncrementalResponseCacheEntry | null> {\n    let previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null =\n      null\n    let resolved = false\n\n    try {\n      // Get the previous cache entry if not in minimal mode\n      previousIncrementalCacheEntry = !this.minimal_mode\n        ? await context.incrementalCache.get(key, {\n            kind: routeKindToIncrementalCacheKind(context.routeKind),\n            isRoutePPREnabled: context.isRoutePPREnabled,\n            isFallback: context.isFallback,\n          })\n        : null\n\n      if (previousIncrementalCacheEntry && !context.isOnDemandRevalidate) {\n        resolve(previousIncrementalCacheEntry)\n        resolved = true\n\n        if (!previousIncrementalCacheEntry.isStale || context.isPrefetch) {\n          // The cached value is still valid, so we don't need to update it yet.\n          return previousIncrementalCacheEntry\n        }\n      }\n\n      // Revalidate the cache entry\n      const incrementalResponseCacheEntry = await this.revalidate(\n        key,\n        context.incrementalCache,\n        context.isRoutePPREnabled,\n        context.isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        previousIncrementalCacheEntry !== null && !context.isOnDemandRevalidate\n      )\n\n      // Handle null response\n      if (!incrementalResponseCacheEntry) {\n        // Unset the previous cache item if it was set so we don't use it again.\n        if (this.minimal_mode) this.previousCacheItem = undefined\n        return null\n      }\n\n      // Resolve for on-demand revalidation or if not already resolved\n      if (context.isOnDemandRevalidate && !resolved) {\n        return incrementalResponseCacheEntry\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // If we've already resolved the cache entry, we can't reject as we\n      // already resolved the cache entry so log the error here.\n      if (resolved) {\n        console.error(err)\n        return null\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Revalidates the cache entry for the given key.\n   *\n   * @param key - The key to revalidate the cache entry for.\n   * @param incrementalCache - The incremental cache to use to revalidate the cache entry.\n   * @param isRoutePPREnabled - Whether the route is PPR enabled.\n   * @param isFallback - Whether the route is a fallback.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param previousIncrementalCacheEntry - The previous cache entry to use to revalidate the cache entry.\n   * @param hasResolved - Whether the response has been resolved.\n   * @returns The revalidated cache entry.\n   */\n  public async revalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean,\n    waitUntil?: (prom: Promise<any>) => void\n  ) {\n    return this.revalidateBatcher.batch(key, () => {\n      const promise = this.handleRevalidate(\n        key,\n        incrementalCache,\n        isRoutePPREnabled,\n        isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        hasResolved\n      )\n\n      // We need to ensure background revalidates are passed to waitUntil.\n      if (waitUntil) waitUntil(promise)\n\n      return promise\n    })\n  }\n\n  private async handleRevalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean\n  ) {\n    try {\n      // Generate the response cache entry using the response generator.\n      const responseCacheEntry = await responseGenerator({\n        hasResolved,\n        previousCacheEntry: previousIncrementalCacheEntry,\n        isRevalidating: true,\n      })\n      if (!responseCacheEntry) {\n        return null\n      }\n\n      // Convert the response cache entry to an incremental response cache entry.\n      const incrementalResponseCacheEntry = await fromResponseCacheEntry({\n        ...responseCacheEntry,\n        isMiss: !previousIncrementalCacheEntry,\n      })\n\n      // We want to persist the result only if it has a cache control value\n      // defined.\n      if (incrementalResponseCacheEntry.cacheControl) {\n        if (this.minimal_mode) {\n          this.previousCacheItem = {\n            key,\n            entry: incrementalResponseCacheEntry,\n            expiresAt: Date.now() + 1000,\n          }\n        } else {\n          await incrementalCache.set(key, incrementalResponseCacheEntry.value, {\n            cacheControl: incrementalResponseCacheEntry.cacheControl,\n            isRoutePPREnabled,\n            isFallback,\n          })\n        }\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // When a path is erroring we automatically re-set the existing cache\n      // with new revalidate and expire times to prevent non-stop retrying.\n      if (previousIncrementalCacheEntry?.cacheControl) {\n        const revalidate = Math.min(\n          Math.max(\n            previousIncrementalCacheEntry.cacheControl.revalidate || 3,\n            3\n          ),\n          30\n        )\n        const expire =\n          previousIncrementalCacheEntry.cacheControl.expire === undefined\n            ? undefined\n            : Math.max(\n                revalidate + 3,\n                previousIncrementalCacheEntry.cacheControl.expire\n              )\n\n        await incrementalCache.set(key, previousIncrementalCacheEntry.value, {\n          cacheControl: { revalidate: revalidate, expire: expire },\n          isRoutePPREnabled,\n          isFallback,\n        })\n      }\n\n      // We haven't resolved yet, so let's throw to indicate an error.\n      throw err\n    }\n  }\n}\n"],"names":["ResponseCache","constructor","minimal_mode","getBatcher","Batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","scheduleOnNextTick","revalidateBatcher","get","responseGenerator","context","hasResolved","previousCacheEntry","previousCacheItem","expiresAt","Date","now","toResponseCacheEntry","entry","incrementalCache","isFallback","isRoutePPREnabled","isPrefetch","waitUntil","routeKind","response","batch","resolve","promise","handleGet","previousIncrementalCacheEntry","resolved","kind","routeKindToIncrementalCacheKind","isStale","incrementalResponseCacheEntry","revalidate","undefined","err","console","error","handleRevalidate","responseCacheEntry","isRevalidating","fromResponseCacheEntry","isMiss","cacheControl","set","value","Math","min","max","expire"],"mappings":"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","ignoreList":[0]}