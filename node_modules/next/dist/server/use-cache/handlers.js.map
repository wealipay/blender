{"version":3,"sources":["../../../src/server/use-cache/handlers.ts"],"sourcesContent":["import { createDefaultCacheHandler } from '../lib/cache-handlers/default'\nimport type { CacheHandler } from '../lib/cache-handlers/types'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? (message: string, ...args: any[]) => {\n      console.log(`use-cache: ${message}`, ...args)\n    }\n  : undefined\n\nconst handlersSymbol = Symbol.for('@next/cache-handlers')\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */\nconst reference: typeof globalThis & {\n  [handlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  [handlersMapSymbol]?: Map<string, CacheHandler>\n  [handlersSetSymbol]?: Set<CacheHandler>\n} = globalThis\n\n/**\n * Initialize the cache handlers.\n * @param cacheMaxMemorySize - The maximum memory size of the cache in bytes, if\n *  not provided, the default memory size will be used.\n * @returns `true` if the cache handlers were initialized, `false` if they were already initialized.\n */\nexport function initializeCacheHandlers(cacheMaxMemorySize: number): boolean {\n  // If the cache handlers have already been initialized, don't do it again.\n  if (reference[handlersMapSymbol]) {\n    debug?.('cache handlers already initialized')\n    return false\n  }\n\n  debug?.('initializing cache handlers')\n  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n\n  // Initialize the cache from the symbol contents first.\n  if (reference[handlersSymbol]) {\n    let fallback: CacheHandler\n    if (reference[handlersSymbol].DefaultCache) {\n      debug?.('setting \"default\" cache handler from symbol')\n      fallback = reference[handlersSymbol].DefaultCache\n    } else {\n      debug?.('setting \"default\" cache handler from default')\n      fallback = createDefaultCacheHandler(cacheMaxMemorySize)\n    }\n\n    reference[handlersMapSymbol].set('default', fallback)\n\n    if (reference[handlersSymbol].RemoteCache) {\n      debug?.('setting \"remote\" cache handler from symbol')\n      reference[handlersMapSymbol].set(\n        'remote',\n        reference[handlersSymbol].RemoteCache\n      )\n    } else {\n      debug?.('setting \"remote\" cache handler from default')\n      reference[handlersMapSymbol].set('remote', fallback)\n    }\n  } else {\n    const handler = createDefaultCacheHandler(cacheMaxMemorySize)\n\n    debug?.('setting \"default\" cache handler from default')\n    reference[handlersMapSymbol].set('default', handler)\n    debug?.('setting \"remote\" cache handler from default')\n    reference[handlersMapSymbol].set('remote', handler)\n  }\n\n  // Create a set of the cache handlers.\n  reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())\n\n  return true\n}\n\n/**\n * Get a cache handler by kind.\n * @param kind - The kind of cache handler to get.\n * @returns The cache handler, or `undefined` if it does not exist.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandler(kind: string): CacheHandler | undefined {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  return reference[handlersMapSymbol].get(kind)\n}\n\n/**\n * Get a set iterator over the cache handlers.\n * @returns An iterator over the cache handlers, or `undefined` if they are not\n * initialized.\n */\nexport function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  if (!reference[handlersSetSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersSetSymbol].values()\n}\n\n/**\n * Get a map iterator over the cache handlers (keyed by kind).\n * @returns An iterator over the cache handler entries, or `undefined` if they\n * are not initialized.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandlerEntries():\n  | MapIterator<[string, CacheHandler]>\n  | undefined {\n  if (!reference[handlersMapSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersMapSymbol].entries()\n}\n\n/**\n * Set a cache handler by kind.\n * @param kind - The kind of cache handler to set.\n * @param cacheHandler - The cache handler to set.\n */\nexport function setCacheHandler(\n  kind: string,\n  cacheHandler: CacheHandler\n): void {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  debug?.('setting cache handler for \"%s\"', kind)\n  reference[handlersMapSymbol].set(kind, cacheHandler)\n  reference[handlersSetSymbol].add(cacheHandler)\n}\n"],"names":["getCacheHandler","getCacheHandlerEntries","getCacheHandlers","initializeCacheHandlers","setCacheHandler","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","message","args","console","log","undefined","handlersSymbol","Symbol","for","handlersMapSymbol","handlersSetSymbol","reference","globalThis","cacheMaxMemorySize","Map","fallback","DefaultCache","createDefaultCacheHandler","set","RemoteCache","handler","Set","values","kind","Error","get","entries","cacheHandler","add"],"mappings":"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","ignoreList":[0]}