{"version":3,"sources":["../../src/build/lockfile.ts"],"sourcesContent":["import { bold, cyan } from '../lib/picocolors'\nimport * as Log from './output/log'\n\nimport type { Binding, Lockfile as NativeLockfile } from './swc/types'\n\nconst RETRY_DELAY_MS = 10\nconst MAX_RETRY_MS = 1000\n\n/**\n * A cross-platform on-disk best-effort advisory exclusive lockfile\n * implementation.\n *\n * On Windows, this opens a file in write mode with the `FILE_SHARE_WRITE` flag\n * unset, so it still allows reading the lockfile. This avoids breaking tools\n * that read the contents of `.next`.\n *\n * On POSIX platforms, this uses `flock()` via `std::fs::File::try_lock`:\n * https://doc.rust-lang.org/std/fs/struct.File.html#method.try_lock\n *\n * On WASM, a dummy implementation is used which always \"succeeds\" in acquiring\n * the lock.\n *\n * This provides a more idiomatic wrapper around the lockfile APIs exposed on\n * the native bindings object.\n *\n * If this lock is not explicitly closed with `unlock`, we will:\n * - If `unlockOnExit` is set (the default), it will make a best-effort attempt\n *   to unlock the lockfile using `process.on('exit', ...)`. This is preferrable\n *   on Windows where it may take some time after process exit for the operating\n *   system to clean up locks that are not explicitly released by the process.\n * - If we fail to ever release the lockfile, the operating system will clean up\n *   the lock and file descriptor upon process exit.\n */\nexport class Lockfile {\n  /**\n   * The underlying `Lockfile` object returned by the native bindings.\n   *\n   * This can be `undefined` on wasm, where we don't acquire a real lockfile.\n   */\n  private bindings: Binding\n  private nativeLockfile: NativeLockfile | undefined\n  private listener: NodeJS.ExitListener | undefined\n\n  private constructor(\n    bindings: Binding,\n    nativeLockfile: NativeLockfile | undefined\n  ) {\n    this.bindings = bindings\n    this.nativeLockfile = nativeLockfile\n  }\n\n  /**\n   * Attempts to create or acquire an exclusive lockfile on disk. Lockfiles are\n   * best-effort, depending on the platform.\n   *\n   * - If we fail to acquire the lock, we return `undefined`.\n   * - If we're on wasm, this always returns a dummy `Lockfile` object.\n   */\n  static async tryAcquire(\n    path: string,\n    unlockOnExit: boolean = true\n  ): Promise<Lockfile | undefined> {\n    const { loadBindings } = require('./swc') as typeof import('./swc')\n    // Ideally we could provide a sync version of `tryAcquire`, but\n    // `loadBindings` is async. We're okay with skipping async-loaded wasm\n    // bindings and the internal `loadNative` function is synchronous, but it\n    // lacks some checks that `loadBindings` has.\n    const bindings = await loadBindings()\n    if (bindings.isWasm) {\n      Log.info(\n        `Skipping creating a lockfile at ${cyan(path)} because we're using WASM bindings`\n      )\n      return new Lockfile(bindings, undefined)\n    } else {\n      let nativeLockfile\n      try {\n        nativeLockfile = await bindings.lockfileTryAcquire(path)\n      } catch (e) {\n        // this happens if there's an IO error (e.g. `ENOENT`), which is\n        // different than if we just didn't acquire the lock\n        throw new Error(\n          'An IO error occurred while attempting to create and acquire the lockfile',\n          { cause: e }\n        )\n      }\n      if (nativeLockfile != null) {\n        const jsLockfile = new Lockfile(bindings, nativeLockfile)\n        if (unlockOnExit) {\n          const exitListener = () => {\n            // Best-Effort: If we don't do this, the operating system will\n            // release the lock for us. This gives an opportunity to delete the\n            // unlocked lockfile (which is not otherwise deleted on POSIX).\n            //\n            // This must be synchronous because `process.on('exit', ...)` is\n            // synchronous.\n            jsLockfile.unlockSync()\n          }\n          process.on('exit', exitListener)\n          jsLockfile.listener = exitListener\n        }\n        return jsLockfile\n      } else {\n        return undefined\n      }\n    }\n  }\n\n  /**\n   * Attempts to create or acquire a lockfile using `Lockfile.tryAcquire`. If\n   * that returns `undefined`, indicating that another process or caller has the\n   * lockfile, then this will output an error message and exit the process with\n   * a non-zero exit code.\n   *\n   * This will retry a small number of times. This can be useful when running\n   * processes in a loop, e.g. if cleanup isn't fully synchronous due to child\n   * parent/processes.\n   */\n  static async acquireWithRetriesOrExit(\n    path: string,\n    processName: string,\n    unlockOnExit: boolean = true\n  ): Promise<Lockfile> {\n    const startMs = Date.now()\n    let lockfile\n    while (Date.now() - startMs < MAX_RETRY_MS) {\n      lockfile = await Lockfile.tryAcquire(path, unlockOnExit)\n      if (lockfile !== undefined) break\n      await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS))\n    }\n    if (lockfile === undefined) {\n      Log.error(\n        `Unable to acquire lock at ${cyan(path)}, is another instance of ${cyan(processName)} running?`\n      )\n      Log.info(\n        `${bold('Suggestion:')} If you intended to restart ${cyan(processName)}, terminate the other process, and then try again.`\n      )\n      process.exit(1)\n    }\n    return lockfile\n  }\n\n  /**\n   * Releases the lockfile and closes the file descriptor.\n   *\n   * If this is not called, the lock will be released by the operating system\n   * when the file handle is closed during process exit.\n   */\n  async unlock(): Promise<void> {\n    const { nativeLockfile, listener } = this\n    if (nativeLockfile !== undefined) {\n      await this.bindings.lockfileUnlock(nativeLockfile)\n    }\n    if (listener !== undefined) {\n      process.off('exit', listener)\n    }\n  }\n\n  /**\n   * A blocking version of `unlock`.\n   */\n  unlockSync(): void {\n    const { nativeLockfile, listener } = this\n    if (nativeLockfile !== undefined) {\n      this.bindings.lockfileUnlockSync(nativeLockfile)\n    }\n    if (listener !== undefined) {\n      process.off('exit', listener)\n    }\n  }\n}\n"],"names":["Lockfile","RETRY_DELAY_MS","MAX_RETRY_MS","bindings","nativeLockfile","tryAcquire","path","unlockOnExit","loadBindings","require","isWasm","Log","info","cyan","undefined","lockfileTryAcquire","e","Error","cause","jsLockfile","exitListener","unlockSync","process","on","listener","acquireWithRetriesOrExit","processName","startMs","Date","now","lockfile","Promise","resolve","setTimeout","error","bold","exit","unlock","lockfileUnlock","off","lockfileUnlockSync"],"mappings":";;;;+BAiCaA;;;eAAAA;;;4BAjCc;6DACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIrB,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AA2Bd,MAAMF;IAUX,YACEG,QAAiB,EACjBC,cAA0C,CAC1C;QACA,IAAI,CAACD,QAAQ,GAAGA;QAChB,IAAI,CAACC,cAAc,GAAGA;IACxB;IAEA;;;;;;GAMC,GACD,aAAaC,WACXC,IAAY,EACZC,eAAwB,IAAI,EACG;QAC/B,MAAM,EAAEC,YAAY,EAAE,GAAGC,QAAQ;QACjC,+DAA+D;QAC/D,sEAAsE;QACtE,yEAAyE;QACzE,6CAA6C;QAC7C,MAAMN,WAAW,MAAMK;QACvB,IAAIL,SAASO,MAAM,EAAE;YACnBC,KAAIC,IAAI,CACN,CAAC,gCAAgC,EAAEC,IAAAA,gBAAI,EAACP,MAAM,kCAAkC,CAAC;YAEnF,OAAO,IAAIN,SAASG,UAAUW;QAChC,OAAO;YACL,IAAIV;YACJ,IAAI;gBACFA,iBAAiB,MAAMD,SAASY,kBAAkB,CAACT;YACrD,EAAE,OAAOU,GAAG;gBACV,gEAAgE;gBAChE,oDAAoD;gBACpD,MAAM,qBAGL,CAHK,IAAIC,MACR,4EACA;oBAAEC,OAAOF;gBAAE,IAFP,qBAAA;2BAAA;gCAAA;kCAAA;gBAGN;YACF;YACA,IAAIZ,kBAAkB,MAAM;gBAC1B,MAAMe,aAAa,IAAInB,SAASG,UAAUC;gBAC1C,IAAIG,cAAc;oBAChB,MAAMa,eAAe;wBACnB,8DAA8D;wBAC9D,mEAAmE;wBACnE,+DAA+D;wBAC/D,EAAE;wBACF,gEAAgE;wBAChE,eAAe;wBACfD,WAAWE,UAAU;oBACvB;oBACAC,QAAQC,EAAE,CAAC,QAAQH;oBACnBD,WAAWK,QAAQ,GAAGJ;gBACxB;gBACA,OAAOD;YACT,OAAO;gBACL,OAAOL;YACT;QACF;IACF;IAEA;;;;;;;;;GASC,GACD,aAAaW,yBACXnB,IAAY,EACZoB,WAAmB,EACnBnB,eAAwB,IAAI,EACT;QACnB,MAAMoB,UAAUC,KAAKC,GAAG;QACxB,IAAIC;QACJ,MAAOF,KAAKC,GAAG,KAAKF,UAAUzB,aAAc;YAC1C4B,WAAW,MAAM9B,SAASK,UAAU,CAACC,MAAMC;YAC3C,IAAIuB,aAAahB,WAAW;YAC5B,MAAM,IAAIiB,QAAQ,CAACC,UAAYC,WAAWD,SAAS/B;QACrD;QACA,IAAI6B,aAAahB,WAAW;YAC1BH,KAAIuB,KAAK,CACP,CAAC,0BAA0B,EAAErB,IAAAA,gBAAI,EAACP,MAAM,yBAAyB,EAAEO,IAAAA,gBAAI,EAACa,aAAa,SAAS,CAAC;YAEjGf,KAAIC,IAAI,CACN,GAAGuB,IAAAA,gBAAI,EAAC,eAAe,4BAA4B,EAAEtB,IAAAA,gBAAI,EAACa,aAAa,kDAAkD,CAAC;YAE5HJ,QAAQc,IAAI,CAAC;QACf;QACA,OAAON;IACT;IAEA;;;;;GAKC,GACD,MAAMO,SAAwB;QAC5B,MAAM,EAAEjC,cAAc,EAAEoB,QAAQ,EAAE,GAAG,IAAI;QACzC,IAAIpB,mBAAmBU,WAAW;YAChC,MAAM,IAAI,CAACX,QAAQ,CAACmC,cAAc,CAAClC;QACrC;QACA,IAAIoB,aAAaV,WAAW;YAC1BQ,QAAQiB,GAAG,CAAC,QAAQf;QACtB;IACF;IAEA;;GAEC,GACDH,aAAmB;QACjB,MAAM,EAAEjB,cAAc,EAAEoB,QAAQ,EAAE,GAAG,IAAI;QACzC,IAAIpB,mBAAmBU,WAAW;YAChC,IAAI,CAACX,QAAQ,CAACqC,kBAAkB,CAACpC;QACnC;QACA,IAAIoB,aAAaV,WAAW;YAC1BQ,QAAQiB,GAAG,CAAC,QAAQf;QACtB;IACF;AACF","ignoreList":[0]}