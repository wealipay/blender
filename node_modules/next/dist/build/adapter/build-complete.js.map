{"version":3,"sources":["../../../src/build/adapter/build-complete.ts"],"sourcesContent":["import path from 'path'\nimport fs from 'fs/promises'\nimport { pathToFileURL } from 'url'\nimport * as Log from '../output/log'\nimport { isMiddlewareFilename } from '../utils'\nimport { RenderingMode } from '../rendering-mode'\nimport { interopDefault } from '../../lib/interop-default'\nimport type { RouteHas } from '../../lib/load-custom-routes'\nimport { recursiveReadDir } from '../../lib/recursive-readdir'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { Revalidate } from '../../server/lib/cache-control'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { AdapterOutputType, type PHASE_TYPE } from '../../shared/lib/constants'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\nimport {\n  convertRedirects,\n  convertRewrites,\n  convertHeaders,\n} from 'next/dist/compiled/@vercel/routing-utils'\n\nimport type {\n  MiddlewareManifest,\n  EdgeFunctionDefinition,\n} from '../webpack/plugins/middleware-plugin'\n\nimport type {\n  RoutesManifest,\n  PrerenderManifest,\n  ManifestRewriteRoute,\n  FunctionsConfigManifest,\n  DynamicPrerenderManifestRoute,\n} from '..'\n\nimport {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../../lib/constants'\nimport { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { getRedirectStatus, modifyRouteRegex } from '../../lib/redirect-status'\nimport { getNamedRouteRegex } from '../../shared/lib/router/utils/route-regex'\nimport { escapeStringRegexp } from '../../shared/lib/escape-regexp'\nimport { sortSortableRoutes } from '../../shared/lib/router/utils/sortable-routes'\nimport { nodeFileTrace } from 'next/dist/compiled/@vercel/nft'\nimport { defaultOverrides } from '../../server/require-hook'\nimport { makeIgnoreFn } from '../collect-build-traces'\n\ninterface SharedRouteFields {\n  /**\n   * id is the unique identifier of the output\n   */\n  id: string\n  /**\n   * filePath is the location on disk of the built entrypoint asset\n   */\n  filePath: string\n  /**\n   * pathname is the URL pathname the asset should be served at\n   */\n  pathname: string\n\n  /**\n   * sourcePage is the original source in the app or pages folder\n   */\n  sourcePage: string\n\n  /**\n   * runtime is which runtime the entrypoint is built for\n   */\n  runtime: 'nodejs' | 'edge'\n  /**\n   * assets are all necessary traced assets that could be\n   * loaded by the output to handle a request e.g. traced\n   * node_modules or necessary manifests for Next.js.\n   * The key is the relative path from the repo root and the value\n   * is the absolute path to the file\n   */\n  assets: Record<string, string>\n\n  /**\n   * wasmAssets are bundled wasm files with mapping of name\n   * to filePath on disk\n   */\n  wasmAssets?: Record<string, string>\n\n  /**\n   * config related to the route\n   */\n  config: {\n    /**\n     * maxDuration is a segment config to signal the max\n     * execution duration a route should be allowed before\n     * it's timed out\n     */\n    maxDuration?: number\n    /**\n     * preferredRegion is a segment config to signal deployment\n     * region preferences to the provider being used\n     */\n    preferredRegion?: string | string[]\n\n    /**\n     * env is the environment variables to expose, this is only\n     * populated for edge runtime currently\n     */\n    env?: Record<string, string>\n  }\n}\n\nexport interface AdapterOutput {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES: SharedRouteFields & {\n    type: AdapterOutputType.PAGES\n  }\n\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API: SharedRouteFields & {\n    type: AdapterOutputType.PAGES_API\n  }\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE: SharedRouteFields & {\n    type: AdapterOutputType.APP_PAGE\n  }\n\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE: SharedRouteFields & {\n    type: AdapterOutputType.APP_ROUTE\n  }\n\n  /**\n   * `PRERENDER` represents an ISR enabled route that might\n   * have a seeded cache entry or fallback generated during build\n   */\n  PRERENDER: {\n    id: string\n    pathname: string\n    type: AdapterOutputType.PRERENDER\n\n    /**\n     * For prerenders the parent output is the originating\n     * page that the prerender is created from\n     */\n    parentOutputId: string\n\n    /**\n     * groupId is the identifier for a group of prerenders that should be\n     * revalidated together\n     */\n    groupId: number\n\n    pprChain?: {\n      headers: Record<string, string>\n    }\n\n    /**\n     * parentFallbackMode signals whether additional routes can be generated\n     * e.g. fallback: false or 'blocking' in getStaticPaths in pages router\n     */\n    parentFallbackMode?: DynamicPrerenderManifestRoute['fallback']\n\n    /**\n     * fallback is initial cache data generated during build for a prerender\n     */\n    fallback?: {\n      /**\n       * path to the fallback file can be HTML/JSON/RSC\n       */\n      filePath: string\n      /**\n       * initialStatus is the status code that should be applied\n       * when serving the fallback\n       */\n      initialStatus?: number\n      /**\n       * initialHeaders are the headers that should be sent when\n       * serving the fallback\n       */\n      initialHeaders?: Record<string, string | string[]>\n      /**\n       * initial expiration is how long until the fallback entry\n       * is considered expired and no longer valid to serve\n       */\n      initialExpiration?: number\n      /**\n       * initial revalidate is how long until the fallback is\n       * considered stale and should be revalidated\n       */\n      initialRevalidate?: Revalidate\n\n      /**\n       * postponedState is the PPR state when it postponed and is used for resuming\n       */\n      postponedState?: string\n    }\n    /**\n     * config related to the route\n     */\n    config: {\n      /**\n       * allowQuery is the allowed query values to be passed\n       * to an ISR function and what should be considered for the cacheKey\n       * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n       */\n      allowQuery?: string[]\n      /**\n       * allowHeader is the allowed headers to be passed to an\n       * ISR function to prevent accidentally poisoning the cache\n       * from leaking additional information that can impact the render\n       */\n      allowHeader?: string[]\n      /**\n       * bypass for is a list of has conditions the cache\n       * should be bypassed and invoked directly e.g. action header\n       */\n      bypassFor?: RouteHas[]\n      /**\n       * renderingMode signals PPR or not for a prerender\n       */\n      renderingMode?: RenderingMode\n\n      /**\n       * bypassToken is the generated token that signals a prerender cache\n       * should be bypassed\n       */\n      bypassToken?: string\n    }\n  }\n\n  /**\n   * `STATIC_FILE` represents a static file (ie /_next/static) or a purely\n   * static HTML asset e.g. an automatically statically optimized page\n   * that does not use ISR\n   */\n  STATIC_FILE: {\n    id: string\n    filePath: string\n    pathname: string\n    type: AdapterOutputType.STATIC_FILE\n  }\n\n  /**\n   * `MIDDLEWARE` represents the middleware output if present\n   */\n  MIDDLEWARE: SharedRouteFields & {\n    type: AdapterOutputType.MIDDLEWARE\n    /**\n     * config related to the route\n     */\n    config: SharedRouteFields['config'] & {\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: Array<{\n        source: string\n        sourceRegex: string\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n      }>\n    }\n  }\n}\n\nexport interface AdapterOutputs {\n  pages: Array<AdapterOutput['PAGES']>\n  middleware?: AdapterOutput['MIDDLEWARE']\n  appPages: Array<AdapterOutput['APP_PAGE']>\n  pagesApi: Array<AdapterOutput['PAGES_API']>\n  appRoutes: Array<AdapterOutput['APP_ROUTE']>\n  prerenders: Array<AdapterOutput['PRERENDER']>\n  staticFiles: Array<AdapterOutput['STATIC_FILE']>\n}\n\ntype RewriteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\ntype DynamicRouteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\nexport interface NextAdapter {\n  name: string\n  /**\n   * modifyConfig is called for any CLI command that loads the next.config\n   * to only apply for specific commands the \"phase\" should be used\n   * @param config\n   * @param ctx\n   * @returns\n   */\n  modifyConfig?: (\n    config: NextConfigComplete,\n    ctx: {\n      phase: PHASE_TYPE\n    }\n  ) => Promise<NextConfigComplete> | NextConfigComplete\n  onBuildComplete?: (ctx: {\n    routes: {\n      headers: Array<{\n        source: string\n        sourceRegex: string\n        headers: Record<string, string>\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n        priority?: boolean\n      }>\n      redirects: Array<{\n        source: string\n        sourceRegex: string\n        destination: string\n        statusCode: number\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n        priority?: boolean\n      }>\n      rewrites: {\n        beforeFiles: RewriteItem[]\n        afterFiles: RewriteItem[]\n        fallback: RewriteItem[]\n      }\n      dynamicRoutes: Array<DynamicRouteItem>\n    }\n    outputs: AdapterOutputs\n    /**\n     * projectDir is the absolute directory the Next.js application is in\n     */\n    projectDir: string\n    /**\n     * repoRoot is the absolute path of the detected root of the repo\n     */\n    repoRoot: string\n    /**\n     * distDir is the absolute path to the dist directory\n     */\n    distDir: string\n    /**\n     * config is the loaded next.config (has modifyConfig applied)\n     */\n    config: NextConfigComplete\n    /**\n     * nextVersion is the current version of Next.js being used\n     */\n    nextVersion: string\n    /**\n     * buildId is the current unique ID for the build, this can be\n     * influenced by NextConfig.generateBuildId\n     */\n    buildId: string\n  }) => Promise<void> | void\n}\n\nfunction normalizePathnames(\n  config: NextConfigComplete,\n  outputs: AdapterOutputs\n) {\n  // normalize pathname field with basePath\n  if (config.basePath) {\n    for (const output of [\n      ...outputs.pages,\n      ...outputs.pagesApi,\n      ...outputs.appPages,\n      ...outputs.appRoutes,\n      ...outputs.prerenders,\n      ...outputs.staticFiles,\n    ]) {\n      output.pathname =\n        addPathPrefix(output.pathname, config.basePath).replace(/\\/$/, '') ||\n        '/'\n    }\n  }\n}\n\nexport async function handleBuildComplete({\n  dir,\n  config,\n  buildId,\n  configOutDir,\n  distDir,\n  pageKeys,\n  tracingRoot,\n  adapterPath,\n  appPageKeys,\n  staticPages,\n  nextVersion,\n  hasStatic404,\n  hasStatic500,\n  routesManifest,\n  serverPropsPages,\n  hasNodeMiddleware,\n  prerenderManifest,\n  middlewareManifest,\n  requiredServerFiles,\n  hasInstrumentationHook,\n  functionsConfigManifest,\n}: {\n  dir: string\n  distDir: string\n  buildId: string\n  configOutDir: string\n  adapterPath: string\n  tracingRoot: string\n  nextVersion: string\n  hasStatic404: boolean\n  hasStatic500: boolean\n  staticPages: Set<string>\n  hasNodeMiddleware: boolean\n  config: NextConfigComplete\n  pageKeys: readonly string[]\n  serverPropsPages: Set<string>\n  requiredServerFiles: string[]\n  routesManifest: RoutesManifest\n  hasInstrumentationHook: boolean\n  prerenderManifest: PrerenderManifest\n  middlewareManifest: MiddlewareManifest\n  appPageKeys?: readonly string[] | undefined\n  functionsConfigManifest: FunctionsConfigManifest\n}) {\n  const adapterMod = interopDefault(\n    await import(pathToFileURL(require.resolve(adapterPath)).href)\n  ) as NextAdapter\n\n  if (typeof adapterMod.onBuildComplete === 'function') {\n    const outputs: AdapterOutputs = {\n      pages: [],\n      pagesApi: [],\n      appPages: [],\n      appRoutes: [],\n      prerenders: [],\n      staticFiles: [],\n    }\n\n    if (config.output === 'export') {\n      // collect export assets and provide as static files\n      const exportFiles = await recursiveReadDir(configOutDir)\n\n      for (const file of exportFiles) {\n        let pathname = (\n          file.endsWith('.html') ? file.replace(/\\.html$/, '') : file\n        ).replace(/\\\\/g, '/')\n\n        pathname = pathname.startsWith('/') ? pathname : `/${pathname}`\n\n        outputs.staticFiles.push({\n          id: file,\n          pathname,\n          filePath: path.join(configOutDir, file),\n          type: AdapterOutputType.STATIC_FILE,\n        } satisfies AdapterOutput['STATIC_FILE'])\n      }\n    } else {\n      const staticFiles = await recursiveReadDir(path.join(distDir, 'static'))\n\n      for (const file of staticFiles) {\n        const pathname = path.posix.join('/_next/static', file)\n        const filePath = path.join(distDir, 'static', file)\n        outputs.staticFiles.push({\n          type: AdapterOutputType.STATIC_FILE,\n          id: path.join('static', file),\n          pathname,\n          filePath,\n        })\n      }\n\n      const sharedNodeAssets: Record<string, string> = {}\n      const pagesSharedNodeAssets: Record<string, string> = {}\n      const appPagesSharedNodeAssets: Record<string, string> = {}\n\n      const sharedTraceIgnores = [\n        '**/next/dist/compiled/next-server/**/*.dev.js',\n        '**/next/dist/compiled/webpack/*',\n        '**/node_modules/webpack5/**/*',\n        '**/next/dist/server/lib/route-resolver*',\n        'next/dist/compiled/semver/semver/**/*.js',\n        '**/node_modules/react{,-dom,-dom-server-turbopack}/**/*.development.js',\n        '**/*.d.ts',\n        '**/*.map',\n        '**/next/dist/pages/**/*',\n        '**/node_modules/sharp/**/*',\n        '**/@img/sharp-libvips*/**/*',\n        '**/next/dist/compiled/edge-runtime/**/*',\n        '**/next/dist/server/web/sandbox/**/*',\n        '**/next/dist/server/post-process.js',\n      ]\n      const sharedIgnoreFn = makeIgnoreFn(tracingRoot, sharedTraceIgnores)\n\n      for (const file of requiredServerFiles) {\n        // add to shared node assets\n        const filePath = path.join(dir, file)\n        const fileOutputPath = path.relative(tracingRoot, filePath)\n        sharedNodeAssets[fileOutputPath] = filePath\n      }\n\n      const moduleTypes = ['app-page', 'pages'] as const\n\n      for (const type of moduleTypes) {\n        const currentDependencies: string[] = []\n        const modulePath = require.resolve(\n          `next/dist/server/route-modules/${type}/module.compiled`\n        )\n        const contextDir = path.join(\n          path.dirname(modulePath),\n          'vendored',\n          'contexts'\n        )\n\n        for (const item of await fs.readdir(contextDir)) {\n          if (item.match(/\\.(mjs|cjs|js)$/)) {\n            currentDependencies.push(path.join(contextDir, item))\n          }\n        }\n\n        const { fileList, esmFileList } = await nodeFileTrace(\n          currentDependencies,\n          {\n            base: tracingRoot,\n            ignore: sharedIgnoreFn,\n          }\n        )\n        esmFileList.forEach((item) => fileList.add(item))\n\n        for (const rootRelativeFilePath of fileList) {\n          if (type === 'pages') {\n            pagesSharedNodeAssets[rootRelativeFilePath] = path.join(\n              tracingRoot,\n              rootRelativeFilePath\n            )\n          } else {\n            appPagesSharedNodeAssets[rootRelativeFilePath] = path.join(\n              tracingRoot,\n              rootRelativeFilePath\n            )\n          }\n        }\n      }\n\n      // These are modules that are necessary for bootstrapping node env\n      const necessaryNodeDependencies = [\n        require.resolve('next/dist/server/node-environment'),\n        require.resolve('next/dist/server/require-hook'),\n        require.resolve('next/dist/server/node-polyfill-crypto'),\n        ...Object.values(defaultOverrides).filter((item) => path.extname(item)),\n      ]\n\n      const { fileList, esmFileList } = await nodeFileTrace(\n        necessaryNodeDependencies,\n        {\n          base: tracingRoot,\n          ignore: sharedIgnoreFn,\n        }\n      )\n      esmFileList.forEach((item) => fileList.add(item))\n\n      for (const rootRelativeFilePath of fileList) {\n        sharedNodeAssets[rootRelativeFilePath] = path.join(\n          tracingRoot,\n          rootRelativeFilePath\n        )\n      }\n\n      if (hasInstrumentationHook) {\n        const assets = await handleTraceFiles(\n          path.join(distDir, 'server', 'instrumentation.js.nft.json'),\n          'neutral'\n        )\n        const fileOutputPath = path.relative(\n          tracingRoot,\n          path.join(distDir, 'server', 'instrumentation.js')\n        )\n        sharedNodeAssets[fileOutputPath] = path.join(\n          distDir,\n          'server',\n          'instrumentation.js'\n        )\n        Object.assign(sharedNodeAssets, assets)\n      }\n\n      async function handleTraceFiles(\n        traceFilePath: string,\n        type: 'pages' | 'app' | 'neutral'\n      ): Promise<Record<string, string>> {\n        const assets: Record<string, string> = Object.assign(\n          {},\n          sharedNodeAssets,\n          type === 'pages' ? pagesSharedNodeAssets : {},\n          type === 'app' ? appPagesSharedNodeAssets : {}\n        )\n        const traceData = JSON.parse(\n          await fs.readFile(traceFilePath, 'utf8')\n        ) as {\n          files: string[]\n        }\n        const traceFileDir = path.dirname(traceFilePath)\n\n        for (const relativeFile of traceData.files) {\n          const tracedFilePath = path.join(traceFileDir, relativeFile)\n          const fileOutputPath = path.relative(tracingRoot, tracedFilePath)\n          assets[fileOutputPath] = tracedFilePath\n        }\n        return assets\n      }\n\n      async function handleEdgeFunction(\n        page: EdgeFunctionDefinition,\n        isMiddleware: boolean = false\n      ) {\n        let type: AdapterOutputType = AdapterOutputType.PAGES\n        const isAppPrefix = page.name.startsWith('app/')\n        const isAppPage = isAppPrefix && page.name.endsWith('/page')\n        const isAppRoute = isAppPrefix && page.name.endsWith('/route')\n        let currentOutputs: Array<\n          | AdapterOutput['PAGES']\n          | AdapterOutput['PAGES_API']\n          | AdapterOutput['APP_PAGE']\n          | AdapterOutput['APP_ROUTE']\n        > = outputs.pages\n\n        if (isMiddleware) {\n          type = AdapterOutputType.MIDDLEWARE\n        } else if (isAppPage) {\n          currentOutputs = outputs.appPages\n          type = AdapterOutputType.APP_PAGE\n        } else if (isAppRoute) {\n          currentOutputs = outputs.appRoutes\n          type = AdapterOutputType.APP_ROUTE\n        } else if (page.page.startsWith('/api')) {\n          currentOutputs = outputs.pagesApi\n          type = AdapterOutputType.PAGES_API\n        }\n\n        const route = page.page.replace(/^(app|pages)\\//, '')\n\n        const output: Omit<AdapterOutput[typeof type], 'type'> & {\n          type: any\n        } = {\n          type,\n          id: page.name,\n          runtime: 'edge',\n          sourcePage: route,\n          pathname: isAppPrefix ? normalizeAppPath(route) : route,\n          filePath: path.join(\n            distDir,\n            page.files.find(\n              (item) =>\n                item.startsWith('server/app') || item.startsWith('server/pages')\n            ) ||\n              // TODO: turbopack build doesn't name the main entry chunk\n              // identifiably so we don't know which to mark here but\n              // technically edge needs all chunks to load always so\n              // should this field even be provided?\n              page.files[0] ||\n              ''\n          ),\n          assets: {},\n          wasmAssets: {},\n          config: {\n            env: page.env,\n          },\n        }\n\n        function handleFile(file: string) {\n          const originalPath = path.join(distDir, file)\n          const fileOutputPath = path.join(\n            path.relative(tracingRoot, distDir),\n            file\n          )\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[fileOutputPath] = originalPath\n        }\n        for (const file of page.files) {\n          handleFile(file)\n        }\n        for (const item of [...(page.assets || [])]) {\n          handleFile(item.filePath)\n        }\n        for (const item of page.wasm || []) {\n          if (!output.wasmAssets) {\n            output.wasmAssets = {}\n          }\n          output.wasmAssets[item.name] = path.join(distDir, item.filePath)\n        }\n\n        if (type === AdapterOutputType.MIDDLEWARE) {\n          ;(output as AdapterOutput['MIDDLEWARE']).config.matchers =\n            page.matchers.map((item) => {\n              return {\n                source: item.originalSource,\n                sourceRegex: item.regexp,\n                has: item.has,\n                missing: [\n                  ...(item.missing || []),\n                  // always skip middleware for on-demand revalidate\n                  {\n                    type: 'header',\n                    key: 'x-prerender-revalidate',\n                    value: prerenderManifest.preview.previewModeId,\n                  },\n                ],\n              }\n            })\n          output.pathname = '/_middleware'\n          output.id = page.name\n          outputs.middleware = output\n        } else {\n          currentOutputs.push(output)\n        }\n\n        // need to add matching .rsc output\n        if (isAppPage) {\n          const rscPathname =\n            (output.pathname === '/' ? '/index' : output.pathname) + '.rsc'\n          outputs.appPages.push({\n            ...output,\n            pathname: rscPathname,\n            id: page.name + '.rsc',\n          })\n        }\n      }\n\n      const edgeFunctionHandlers: Promise<any>[] = []\n\n      for (const middleware of Object.values(middlewareManifest.middleware)) {\n        if (isMiddlewareFilename(middleware.name)) {\n          edgeFunctionHandlers.push(handleEdgeFunction(middleware, true))\n        }\n      }\n\n      for (const page of Object.values(middlewareManifest.functions)) {\n        edgeFunctionHandlers.push(handleEdgeFunction(page))\n      }\n      const pagesDistDir = path.join(distDir, 'server', 'pages')\n      const pageOutputMap: Record<\n        string,\n        AdapterOutput['PAGES'] | AdapterOutput['PAGES_API']\n      > = {}\n\n      const rscFallbackPath = path.join(distDir, 'server', 'rsc-fallback.json')\n\n      if (appPageKeys && appPageKeys.length > 0 && pageKeys.length > 0) {\n        await fs.writeFile(rscFallbackPath, '{}')\n      }\n\n      for (const page of pageKeys) {\n        if (page === '/_app' || page === '/_document') {\n          continue\n        }\n\n        if (middlewareManifest.functions.hasOwnProperty(page)) {\n          continue\n        }\n\n        const route = normalizePagePath(page)\n        const pageFile = path.join(pagesDistDir, `${route}.js`)\n\n        // if it's an auto static optimized page it's just\n        // a static file\n        if (staticPages.has(page)) {\n          if (config.i18n) {\n            for (const locale of config.i18n.locales || []) {\n              const localePage =\n                page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n              const localeOutput = {\n                id: localePage,\n                pathname: localePage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: path.join(\n                  pagesDistDir,\n                  `${normalizePagePath(localePage)}.html`\n                ),\n              } satisfies AdapterOutput['STATIC_FILE']\n\n              outputs.staticFiles.push(localeOutput)\n\n              if (appPageKeys && appPageKeys.length > 0) {\n                outputs.staticFiles.push({\n                  id: `${localePage}.rsc`,\n                  pathname: `${localePage}.rsc`,\n                  type: AdapterOutputType.STATIC_FILE,\n                  filePath: rscFallbackPath,\n                })\n              }\n            }\n          } else {\n            const staticOutput = {\n              id: page,\n              pathname: route,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: pageFile.replace(/\\.js$/, '.html'),\n            } satisfies AdapterOutput['STATIC_FILE']\n\n            outputs.staticFiles.push(staticOutput)\n\n            if (appPageKeys && appPageKeys.length > 0) {\n              outputs.staticFiles.push({\n                id: `${page}.rsc`,\n                pathname: `${route}.rsc`,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n          }\n          // if was a static file output don't create page output as well\n          continue\n        }\n\n        const pageTraceFile = `${pageFile}.nft.json`\n        const assets = await handleTraceFiles(pageTraceFile, 'pages').catch(\n          (err) => {\n            if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n              Log.warn(`Failed to locate traced assets for ${pageFile}`, err)\n            }\n            return {} as Record<string, string>\n          }\n        )\n        const functionConfig = functionsConfigManifest.functions[route] || {}\n        let sourcePage = route.replace(/^\\//, '')\n\n        sourcePage = sourcePage === 'api' ? 'api/index' : sourcePage\n\n        const output: AdapterOutput['PAGES'] | AdapterOutput['PAGES_API'] = {\n          id: route,\n          type: page.startsWith('/api')\n            ? AdapterOutputType.PAGES_API\n            : AdapterOutputType.PAGES,\n          filePath: pageTraceFile.replace(/\\.nft\\.json$/, ''),\n          pathname: route,\n          sourcePage,\n          assets,\n          runtime: 'nodejs',\n          config: {\n            maxDuration: functionConfig.maxDuration,\n            preferredRegion: functionConfig.regions,\n          },\n        }\n        pageOutputMap[page] = output\n\n        if (output.type === AdapterOutputType.PAGES) {\n          outputs.pages.push(output)\n\n          // if page is get server side props we need to create\n          // the _next/data output as well\n          if (serverPropsPages.has(page)) {\n            const dataPathname = path.posix.join(\n              '/_next/data',\n              buildId,\n              page + '.json'\n            )\n            outputs.pages.push({\n              ...output,\n              pathname: dataPathname,\n              id: dataPathname,\n            })\n          }\n\n          for (const locale of config.i18n?.locales || []) {\n            const localePage =\n              page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n            outputs.pages.push({\n              ...output,\n              id: localePage,\n              pathname: localePage,\n            })\n\n            if (serverPropsPages.has(page)) {\n              const dataPathname = path.posix.join(\n                '/_next/data',\n                buildId,\n                localePage + '.json'\n              )\n              outputs.pages.push({\n                ...output,\n                pathname: dataPathname,\n                id: dataPathname,\n              })\n            }\n          }\n        } else {\n          outputs.pagesApi.push(output)\n        }\n\n        if (appPageKeys && appPageKeys.length > 0) {\n          outputs.staticFiles.push({\n            id: `${output.id}.rsc`,\n            pathname: `${output.pathname}.rsc`,\n            type: AdapterOutputType.STATIC_FILE,\n            filePath: rscFallbackPath,\n          })\n        }\n      }\n\n      if (hasNodeMiddleware) {\n        const middlewareFile = path.join(distDir, 'server', 'middleware.js')\n        const middlewareTrace = `${middlewareFile}.nft.json`\n        const assets = await handleTraceFiles(middlewareTrace, 'neutral')\n        const functionConfig =\n          functionsConfigManifest.functions['/_middleware'] || {}\n\n        outputs.middleware = {\n          pathname: '/_middleware',\n          id: '/_middleware',\n          sourcePage: 'middleware',\n          assets,\n          type: AdapterOutputType.MIDDLEWARE,\n          runtime: 'nodejs',\n          filePath: middlewareFile,\n          config: {\n            matchers:\n              functionConfig.matchers?.map((item) => {\n                return {\n                  source: item.originalSource,\n                  sourceRegex: item.regexp,\n                  has: item.has,\n                  missing: [\n                    ...(item.missing || []),\n                    // always skip middleware for on-demand revalidate\n                    {\n                      type: 'header',\n                      key: 'x-prerender-revalidate',\n                      value: prerenderManifest.preview.previewModeId,\n                    },\n                  ],\n                }\n              }) || [],\n          },\n        } satisfies AdapterOutput['MIDDLEWARE']\n      }\n      const appOutputMap: Record<\n        string,\n        AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE']\n      > = {}\n      const appDistDir = path.join(distDir, 'server', 'app')\n\n      if (appPageKeys) {\n        for (const page of appPageKeys) {\n          if (middlewareManifest.functions.hasOwnProperty(page)) {\n            continue\n          }\n          const normalizedPage = normalizeAppPath(page)\n          const pageFile = path.join(appDistDir, `${page}.js`)\n          const pageTraceFile = `${pageFile}.nft.json`\n          const assets = await handleTraceFiles(pageTraceFile, 'app').catch(\n            (err) => {\n              Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n              return {} as Record<string, string>\n            }\n          )\n          const functionConfig =\n            functionsConfigManifest.functions[normalizedPage] || {}\n\n          const output: AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE'] =\n            {\n              pathname: normalizedPage,\n              id: normalizedPage,\n              sourcePage: page,\n              assets,\n              type: page.endsWith('/route')\n                ? AdapterOutputType.APP_ROUTE\n                : AdapterOutputType.APP_PAGE,\n              runtime: 'nodejs',\n              filePath: pageFile,\n              config: {\n                maxDuration: functionConfig.maxDuration,\n                preferredRegion: functionConfig.regions,\n              },\n            }\n          appOutputMap[normalizedPage] = output\n\n          if (output.type === AdapterOutputType.APP_PAGE) {\n            outputs.appPages.push({\n              ...output,\n              pathname:\n                (output.pathname === '/' ? '/index' : output.pathname) + '.rsc',\n              id: (output.id === '/' ? '/index' : output.pathname) + '.rsc',\n            })\n            outputs.appPages.push(output)\n          } else {\n            outputs.appRoutes.push(output)\n          }\n        }\n      }\n\n      const getParentOutput = (\n        srcRoute: string,\n        childRoute: string,\n        allowMissing?: boolean\n      ) => {\n        const normalizedSrcRoute = normalizeLocalePath(\n          srcRoute,\n          config.i18n?.locales || []\n        ).pathname\n        const parentOutput =\n          pageOutputMap[normalizedSrcRoute] || appOutputMap[normalizedSrcRoute]\n\n        if (!parentOutput && !allowMissing) {\n          console.error({\n            appOutputs: Object.keys(appOutputMap),\n            pageOutputs: Object.keys(pageOutputMap),\n          })\n          throw new Error(\n            `Invariant: failed to find source route ${srcRoute} for prerender ${childRoute}`\n          )\n        }\n        return parentOutput\n      }\n\n      const {\n        prefetchSegmentDirSuffix,\n        prefetchSegmentSuffix,\n        varyHeader,\n        didPostponeHeader,\n        contentTypeHeader: rscContentTypeHeader,\n      } = routesManifest.rsc\n\n      const handleAppMeta = async (\n        route: string,\n        initialOutput: AdapterOutput['PRERENDER'],\n        meta: {\n          postponed?: string\n          segmentPaths?: string[]\n        }\n      ) => {\n        if (meta.postponed && initialOutput.fallback) {\n          initialOutput.fallback.postponedState = meta.postponed\n        }\n\n        if (meta?.segmentPaths) {\n          const segmentsDir = path.join(\n            appDistDir,\n            `${route}${prefetchSegmentDirSuffix}`\n          )\n\n          for (const segmentPath of meta.segmentPaths) {\n            const outputSegmentPath =\n              path.join(route + prefetchSegmentDirSuffix, segmentPath) +\n              prefetchSegmentSuffix\n\n            const fallbackPathname = path.join(\n              segmentsDir,\n              segmentPath + prefetchSegmentSuffix\n            )\n\n            outputs.prerenders.push({\n              id: outputSegmentPath,\n              pathname: outputSegmentPath,\n              type: AdapterOutputType.PRERENDER,\n              parentOutputId: initialOutput.parentOutputId,\n              groupId: initialOutput.groupId,\n\n              config: {\n                ...initialOutput.config,\n              },\n\n              fallback: {\n                filePath: fallbackPathname,\n                initialExpiration: initialOutput.fallback?.initialExpiration,\n                initialRevalidate: initialOutput.fallback?.initialRevalidate,\n\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  vary: varyHeader,\n                  'content-type': rscContentTypeHeader,\n                  [didPostponeHeader]: '2',\n                },\n              },\n            } satisfies AdapterOutput['PRERENDER'])\n          }\n        }\n      }\n\n      let prerenderGroupId = 1\n\n      type AppRouteMeta = {\n        segmentPaths?: string[]\n        postponed?: string\n        headers?: Record<string, string>\n        status?: number\n      }\n\n      const getAppRouteMeta = async (\n        route: string,\n        isAppPage: boolean\n      ): Promise<AppRouteMeta> => {\n        const meta: AppRouteMeta = isAppPage\n          ? JSON.parse(\n              await fs\n                .readFile(path.join(appDistDir, `${route}.meta`), 'utf8')\n                .catch(() => '{}')\n            )\n          : {}\n\n        if (meta.headers) {\n          // normalize these for consistency\n          for (const key of Object.keys(meta.headers)) {\n            const keyLower = key.toLowerCase()\n            if (keyLower !== key) {\n              const value = meta.headers[key]\n              delete meta.headers[key]\n              meta.headers[keyLower] = value\n            }\n          }\n        }\n\n        return meta\n      }\n\n      const filePathCache = new Map<string, Promise<boolean>>()\n      const cachedFilePathCheck = async (filePath: string) => {\n        if (filePathCache.has(filePath)) {\n          return filePathCache.get(filePath)\n        }\n        const newCheck = fs\n          .access(filePath)\n          .then(() => true)\n          .catch(() => false)\n        filePathCache.set(filePath, newCheck)\n\n        return newCheck\n      }\n\n      for (const route in prerenderManifest.routes) {\n        const {\n          initialExpireSeconds: initialExpiration,\n          initialRevalidateSeconds: initialRevalidate,\n          initialHeaders,\n          initialStatus,\n          prefetchDataRoute,\n          dataRoute,\n          renderingMode,\n          allowHeader,\n          experimentalBypassFor,\n        } = prerenderManifest.routes[route]\n\n        const srcRoute = prerenderManifest.routes[route].srcRoute || route\n        const srcRouteInfo = prerenderManifest.dynamicRoutes[srcRoute]\n\n        const isAppPage =\n          Boolean(appOutputMap[srcRoute]) || srcRoute === '/_not-found'\n\n        const isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route)\n\n        let allowQuery: string[] | undefined\n        const routeKeys = routesManifest.dynamicRoutes.find(\n          (item) => item.page === srcRoute\n        )?.routeKeys\n\n        if (!isDynamicRoute(srcRoute)) {\n          // for non-dynamic routes we use an empty array since\n          // no query values bust the cache for non-dynamic prerenders\n          // prerendered paths also do not pass allowQuery as they match\n          // during handle: 'filesystem' so should not cache differently\n          // by query values\n          allowQuery = []\n        } else if (routeKeys) {\n          // if we have routeKeys in the routes-manifest we use those\n          // for allowQuery for dynamic routes\n          allowQuery = Object.values(routeKeys)\n        }\n\n        let filePath = path.join(\n          isAppPage ? appDistDir : pagesDistDir,\n          `${route === '/' ? 'index' : route}.${isAppPage && !dataRoute ? 'body' : 'html'}`\n        )\n\n        // we use the static 404 for notFound: true if available\n        // if not we do a blocking invoke on first request\n        if (isNotFoundTrue && hasStatic404) {\n          const locale =\n            config.i18n &&\n            normalizeLocalePath(route, config.i18n?.locales).detectedLocale\n\n          for (const currentFilePath of [\n            path.join(pagesDistDir, locale || '', '404.html'),\n            path.join(pagesDistDir, '404.html'),\n          ]) {\n            if (await cachedFilePathCheck(currentFilePath)) {\n              filePath = currentFilePath\n              break\n            }\n          }\n        }\n\n        const meta = await getAppRouteMeta(route, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: route,\n          type: AdapterOutputType.PRERENDER,\n          pathname: route,\n          parentOutputId:\n            srcRoute === '/_not-found'\n              ? srcRoute\n              : getParentOutput(srcRoute, route).id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && config.experimental.ppr\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          parentFallbackMode: srcRouteInfo?.fallback,\n\n          fallback:\n            !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n              ? {\n                  filePath,\n                  initialStatus:\n                    (initialStatus ?? isNotFoundTrue) ? 404 : undefined,\n                  initialHeaders: {\n                    ...initialHeaders,\n                    vary: varyHeader,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration,\n                  initialRevalidate:\n                    typeof initialRevalidate === 'undefined'\n                      ? 1\n                      : initialRevalidate,\n                }\n              : undefined,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (dataRoute) {\n          let dataFilePath = path.join(\n            pagesDistDir,\n            `${route === '/' ? 'index' : route}.json`\n          )\n\n          if (isAppPage) {\n            // When experimental PPR is enabled, we expect that the data\n            // that should be served as a part of the prerender should\n            // be from the prefetch data route. If this isn't enabled\n            // for ppr, the only way to get the data is from the data\n            // route.\n            dataFilePath = path.join(\n              appDistDir,\n              prefetchDataRoute &&\n                renderingMode === RenderingMode.PARTIALLY_STATIC\n                ? prefetchDataRoute\n                : dataRoute\n            )\n          }\n\n          outputs.prerenders.push({\n            ...initialOutput,\n            id: dataRoute,\n            pathname: dataRoute,\n            fallback: isNotFoundTrue\n              ? undefined\n              : {\n                  ...initialOutput.fallback,\n                  initialHeaders: {\n                    ...initialOutput.fallback?.initialHeaders,\n                    'content-type': isAppPage\n                      ? rscContentTypeHeader\n                      : JSON_CONTENT_TYPE_HEADER,\n                  },\n                  filePath: dataFilePath,\n                },\n          })\n        }\n\n        if (isAppPage) {\n          await handleAppMeta(route, initialOutput, meta)\n        }\n        prerenderGroupId += 1\n      }\n\n      for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n        const {\n          fallback,\n          fallbackExpire,\n          fallbackRevalidate,\n          fallbackHeaders,\n          fallbackStatus,\n          allowHeader,\n          dataRoute,\n          renderingMode,\n          experimentalBypassFor,\n        } = prerenderManifest.dynamicRoutes[dynamicRoute]\n\n        const isAppPage = Boolean(appOutputMap[dynamicRoute])\n\n        const allowQuery = Object.values(\n          routesManifest.dynamicRoutes.find(\n            (item) => item.page === dynamicRoute\n          )?.routeKeys || {}\n        )\n        const meta = await getAppRouteMeta(dynamicRoute, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: dynamicRoute,\n          type: AdapterOutputType.PRERENDER,\n          pathname: dynamicRoute,\n          parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,\n          groupId: prerenderGroupId,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n          fallback:\n            typeof fallback === 'string'\n              ? {\n                  filePath: path.join(\n                    isAppPage ? appDistDir : pagesDistDir,\n                    // app router dynamic route fallbacks don't have the\n                    // extension so ensure it's added here\n                    fallback.endsWith('.html') ? fallback : `${fallback}.html`\n                  ),\n                  initialStatus: fallbackStatus,\n                  initialHeaders: {\n                    ...fallbackHeaders,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                  },\n                  initialExpiration: fallbackExpire,\n                  initialRevalidate: fallbackRevalidate || 1,\n                }\n              : undefined,\n        }\n\n        if (!config.i18n || isAppPage) {\n          outputs.prerenders.push(initialOutput)\n\n          if (isAppPage) {\n            await handleAppMeta(dynamicRoute, initialOutput, meta)\n          }\n\n          if (dataRoute) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: undefined,\n            })\n          }\n          prerenderGroupId += 1\n        } else {\n          for (const locale of config.i18n.locales) {\n            const currentOutput = {\n              ...initialOutput,\n              pathname: path.posix.join(`/${locale}`, initialOutput.pathname),\n              id: path.posix.join(`/${locale}`, initialOutput.id),\n              fallback:\n                typeof fallback === 'string'\n                  ? {\n                      ...initialOutput.fallback,\n                      filePath: path.join(\n                        pagesDistDir,\n                        locale,\n                        // app router dynamic route fallbacks don't have the\n                        // extension so ensure it's added here\n                        fallback.endsWith('.html')\n                          ? fallback\n                          : `${fallback}.html`\n                      ),\n                    }\n                  : undefined,\n              groupId: prerenderGroupId,\n            }\n            outputs.prerenders.push(currentOutput)\n\n            if (dataRoute) {\n              const dataPathname = path.posix.join(\n                `/_next/data`,\n                buildId,\n                locale,\n                dynamicRoute + '.json'\n              )\n              outputs.prerenders.push({\n                ...initialOutput,\n                id: dataPathname,\n                pathname: dataPathname,\n                // data route doesn't have skeleton fallback\n                fallback: undefined,\n                groupId: prerenderGroupId,\n              })\n            }\n            prerenderGroupId += 1\n          }\n        }\n      }\n\n      // ensure 404\n      const staticErrorDocs = [\n        ...(hasStatic404 ? ['/404'] : []),\n        ...(hasStatic500 ? ['/500'] : []),\n      ]\n\n      for (const errorDoc of staticErrorDocs) {\n        const errorDocPath = path.posix.join(\n          '/',\n          config.i18n?.defaultLocale || '',\n          errorDoc\n        )\n\n        if (!prerenderManifest.routes[errorDocPath]) {\n          for (const currentDocPath of [\n            errorDocPath,\n            ...(config.i18n?.locales?.map((locale) =>\n              path.posix.join('/', locale, errorDoc)\n            ) || []),\n          ]) {\n            const currentFilePath = path.join(\n              pagesDistDir,\n              `${currentDocPath}.html`\n            )\n            if (await cachedFilePathCheck(currentFilePath)) {\n              outputs.staticFiles.push({\n                pathname: currentDocPath,\n                id: currentDocPath,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: currentFilePath,\n              })\n            }\n          }\n        }\n      }\n    }\n\n    normalizePathnames(config, outputs)\n\n    const dynamicRoutes: DynamicRouteItem[] = []\n    const dynamicDataRoutes: DynamicRouteItem[] = []\n    const dynamicSegmentRoutes: DynamicRouteItem[] = []\n\n    const getDestinationQuery = (routeKeys: Record<string, string>) => {\n      const items = Object.entries(routeKeys ?? {})\n      if (items.length === 0) return ''\n\n      return '?' + items.map(([key, value]) => `${value}=$${key}`).join('&')\n    }\n\n    const fallbackFalseHasCondition: RouteHas[] = [\n      {\n        type: 'cookie',\n        key: '__prerender_bypass',\n        value: prerenderManifest.preview.previewModeId,\n      },\n      {\n        type: 'cookie',\n        key: '__next_preview_data',\n      },\n    ]\n\n    for (const route of routesManifest.dynamicRoutes) {\n      const shouldLocalize = config.i18n\n\n      const routeRegex = getNamedRouteRegex(route.page, {\n        prefixRouteKeys: true,\n      })\n\n      const isFallbackFalse =\n        prerenderManifest.dynamicRoutes[route.page]?.fallback === false\n\n      const { hasFallbackRootParams } = route\n\n      const sourceRegex = routeRegex.namedRegex.replace(\n        '^',\n        `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})?' : ''}`\n      )\n      const destination =\n        path.posix.join(\n          '/',\n          config.basePath,\n          shouldLocalize ? '/$nextLocale' : '',\n          route.page\n        ) + getDestinationQuery(route.routeKeys)\n\n      if (\n        appPageKeys &&\n        appPageKeys.length > 0 &&\n        (config.experimental.cacheComponents ||\n          config.experimental.clientSegmentCache)\n      ) {\n        // If we have fallback root params (implying we've already\n        // emitted a rewrite for the /_tree request), or if the route\n        // has PPR enabled and client param parsing is enabled, then\n        // we don't need to include any other suffixes.\n        const shouldSkipSuffixes = hasFallbackRootParams\n\n        dynamicRoutes.push({\n          source: route.page + '.rsc',\n          sourceRegex: sourceRegex.replace(\n            new RegExp(escapeStringRegexp('(?:/)?$')),\n            // Now than the upstream issues has been resolved, we can safely\n            // add the suffix back, this resolves a bug related to segment\n            // rewrites not capturing the correct suffix values when\n            // enabled.\n            shouldSkipSuffixes\n              ? '(?<rscSuffix>\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n              : '(?<rscSuffix>\\\\.rsc|\\\\.prefetch\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n          ),\n          destination: destination?.replace(/($|\\?)/, '$rscSuffix$1'),\n          has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n          missing: undefined,\n        })\n      }\n\n      // needs basePath and locale handling if pages router\n      dynamicRoutes.push({\n        source: route.page,\n        sourceRegex,\n        destination,\n        has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n        missing: undefined,\n      })\n\n      for (const segmentRoute of route.prefetchSegmentDataRoutes || []) {\n        dynamicSegmentRoutes.push({\n          source: route.page,\n          sourceRegex: segmentRoute.source.replace(\n            '^',\n            `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?`\n          ),\n          destination: path.posix.join(\n            '/',\n            config.basePath,\n            segmentRoute.destination +\n              getDestinationQuery(segmentRoute.routeKeys)\n          ),\n          has: undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const needsMiddlewareResolveRoutes =\n      outputs.middleware && outputs.pages.length > 0\n\n    const dataRoutePages = new Set([\n      ...routesManifest.dataRoutes.map((item) => item.page),\n    ])\n    const sortedDataPages = sortSortableRoutes([\n      ...(needsMiddlewareResolveRoutes\n        ? [...staticPages].map((page) => ({ sourcePage: page, page }))\n        : []),\n      ...routesManifest.dataRoutes.map((item) => ({\n        sourcePage: item.page,\n        page: item.page,\n      })),\n    ])\n\n    for (const { page } of sortedDataPages) {\n      if (needsMiddlewareResolveRoutes || isDynamicRoute(page)) {\n        const shouldLocalize = config.i18n\n        const isFallbackFalse =\n          prerenderManifest.dynamicRoutes[page]?.fallback === false\n\n        const routeRegex = getNamedRouteRegex(page + '.json', {\n          prefixRouteKeys: true,\n          includeSuffix: true,\n        })\n        const destination = path.posix.join(\n          '/',\n          config.basePath,\n          ...(dataRoutePages.has(page) ? [`_next/data`, buildId] : ''),\n          ...(page === '/'\n            ? [shouldLocalize ? '$nextLocale.json' : 'index.json']\n            : [\n                shouldLocalize ? '$nextLocale' : '',\n                page +\n                  '.json' +\n                  getDestinationQuery(routeRegex.routeKeys || {}),\n              ])\n        )\n\n        dynamicDataRoutes.push({\n          source: page,\n          sourceRegex:\n            shouldLocalize && page === '/'\n              ? '^' +\n                path.posix.join(\n                  '/',\n                  config.basePath,\n                  '_next/data',\n                  escapeStringRegexp(buildId),\n                  '(?<nextLocale>[^/]{1,}).json'\n                )\n              : routeRegex.namedRegex.replace(\n                  '^',\n                  `^${path.posix.join(\n                    '/',\n                    config.basePath,\n                    `_next/data`,\n                    escapeStringRegexp(buildId)\n                  )}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})?' : ''}`\n                ),\n          destination,\n          has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const buildRewriteItem = (route: ManifestRewriteRoute): RewriteItem => {\n      const converted = convertRewrites([route], ['nextInternalLocale'])[0]\n      const regex = converted.src || route.regex\n\n      return {\n        source: route.source,\n        sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n        destination: converted.dest || route.destination,\n        has: route.has,\n        missing: route.missing,\n      }\n    }\n\n    try {\n      Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n      await adapterMod.onBuildComplete({\n        routes: {\n          dynamicRoutes: [\n            ...dynamicDataRoutes,\n            ...dynamicSegmentRoutes,\n            ...dynamicRoutes,\n          ],\n          rewrites: {\n            beforeFiles:\n              routesManifest.rewrites.beforeFiles.map(buildRewriteItem),\n            afterFiles:\n              routesManifest.rewrites.afterFiles.map(buildRewriteItem),\n            fallback: routesManifest.rewrites.fallback.map(buildRewriteItem),\n          },\n          redirects: routesManifest.redirects.map((route) => {\n            const converted = convertRedirects([route], 307)[0]\n            let dest = 'headers' in converted && converted.headers?.Location\n            const regex = converted.src || route.regex\n\n            return {\n              source: route.source,\n              sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n              destination: dest || route.destination,\n              statusCode: converted.status || getRedirectStatus(route),\n              has: route.has,\n              missing: route.missing,\n              priority: route.internal || undefined,\n            }\n          }),\n          headers: routesManifest.headers.map((route) => {\n            const converted = convertHeaders([route])[0]\n            const regex = converted.src || route.regex\n\n            return {\n              source: route.source,\n              sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n              headers: 'headers' in converted ? converted.headers || {} : {},\n              has: route.has,\n              missing: route.missing,\n              priority: route.internal || undefined,\n            }\n          }),\n        },\n        outputs,\n\n        config,\n        distDir,\n        buildId,\n        nextVersion,\n        projectDir: dir,\n        repoRoot: tracingRoot,\n      })\n    } catch (err) {\n      Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)\n      throw err\n    }\n  }\n}\n"],"names":["handleBuildComplete","normalizePathnames","config","outputs","basePath","output","pages","pagesApi","appPages","appRoutes","prerenders","staticFiles","pathname","addPathPrefix","replace","dir","buildId","configOutDir","distDir","pageKeys","tracingRoot","adapterPath","appPageKeys","staticPages","nextVersion","hasStatic404","hasStatic500","routesManifest","serverPropsPages","hasNodeMiddleware","prerenderManifest","middlewareManifest","requiredServerFiles","hasInstrumentationHook","functionsConfigManifest","adapterMod","interopDefault","pathToFileURL","require","resolve","href","onBuildComplete","exportFiles","recursiveReadDir","file","endsWith","startsWith","push","id","filePath","path","join","type","AdapterOutputType","STATIC_FILE","posix","sharedNodeAssets","pagesSharedNodeAssets","appPagesSharedNodeAssets","sharedTraceIgnores","sharedIgnoreFn","makeIgnoreFn","fileOutputPath","relative","moduleTypes","currentDependencies","modulePath","contextDir","dirname","item","fs","readdir","match","fileList","esmFileList","nodeFileTrace","base","ignore","forEach","add","rootRelativeFilePath","necessaryNodeDependencies","Object","values","defaultOverrides","filter","extname","assets","handleTraceFiles","assign","traceFilePath","traceData","JSON","parse","readFile","traceFileDir","relativeFile","files","tracedFilePath","handleEdgeFunction","page","isMiddleware","PAGES","isAppPrefix","name","isAppPage","isAppRoute","currentOutputs","MIDDLEWARE","APP_PAGE","APP_ROUTE","PAGES_API","route","runtime","sourcePage","normalizeAppPath","find","wasmAssets","env","handleFile","originalPath","wasm","matchers","map","source","originalSource","sourceRegex","regexp","has","missing","key","value","preview","previewModeId","middleware","rscPathname","edgeFunctionHandlers","isMiddlewareFilename","functions","pagesDistDir","pageOutputMap","rscFallbackPath","length","writeFile","hasOwnProperty","normalizePagePath","pageFile","i18n","locale","locales","localePage","localeOutput","staticOutput","pageTraceFile","catch","err","code","Log","warn","functionConfig","maxDuration","preferredRegion","regions","dataPathname","middlewareFile","middlewareTrace","appOutputMap","appDistDir","normalizedPage","getParentOutput","srcRoute","childRoute","allowMissing","normalizedSrcRoute","normalizeLocalePath","parentOutput","console","error","appOutputs","keys","pageOutputs","Error","prefetchSegmentDirSuffix","prefetchSegmentSuffix","varyHeader","didPostponeHeader","contentTypeHeader","rscContentTypeHeader","rsc","handleAppMeta","initialOutput","meta","postponed","fallback","postponedState","segmentPaths","segmentsDir","segmentPath","outputSegmentPath","fallbackPathname","PRERENDER","parentOutputId","groupId","initialExpiration","initialRevalidate","initialHeaders","vary","prerenderGroupId","getAppRouteMeta","headers","keyLower","toLowerCase","filePathCache","Map","cachedFilePathCheck","get","newCheck","access","then","set","routes","initialExpireSeconds","initialRevalidateSeconds","initialStatus","prefetchDataRoute","dataRoute","renderingMode","allowHeader","experimentalBypassFor","srcRouteInfo","dynamicRoutes","Boolean","isNotFoundTrue","notFoundRoutes","includes","allowQuery","routeKeys","isDynamicRoute","detectedLocale","currentFilePath","pprChain","experimental","ppr","NEXT_RESUME_HEADER","undefined","parentFallbackMode","HTML_CONTENT_TYPE_HEADER","bypassFor","bypassToken","dataFilePath","RenderingMode","PARTIALLY_STATIC","JSON_CONTENT_TYPE_HEADER","dynamicRoute","fallbackExpire","fallbackRevalidate","fallbackHeaders","fallbackStatus","currentOutput","staticErrorDocs","errorDoc","errorDocPath","defaultLocale","currentDocPath","dynamicDataRoutes","dynamicSegmentRoutes","getDestinationQuery","items","entries","fallbackFalseHasCondition","shouldLocalize","routeRegex","getNamedRouteRegex","prefixRouteKeys","isFallbackFalse","hasFallbackRootParams","namedRegex","destination","cacheComponents","clientSegmentCache","shouldSkipSuffixes","RegExp","escapeStringRegexp","segmentRoute","prefetchSegmentDataRoutes","needsMiddlewareResolveRoutes","dataRoutePages","Set","dataRoutes","sortedDataPages","sortSortableRoutes","includeSuffix","buildRewriteItem","converted","convertRewrites","regex","src","internal","modifyRouteRegex","dest","info","rewrites","beforeFiles","afterFiles","redirects","convertRedirects","Location","statusCode","status","getRedirectStatus","priority","convertHeaders","projectDir","repoRoot"],"mappings":"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","ignoreList":[0]}