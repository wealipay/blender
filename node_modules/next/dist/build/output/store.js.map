{"version":3,"sources":["../../../src/build/output/store.ts"],"sourcesContent":["import createStore from 'next/dist/compiled/unistore'\nimport { type Span, flushAllTraces, trace } from '../../trace'\nimport { teardownTraceSubscriber } from '../swc'\nimport * as Log from './log'\n\nconst MAX_LOG_SKIP_DURATION_MS = 3000\n\nexport type OutputState =\n  | {\n      bootstrap: true\n      appUrl: string | null\n      bindAddr: string | null\n      logging: boolean\n    }\n  | ({\n      bootstrap: false\n      appUrl: string | null\n      bindAddr: string | null\n      logging: boolean\n    } & (\n      | {\n          loading: true\n          trigger: string | undefined\n          url: string | undefined\n        }\n      | {\n          loading: false\n          typeChecking: boolean\n          totalModulesCount: number\n          errors: string[] | null\n          warnings: string[] | null\n          hasEdgeServer: boolean\n        }\n    ))\n\nexport function formatTrigger(trigger: string) {\n  // Format dynamic sitemap routes to simpler file path\n  // e.g., /sitemap.xml[] -> /sitemap.xml\n  if (trigger.includes('[__metadata_id__]')) {\n    trigger = trigger.replace('/[__metadata_id__]', '/[id]')\n  }\n\n  if (trigger.length > 1 && trigger.endsWith('/')) {\n    trigger = trigger.slice(0, -1)\n  }\n  return trigger\n}\n\nexport const store = createStore<OutputState>({\n  appUrl: null,\n  bindAddr: null,\n  bootstrap: true,\n  logging: true,\n})\n\nlet lastStore: OutputState = {\n  appUrl: null,\n  bindAddr: null,\n  bootstrap: true,\n  logging: true,\n}\nfunction hasStoreChanged(nextStore: OutputState) {\n  if (\n    (\n      [\n        ...new Set([...Object.keys(lastStore), ...Object.keys(nextStore)]),\n      ] as Array<keyof OutputState>\n    ).every((key) => Object.is(lastStore[key], nextStore[key]))\n  ) {\n    return false\n  }\n\n  lastStore = nextStore\n  return true\n}\n\nlet startTime = 0\nlet trigger = '' // default, use empty string for trigger\nlet triggerUrl: string | undefined = undefined\nlet loadingLogTimer: NodeJS.Timeout | null = null\nlet traceSpan: Span | null = null\nlet logging = true\n\nstore.subscribe((state) => {\n  // Update persisted logging state\n  if ('logging' in state) {\n    logging = state.logging\n  }\n\n  // If logging is disabled, do not log\n  if (!logging) {\n    return\n  }\n\n  if (!hasStoreChanged(state)) {\n    return\n  }\n\n  if (state.bootstrap) {\n    return\n  }\n\n  if (state.loading) {\n    if (state.trigger) {\n      trigger = formatTrigger(state.trigger)\n      triggerUrl = state.url\n      if (trigger !== 'initial') {\n        traceSpan = trace('compile-path', undefined, {\n          trigger: trigger,\n        })\n        if (!loadingLogTimer) {\n          // Only log compiling if compiled is not finished quickly\n          loadingLogTimer = setTimeout(() => {\n            if (\n              triggerUrl &&\n              triggerUrl !== trigger &&\n              process.env.NEXT_TRIGGER_URL\n            ) {\n              Log.wait(`Compiling ${trigger} (${triggerUrl}) ...`)\n            } else {\n              Log.wait(`Compiling ${trigger} ...`)\n            }\n          }, MAX_LOG_SKIP_DURATION_MS)\n        }\n      }\n    }\n    if (startTime === 0) {\n      startTime = Date.now()\n    }\n    return\n  }\n\n  if (state.errors) {\n    // Log compilation errors\n    Log.error(state.errors[0])\n\n    startTime = 0\n    // Ensure traces are flushed after each compile in development mode\n    flushAllTraces()\n    teardownTraceSubscriber()\n    return\n  }\n\n  let timeMessage = ''\n  if (startTime) {\n    const time = Date.now() - startTime\n    startTime = 0\n\n    timeMessage =\n      ' ' +\n      (time > 2000 ? `in ${Math.round(time / 100) / 10}s` : `in ${time}ms`)\n  }\n\n  let modulesMessage = ''\n  if (state.totalModulesCount) {\n    modulesMessage = ` (${state.totalModulesCount} modules)`\n  }\n\n  if (state.warnings) {\n    Log.warn(state.warnings.join('\\n\\n'))\n    // Ensure traces are flushed after each compile in development mode\n    flushAllTraces()\n    teardownTraceSubscriber()\n    return\n  }\n\n  if (state.typeChecking) {\n    Log.info(\n      `bundled ${trigger}${timeMessage}${modulesMessage}, type checking...`\n    )\n    return\n  }\n\n  if (trigger === 'initial') {\n    trigger = ''\n  } else {\n    if (loadingLogTimer) {\n      clearTimeout(loadingLogTimer)\n      loadingLogTimer = null\n    }\n    if (traceSpan) {\n      traceSpan.stop()\n      traceSpan = null\n    }\n    trigger = ''\n  }\n\n  // Ensure traces are flushed after each compile in development mode\n  flushAllTraces()\n  teardownTraceSubscriber()\n})\n"],"names":["formatTrigger","store","MAX_LOG_SKIP_DURATION_MS","trigger","includes","replace","length","endsWith","slice","createStore","appUrl","bindAddr","bootstrap","logging","lastStore","hasStoreChanged","nextStore","Set","Object","keys","every","key","is","startTime","triggerUrl","undefined","loadingLogTimer","traceSpan","subscribe","state","loading","url","trace","setTimeout","process","env","NEXT_TRIGGER_URL","Log","wait","Date","now","errors","error","flushAllTraces","teardownTraceSubscriber","timeMessage","time","Math","round","modulesMessage","totalModulesCount","warnings","warn","join","typeChecking","info","clearTimeout","stop"],"mappings":"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","ignoreList":[0]}