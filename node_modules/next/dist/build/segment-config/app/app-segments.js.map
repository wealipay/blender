{"version":3,"sources":["../../../../src/build/segment-config/app/app-segments.ts"],"sourcesContent":["import type { Params } from '../../../server/request/params'\nimport type { AppPageRouteModule } from '../../../server/route-modules/app-page/module.compiled'\nimport type { AppRouteRouteModule } from '../../../server/route-modules/app-route/module.compiled'\nimport {\n  type AppSegmentConfig,\n  parseAppSegmentConfig,\n} from './app-segment-config'\n\nimport { InvariantError } from '../../../shared/lib/invariant-error'\nimport {\n  isAppRouteRouteModule,\n  isAppPageRouteModule,\n} from '../../../server/route-modules/checks'\nimport { isClientReference } from '../../../lib/client-and-server-references'\nimport { getSegmentParam } from '../../../shared/lib/router/utils/get-segment-param'\nimport {\n  getLayoutOrPageModule,\n  type LoaderTree,\n} from '../../../server/lib/app-dir-module'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { FallbackRouteParam } from '../../static-paths/types'\nimport { createFallbackRouteParam } from '../../static-paths/utils'\nimport type { DynamicParamTypes } from '../../../shared/lib/app-router-types'\n\ntype GenerateStaticParams = (options: { params?: Params }) => Promise<Params[]>\n\n/**\n * Parses the app config and attaches it to the segment.\n */\nfunction attach(segment: AppSegment, userland: unknown, route: string) {\n  // If the userland is not an object, then we can't do anything with it.\n  if (typeof userland !== 'object' || userland === null) {\n    return\n  }\n\n  // Try to parse the application configuration.\n  const config = parseAppSegmentConfig(userland, route)\n\n  // If there was any keys on the config, then attach it to the segment.\n  if (Object.keys(config).length > 0) {\n    segment.config = config\n  }\n\n  if (\n    'generateStaticParams' in userland &&\n    typeof userland.generateStaticParams === 'function'\n  ) {\n    segment.generateStaticParams =\n      userland.generateStaticParams as GenerateStaticParams\n\n    // Validate that `generateStaticParams` makes sense in this context.\n    if (segment.config?.runtime === 'edge') {\n      throw new Error(\n        'Edge runtime is not supported with `generateStaticParams`.'\n      )\n    }\n  }\n}\n\nexport type AppSegment = {\n  name: string\n  paramName: string | undefined\n  paramType: DynamicParamTypes | undefined\n  filePath: string | undefined\n  config: AppSegmentConfig | undefined\n  isDynamicSegment: boolean\n  generateStaticParams: GenerateStaticParams | undefined\n\n  /**\n   * Whether this segment is a parallel route segment or descends from a\n   * parallel route segment.\n   */\n  isParallelRouteSegment: boolean | undefined\n}\n\n/**\n * Walks the loader tree and collects the generate parameters for each segment.\n *\n * @param routeModule the app page route module\n * @returns the segments for the app page route module\n */\nasync function collectAppPageSegments(routeModule: AppPageRouteModule) {\n  // We keep track of unique segments, since with parallel routes, it's possible\n  // to see the same segment multiple times.\n  const uniqueSegments = new Map<string, AppSegment>()\n\n  // Queue will store tuples of [loaderTree, currentSegments, isParallelRouteSegment]\n  type QueueItem = [\n    loaderTree: LoaderTree,\n    currentSegments: AppSegment[],\n    isParallelRouteSegment: boolean,\n  ]\n  const queue: QueueItem[] = [[routeModule.userland.loaderTree, [], false]]\n\n  while (queue.length > 0) {\n    const [loaderTree, currentSegments, isParallelRouteSegment] = queue.shift()!\n    const [name, parallelRoutes] = loaderTree\n\n    // Process current node\n    const { mod: userland, filePath } = await getLayoutOrPageModule(loaderTree)\n    const isClientComponent = userland && isClientReference(userland)\n\n    const { param: paramName, type: paramType } = getSegmentParam(name) ?? {}\n\n    const segment: AppSegment = {\n      name,\n      paramName,\n      paramType,\n      filePath,\n      config: undefined,\n      isDynamicSegment: !!paramName,\n      generateStaticParams: undefined,\n      isParallelRouteSegment,\n    }\n\n    // Only server components can have app segment configurations\n    if (!isClientComponent) {\n      attach(segment, userland, routeModule.definition.pathname)\n    }\n\n    // Create a unique key for the segment\n    const segmentKey = getSegmentKey(segment)\n    if (!uniqueSegments.has(segmentKey)) {\n      uniqueSegments.set(segmentKey, segment)\n    }\n\n    const updatedSegments = [...currentSegments, segment]\n\n    // If this is a page segment, we've reached a leaf node\n    if (name === PAGE_SEGMENT_KEY) {\n      // Add all segments in the current path, preferring non-parallel segments\n      updatedSegments.forEach((seg) => {\n        const key = getSegmentKey(seg)\n        if (!uniqueSegments.has(key)) {\n          uniqueSegments.set(key, seg)\n        }\n      })\n    }\n\n    // Add all parallel routes to the queue\n    for (const parallelRouteKey in parallelRoutes) {\n      const parallelRoute = parallelRoutes[parallelRouteKey]\n      queue.push([\n        parallelRoute,\n        updatedSegments,\n        // A parallel route segment is one that descends from a segment that is\n        // not children or descends from a parallel route segment.\n        isParallelRouteSegment || parallelRouteKey !== 'children',\n      ])\n    }\n  }\n\n  return Array.from(uniqueSegments.values())\n}\n\nfunction getSegmentKey(segment: AppSegment) {\n  return `${segment.name}-${segment.filePath ?? ''}-${segment.paramName ?? ''}-${segment.isParallelRouteSegment ? 'pr' : 'np'}`\n}\n\n/**\n * Collects the segments for a given app route module.\n *\n * @param routeModule the app route module\n * @returns the segments for the app route module\n */\nfunction collectAppRouteSegments(\n  routeModule: AppRouteRouteModule\n): AppSegment[] {\n  // Get the pathname parts, slice off the first element (which is empty).\n  const parts = routeModule.definition.pathname.split('/').slice(1)\n  if (parts.length === 0) {\n    throw new InvariantError('Expected at least one segment')\n  }\n\n  // Generate all the segments.\n  const segments: AppSegment[] = parts.map((name) => {\n    const { param: paramName, type: paramType } = getSegmentParam(name) ?? {}\n\n    return {\n      name,\n      paramName,\n      paramType,\n      filePath: undefined,\n      isDynamicSegment: !!paramName,\n      config: undefined,\n      generateStaticParams: undefined,\n      isParallelRouteSegment: undefined,\n    } satisfies AppSegment\n  })\n\n  // We know we have at least one, we verified this above. We should get the\n  // last segment which represents the root route module.\n  const segment = segments[segments.length - 1]\n\n  segment.filePath = routeModule.definition.filename\n\n  // Extract the segment config from the userland module.\n  attach(segment, routeModule.userland, routeModule.definition.pathname)\n\n  return segments\n}\n\n/**\n * Collects the segments for a given route module.\n *\n * @param components the loaded components\n * @returns the segments for the route module\n */\nexport function collectSegments(\n  routeModule: AppRouteRouteModule | AppPageRouteModule\n): Promise<AppSegment[]> | AppSegment[] {\n  if (isAppRouteRouteModule(routeModule)) {\n    return collectAppRouteSegments(routeModule)\n  }\n\n  if (isAppPageRouteModule(routeModule)) {\n    return collectAppPageSegments(routeModule)\n  }\n\n  throw new InvariantError(\n    'Expected a route module to be one of app route or page'\n  )\n}\n\n/**\n * Collects the fallback route params for a given app page route module. This is\n * a variant of the `collectSegments` function that only collects the fallback\n * route params without importing anything.\n *\n * @param routeModule the app page route module\n * @returns the fallback route params for the app page route module\n */\nexport function collectFallbackRouteParams(\n  routeModule: AppPageRouteModule\n): readonly FallbackRouteParam[] {\n  const uniqueSegments = new Map<string, FallbackRouteParam>()\n\n  // Queue will store tuples of [loaderTree, isParallelRouteSegment]\n  type QueueItem = [loaderTree: LoaderTree, isParallelRouteSegment: boolean]\n  const queue: QueueItem[] = [[routeModule.userland.loaderTree, false]]\n\n  while (queue.length > 0) {\n    const [loaderTree, isParallelRouteSegment] = queue.shift()!\n    const [name, parallelRoutes] = loaderTree\n\n    // Handle this segment (if it's a dynamic segment param).\n    const segmentParam = getSegmentParam(name)\n    if (segmentParam) {\n      const key = `${name}-${segmentParam.param}-${isParallelRouteSegment ? 'pr' : 'np'}`\n      if (!uniqueSegments.has(key)) {\n        uniqueSegments.set(\n          key,\n          createFallbackRouteParam(\n            segmentParam.param,\n            segmentParam.type,\n            isParallelRouteSegment\n          )\n        )\n      }\n    }\n\n    // Add all of this segment's parallel routes to the queue.\n    for (const parallelRouteKey in parallelRoutes) {\n      const parallelRoute = parallelRoutes[parallelRouteKey]\n      queue.push([\n        parallelRoute,\n        // A parallel route segment is one that descends from a segment that is\n        // not children or descends from a parallel route segment.\n        isParallelRouteSegment || parallelRouteKey !== 'children',\n      ])\n    }\n  }\n\n  return Array.from(uniqueSegments.values())\n}\n"],"names":["collectFallbackRouteParams","collectSegments","attach","segment","userland","route","config","parseAppSegmentConfig","Object","keys","length","generateStaticParams","runtime","Error","collectAppPageSegments","routeModule","uniqueSegments","Map","queue","loaderTree","currentSegments","isParallelRouteSegment","shift","name","parallelRoutes","mod","filePath","getLayoutOrPageModule","isClientComponent","isClientReference","param","paramName","type","paramType","getSegmentParam","undefined","isDynamicSegment","definition","pathname","segmentKey","getSegmentKey","has","set","updatedSegments","PAGE_SEGMENT_KEY","forEach","seg","key","parallelRouteKey","parallelRoute","push","Array","from","values","collectAppRouteSegments","parts","split","slice","InvariantError","segments","map","filename","isAppRouteRouteModule","isAppPageRouteModule","segmentParam","createFallbackRouteParam"],"mappings":"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","ignoreList":[0]}